{"file_contents":{"utils/export_utils.py":{"content":"import pandas as pd\nimport io\nfrom datetime import datetime\nfrom reportlab.lib.pagesizes import letter, A4\nfrom reportlab.lib import colors\nfrom reportlab.lib.units import inch\nfrom reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak, Image\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT\nfrom reportlab.pdfgen import canvas\nimport plotly.graph_objects as go\nimport plotly.io as pio\nimport tempfile\nimport os\n\ndef create_pdf_report(transactions_df, customers_df, products_df, filters):\n    \"\"\"\n    Genera reporte PDF profesional con gráficos y análisis\n    \"\"\"\n    buffer = io.BytesIO()\n    \n    # Crear documento\n    doc = SimpleDocTemplate(\n        buffer,\n        pagesize=letter,\n        rightMargin=72,\n        leftMargin=72,\n        topMargin=72,\n        bottomMargin=18,\n    )\n    \n    # Estilos\n    styles = getSampleStyleSheet()\n    title_style = ParagraphStyle(\n        'CustomTitle',\n        parent=styles['Heading1'],\n        fontSize=24,\n        textColor=colors.HexColor('#1E40AF'),\n        spaceAfter=30,\n        alignment=TA_CENTER\n    )\n    \n    heading_style = ParagraphStyle(\n        'CustomHeading',\n        parent=styles['Heading2'],\n        fontSize=16,\n        textColor=colors.HexColor('#1E40AF'),\n        spaceAfter=12,\n        spaceBefore=12\n    )\n    \n    # Contenido\n    story = []\n    \n    # Título\n    title = Paragraph(\"Global Ecommerce Analytics Report\", title_style)\n    story.append(title)\n    \n    # Fecha\n    date_text = Paragraph(\n        f\"<para align=center>Generado: {datetime.now().strftime('%Y-%m-%d %H:%M')}</para>\",\n        styles['Normal']\n    )\n    story.append(date_text)\n    story.append(Spacer(1, 20))\n    \n    # KPIs principales\n    story.append(Paragraph(\"Resumen Ejecutivo\", heading_style))\n    \n    total_revenue = transactions_df['total_amount_usd'].sum()\n    total_orders = len(transactions_df)\n    total_customers = transactions_df['customer_id'].nunique()\n    avg_order_value = transactions_df['total_amount_usd'].mean()\n    total_profit = transactions_df['profit'].sum()\n    \n    kpi_data = [\n        ['Métrica', 'Valor'],\n        ['Total Revenue', f'${total_revenue:,.2f}'],\n        ['Total Orders', f'{total_orders:,}'],\n        ['Total Customers', f'{total_customers:,}'],\n        ['Avg Order Value', f'${avg_order_value:.2f}'],\n        ['Gross Profit', f'${total_profit:,.2f}'],\n        ['Profit Margin', f'{(total_profit/total_revenue*100):.1f}%']\n    ]\n    \n    kpi_table = Table(kpi_data, colWidths=[3*inch, 3*inch])\n    kpi_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1E40AF')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 12),\n        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black)\n    ]))\n    \n    story.append(kpi_table)\n    story.append(Spacer(1, 20))\n    \n    # Top 10 países\n    story.append(Paragraph(\"Top 10 Países por Revenue\", heading_style))\n    \n    country_data = transactions_df.groupby('country').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index().nlargest(10, 'total_amount_usd')\n    \n    country_table_data = [['País', 'Revenue', 'Orders']]\n    for _, row in country_data.iterrows():\n        country_table_data.append([\n            row['country'],\n            f\"${row['total_amount_usd']:,.0f}\",\n            f\"{row['transaction_id']:,}\"\n        ])\n    \n    country_table = Table(country_table_data, colWidths=[2*inch, 2*inch, 2*inch])\n    country_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#10B981')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 10),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])\n    ]))\n    \n    story.append(country_table)\n    story.append(Spacer(1, 20))\n    \n    # Top 10 productos\n    story.append(Paragraph(\"Top 10 Productos por Revenue\", heading_style))\n    \n    product_data = transactions_df.groupby(['product_id', 'product_name', 'category']).agg({\n        'total_amount_usd': 'sum',\n        'quantity': 'sum'\n    }).reset_index().nlargest(10, 'total_amount_usd')\n    \n    product_table_data = [['Producto', 'Categoría', 'Revenue', 'Units']]\n    for _, row in product_data.iterrows():\n        product_name = row['product_name'][:30] + '...' if len(row['product_name']) > 30 else row['product_name']\n        product_table_data.append([\n            product_name,\n            row['category'],\n            f\"${row['total_amount_usd']:,.0f}\",\n            f\"{row['quantity']:,}\"\n        ])\n    \n    product_table = Table(product_table_data, colWidths=[2.5*inch, 1.5*inch, 1.5*inch, 0.5*inch])\n    product_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#F59E0B')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 10),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])\n    ]))\n    \n    story.append(product_table)\n    story.append(Spacer(1, 20))\n    \n    # Análisis de categorías\n    story.append(Paragraph(\"Revenue por Categoría\", heading_style))\n    \n    category_data = transactions_df.groupby('category').agg({\n        'total_amount_usd': 'sum',\n        'profit': 'sum'\n    }).reset_index().sort_values('total_amount_usd', ascending=False)\n    \n    category_table_data = [['Categoría', 'Revenue', 'Profit', 'Margin %']]\n    for _, row in category_data.iterrows():\n        margin = (row['profit'] / row['total_amount_usd'] * 100) if row['total_amount_usd'] > 0 else 0\n        category_table_data.append([\n            row['category'],\n            f\"${row['total_amount_usd']:,.0f}\",\n            f\"${row['profit']:,.0f}\",\n            f\"{margin:.1f}%\"\n        ])\n    \n    category_table = Table(category_table_data, colWidths=[2*inch, 1.5*inch, 1.5*inch, 1*inch])\n    category_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#8B5CF6')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 10),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])\n    ]))\n    \n    story.append(category_table)\n    \n    # Construir PDF\n    doc.build(story)\n    buffer.seek(0)\n    \n    return buffer\n\ndef create_excel_report(transactions_df, customers_df, products_df, filters):\n    \"\"\"\n    Genera reporte Excel con múltiples hojas y análisis\n    \"\"\"\n    buffer = io.BytesIO()\n    \n    with pd.ExcelWriter(buffer, engine='openpyxl') as writer:\n        # Hoja 1: Resumen\n        summary_data = {\n            'Métrica': [\n                'Total Revenue',\n                'Total Orders',\n                'Total Customers',\n                'Avg Order Value',\n                'Gross Profit',\n                'Profit Margin (%)',\n                'Total Products',\n                'Total Categories'\n            ],\n            'Valor': [\n                f\"${transactions_df['total_amount_usd'].sum():,.2f}\",\n                f\"{len(transactions_df):,}\",\n                f\"{transactions_df['customer_id'].nunique():,}\",\n                f\"${transactions_df['total_amount_usd'].mean():.2f}\",\n                f\"${transactions_df['profit'].sum():,.2f}\",\n                f\"{(transactions_df['profit'].sum()/transactions_df['total_amount_usd'].sum()*100):.2f}\",\n                f\"{transactions_df['product_id'].nunique():,}\",\n                f\"{transactions_df['category'].nunique():,}\"\n            ]\n        }\n        summary_df = pd.DataFrame(summary_data)\n        summary_df.to_excel(writer, sheet_name='Resumen', index=False)\n        \n        # Hoja 2: Transacciones (últimas 1000)\n        transactions_export = transactions_df[[\n            'transaction_id', 'date', 'customer_id', 'country', 'product_name',\n            'category', 'quantity', 'unit_price', 'total_amount_usd', 'profit',\n            'payment_method', 'device_type'\n        ]].head(1000)\n        transactions_export.to_excel(writer, sheet_name='Transacciones', index=False)\n        \n        # Hoja 3: Análisis por país\n        country_analysis = transactions_df.groupby('country').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count',\n            'customer_id': 'nunique',\n            'profit': 'sum'\n        }).reset_index()\n        country_analysis.columns = ['País', 'Revenue', 'Orders', 'Customers', 'Profit']\n        country_analysis = country_analysis.sort_values('Revenue', ascending=False)\n        country_analysis.to_excel(writer, sheet_name='Por País', index=False)\n        \n        # Hoja 4: Análisis por categoría\n        category_analysis = transactions_df.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count',\n            'quantity': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        category_analysis.columns = ['Categoría', 'Revenue', 'Orders', 'Units Sold', 'Profit']\n        category_analysis['Profit Margin %'] = (category_analysis['Profit'] / category_analysis['Revenue'] * 100).round(2)\n        category_analysis = category_analysis.sort_values('Revenue', ascending=False)\n        category_analysis.to_excel(writer, sheet_name='Por Categoría', index=False)\n        \n        # Hoja 5: Top productos\n        product_analysis = transactions_df.groupby(['product_id', 'product_name', 'category']).agg({\n            'total_amount_usd': 'sum',\n            'quantity': 'sum',\n            'transaction_id': 'count',\n            'profit': 'sum'\n        }).reset_index()\n        product_analysis.columns = ['Product ID', 'Product Name', 'Category', 'Revenue', 'Units', 'Orders', 'Profit']\n        product_analysis = product_analysis.nlargest(100, 'Revenue')\n        product_analysis.to_excel(writer, sheet_name='Top 100 Productos', index=False)\n        \n        # Hoja 6: Clientes VIP (top 100 por LTV)\n        top_customers = customers_df.nlargest(100, 'lifetime_value')[[\n            'customer_id', 'country', 'rfm_segment', 'lifetime_value',\n            'total_orders', 'avg_order_value', 'churn_probability'\n        ]]\n        top_customers.to_excel(writer, sheet_name='Clientes VIP', index=False)\n        \n        # Hoja 7: Segmentación RFM\n        rfm_analysis = customers_df.groupby('rfm_segment').agg({\n            'customer_id': 'count',\n            'lifetime_value': 'mean',\n            'total_orders': 'mean',\n            'churn_probability': 'mean'\n        }).reset_index()\n        rfm_analysis.columns = ['Segmento RFM', 'Clientes', 'LTV Promedio', 'Orders Promedio', 'Churn Prob Promedio']\n        rfm_analysis = rfm_analysis.sort_values('LTV Promedio', ascending=False)\n        rfm_analysis.to_excel(writer, sheet_name='Segmentación RFM', index=False)\n        \n        # Hoja 8: Time series (últimos 90 días)\n        transactions_df['date_only'] = pd.to_datetime(transactions_df['date']).dt.date\n        time_series = transactions_df.groupby('date_only').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count'\n        }).reset_index().tail(90)\n        time_series.columns = ['Fecha', 'Revenue', 'Orders']\n        time_series.to_excel(writer, sheet_name='Serie Temporal', index=False)\n    \n    buffer.seek(0)\n    return buffer\n","size_bytes":12018},"app.py":{"content":"\"\"\"\nDashboard Avanzado de Analytics Ecommerce Global\nAutor: cmsr92\nVersión: 2.0\nPlataforma profesional de Business Intelligence con ML, IA y Análisis Predictivo\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport folium\nfrom streamlit_folium import st_folium\nfrom datetime import datetime, timedelta\nimport warnings\nwarnings.filterwarnings('ignore')\n\nst.set_page_config(\n    page_title=\"Analytics Ecommerce Global | cmsr92\",\n    page_icon=\"📊\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\nfrom utils.ui_components import (\n    aplicar_estilos_globales, crear_header_principal, crear_tarjeta_kpi,\n    crear_seccion_titulo, crear_pie_pagina, mostrar_info_dataset,\n    crear_descripcion_seccion, crear_insight, crear_recomendaciones\n)\nfrom utils.filtros import crear_filtros_sidebar, aplicar_filtros\nfrom utils.data_loader_pg import load_or_generate_data\nfrom utils.traducciones import obtener_labels_profesionales\n\n# Labels profesionales para gráficos\nLABELS = obtener_labels_profesionales()\n\n# Aplicar estilos globales con detección automática de tema del navegador\naplicar_estilos_globales()\n\n@st.cache_data(ttl=60)\ndef cargar_datos():\n    return load_or_generate_data()\n\ntransacciones_df, clientes_df, productos_df = cargar_datos()\n\nif transacciones_df is None or clientes_df is None or productos_df is None:\n    st.error(\"❌ Error al cargar los datos. Por favor recarga la página.\")\n    st.stop()\n\ncrear_header_principal(\n    \"📊 Analytics Ecommerce Global\",\n    \"Plataforma Avanzada de Business Intelligence, Machine Learning y Análisis Predictivo\"\n)\n\nfiltros = crear_filtros_sidebar(transacciones_df)\ndatos_filtrados = aplicar_filtros(transacciones_df, filtros)\n\nif len(datos_filtrados) == 0:\n    st.warning(\"⚠️ No hay datos que coincidan con los filtros seleccionados. Ajusta los criterios de búsqueda.\")\n    st.stop()\n\ntab_overview, tab_geografia, tab_rendimiento, tab_productos, tab_clientes, tab_canal, tab_ml, tab_finanzas, tab_operacional = st.tabs([\n    \"🏠 Resumen General\",\n    \"🌍 Análisis Geográfico\",\n    \"📈 Rendimiento & Análisis Temporal\",\n    \"📦 Análisis de Productos\",\n    \"👥 Segmentación de Clientes\",\n    \"📱 Análisis de Canal\",\n    \"🤖 ML & IA Insights\",\n    \"💰 Análisis Financiero\",\n    \"⚙️ Métricas Operacionales\"\n])\n\nwith tab_overview:\n    crear_descripcion_seccion(\n        \"Resumen Ejecutivo\",\n        \"Esta sección presenta una visión general del rendimiento del negocio. Los KPIs principales muestran la salud financiera, \"\n        \"el volumen de operaciones y la eficiencia comercial. Utiliza los filtros del sidebar para analizar períodos específicos, \"\n        \"regiones geográficas o segmentos de clientes.\"\n    )\n    \n    crear_seccion_titulo(\"Indicadores Clave de Rendimiento (KPIs)\")\n    \n    # Explicación de KPIs\n    with st.expander(\"ℹ️ ¿Qué significan estos indicadores?\", expanded=False):\n        st.markdown(\"\"\"\n        **💰 Ingresos Totales:** Suma de todas las ventas en el período seleccionado. El símbolo % muestra el cambio respecto al período anterior equivalente.\n        \n        **🛒 Pedidos Totales:** Número total de transacciones completadas. Un aumento indica mayor actividad comercial.\n        \n        **🎯 Ticket Promedio (AOV):** Valor promedio por pedido. Se calcula dividiendo ingresos totales entre número de pedidos. Un AOV alto indica clientes que compran más por transacción.\n        \n        **💎 Beneficio Total:** Ganancia neta después de costos. Se calcula como: Ingresos - Costos. Indica la rentabilidad real del negocio.\n        \n        **👥 Clientes Únicos:** Número de clientes diferentes que realizaron al menos una compra.\n        \n        **📦 Productos Vendidos:** Cantidad de productos distintos que se vendieron en el período.\n        \n        **🎯 Tasa de Conversión:** Porcentaje de clientes únicos respecto al total de pedidos. Una tasa cercana a 100% indica que cada pedido corresponde a un cliente diferente (baja repetición).\n        \n        **📊 Items por Pedido:** Promedio de artículos incluidos en cada transacción. Útil para estrategias de bundling y cross-selling.\n        \"\"\")\n    \n    ingresos_totales = datos_filtrados['total_amount_usd'].sum()\n    pedidos_totales = len(datos_filtrados)\n    ticket_promedio = datos_filtrados['total_amount_usd'].mean()\n    beneficio_total = datos_filtrados['profit'].sum()\n    clientes_unicos = datos_filtrados['customer_id'].nunique()\n    margen_promedio = (beneficio_total / ingresos_totales * 100) if ingresos_totales > 0 else 0\n    \n    fecha_inicio_comparacion = filtros['fecha_inicio'] - (filtros['fecha_fin'] - filtros['fecha_inicio'])\n    \n    # Aplicar LOS MISMOS filtros al período anterior (excepto fechas) para comparación válida\n    filtros_periodo_anterior_overview = filtros.copy()\n    filtros_periodo_anterior_overview['fecha_inicio'] = fecha_inicio_comparacion\n    filtros_periodo_anterior_overview['fecha_fin'] = filtros['fecha_inicio'] - pd.Timedelta(days=1)\n    \n    datos_periodo_anterior = aplicar_filtros(transacciones_df, filtros_periodo_anterior_overview)\n    \n    ingresos_anteriores = datos_periodo_anterior['total_amount_usd'].sum()\n    cambio_ingresos = ((ingresos_totales - ingresos_anteriores) / ingresos_anteriores * 100) if ingresos_anteriores > 0 else 0\n    \n    pedidos_anteriores = len(datos_periodo_anterior)\n    cambio_pedidos = ((pedidos_totales - pedidos_anteriores) / pedidos_anteriores * 100) if pedidos_anteriores > 0 else 0\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\n            label=\"💰 Ingresos Totales\",\n            value=f\"${ingresos_totales:,.0f}\",\n            delta=f\"{cambio_ingresos:+.1f}%\" if ingresos_anteriores > 0 else None\n        )\n    \n    with col2:\n        st.metric(\n            label=\"🛒 Pedidos Totales\",\n            value=f\"{pedidos_totales:,}\",\n            delta=f\"{cambio_pedidos:+.1f}%\" if pedidos_anteriores > 0 else None\n        )\n    \n    with col3:\n        st.metric(\n            label=\"🎯 Ticket Promedio (AOV)\",\n            value=f\"${ticket_promedio:,.0f}\"\n        )\n    \n    with col4:\n        st.metric(\n            label=\"💎 Beneficio Total\",\n            value=f\"${beneficio_total:,.0f}\"\n        )\n    \n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    \n    col5, col6, col7, col8 = st.columns(4)\n    \n    with col5:\n        st.metric(\n            label=\"👥 Clientes Únicos\",\n            value=f\"{clientes_unicos:,}\"\n        )\n    \n    with col6:\n        productos_unicos = datos_filtrados['product_id'].nunique()\n        st.metric(\n            label=\"📦 Productos Vendidos\",\n            value=f\"{productos_unicos:,}\"\n        )\n    \n    with col7:\n        tasa_conversion = (clientes_unicos / pedidos_totales * 100) if pedidos_totales > 0 else 0\n        st.metric(\n            label=\"🎯 Tasa de Conversión\",\n            value=f\"{tasa_conversion:.1f}%\"\n        )\n    \n    with col8:\n        items_promedio = datos_filtrados['quantity'].mean()\n        st.metric(\n            label=\"📊 Items por Pedido\",\n            value=f\"{items_promedio:.1f}\"\n        )\n    \n    # Sección de Insights Ejecutivos Automáticos\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    crear_seccion_titulo(\"💡 Insights Ejecutivos y Recomendaciones\")\n    \n    # Calcular métricas adicionales para insights (con protección contra división por cero)\n    if ingresos_totales > 0:\n        top_pais = datos_filtrados.groupby('country')['total_amount_usd'].sum().idxmax()\n        ingresos_top_pais = datos_filtrados.groupby('country')['total_amount_usd'].sum().max()\n        porcentaje_top_pais = (ingresos_top_pais / ingresos_totales * 100)\n        \n        top_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().idxmax()\n        ingresos_top_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().max()\n        porcentaje_top_categoria = (ingresos_top_categoria / ingresos_totales * 100)\n    else:\n        top_pais = \"N/A\"\n        ingresos_top_pais = 0\n        porcentaje_top_pais = 0\n        top_categoria = \"N/A\"\n        ingresos_top_categoria = 0\n        porcentaje_top_categoria = 0\n    \n    # Generar insights automáticos\n    insights_ejecutivos = []\n    \n    # Verificar si hay datos suficientes para generar insights\n    if ingresos_totales == 0 or pedidos_totales == 0:\n        insights_ejecutivos.append(\n            f\"ℹ️ **Sin Datos Disponibles:** No hay transacciones registradas en el período y filtros seleccionados. \"\n            f\"Ajusta los criterios de búsqueda en el sidebar para analizar diferentes períodos o segmentos.\"\n        )\n    else:\n        # Insight 1: Rendimiento general\n        if cambio_ingresos > 10:\n            insights_ejecutivos.append(\n                f\"📈 **Crecimiento Acelerado:** Los ingresos han crecido un {cambio_ingresos:.1f}% comparado con el período anterior, \"\n                f\"superando ${ingresos_totales:,.0f}. Este momentum positivo indica una fuerte demanda y efectividad en las estrategias comerciales.\"\n            )\n        elif cambio_ingresos < -10:\n            insights_ejecutivos.append(\n                f\"⚠️ **Alerta de Desaceleración:** Los ingresos han disminuido un {abs(cambio_ingresos):.1f}% comparado con el período anterior. \"\n                f\"Se recomienda revisar estrategias de marketing, competencia y satisfacción del cliente.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"📊 **Estabilidad Controlada:** Los ingresos se mantienen estables con una variación de {cambio_ingresos:+.1f}% respecto al período anterior, \"\n                f\"totalizando ${ingresos_totales:,.0f}. Existen oportunidades de optimización para impulsar el crecimiento.\"\n            )\n        \n        # Insight 2: Concentración geográfica\n        if porcentaje_top_pais > 50:\n            insights_ejecutivos.append(\n                f\"🌍 **Concentración de Mercado:** {top_pais} representa el {porcentaje_top_pais:.1f}% de los ingresos totales \"\n                f\"(${ingresos_top_pais:,.0f}). Esta alta dependencia presenta riesgo. Se recomienda diversificar geográficamente.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"🌍 **Diversificación Saludable:** {top_pais} lidera con {porcentaje_top_pais:.1f}% de ingresos, pero existe buena \"\n                f\"distribución geográfica, reduciendo el riesgo de dependencia de un solo mercado.\"\n            )\n        \n        # Insight 3: Producto estrella\n        insights_ejecutivos.append(\n            f\"⭐ **Categoría Líder:** {top_categoria} domina el portafolio con {porcentaje_top_categoria:.1f}% de los ingresos \"\n            f\"(${ingresos_top_categoria:,.0f}). Reforzar inventario y marketing en esta categoría puede maximizar resultados.\"\n        )\n        \n        # Insight 4: Eficiencia operativa\n        if ticket_promedio > 100:\n            insights_ejecutivos.append(\n                f\"💎 **Alto Valor por Transacción:** El ticket promedio de ${ticket_promedio:,.0f} indica clientes de alto valor. \"\n                f\"Enfocar estrategias de retención y programas VIP puede aumentar la rentabilidad.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"🎯 **Oportunidad de Upselling:** Con un ticket promedio de ${ticket_promedio:,.0f}, existe potencial para incrementar \"\n                f\"el valor por pedido mediante bundling, recomendaciones personalizadas y ofertas complementarias.\"\n            )\n    \n    # Mostrar insights\n    for insight in insights_ejecutivos:\n        crear_insight(\"\", insight)\n    \n    # Recomendaciones accionables\n    recomendaciones_ejecutivas = [\n        f\"🔍 **Análisis Geográfico:** Explorar la pestaña 'Análisis Geográfico' para identificar mercados emergentes con alto potencial de crecimiento\",\n        f\"📊 **Forecasting:** Revisar las predicciones en 'Forecasting & Tendencias' para planificar inventario y presupuestos de los próximos 90 días\",\n        f\"👥 **Segmentación:** Analizar 'Segmentación de Clientes' para identificar clientes Champions y en riesgo de churn, personalizando estrategias\",\n        f\"🤖 **ML Insights:** Activar análisis ML en el sidebar para detectar anomalías, patrones ocultos y oportunidades de optimización automática\",\n        f\"💰 **Análisis Financiero:** Verificar márgenes y rentabilidad en 'Análisis Financiero' para asegurar la salud del negocio\"\n    ]\n    \n    crear_recomendaciones(\"🎯 Acciones Recomendadas\", recomendaciones_ejecutivas)\n    \n    crear_seccion_titulo(\"Evolución Temporal\")\n    \n    datos_temporales = datos_filtrados.copy()\n    datos_temporales['fecha'] = pd.to_datetime(datos_temporales['date'])\n    datos_temporales_agrupados = datos_temporales.groupby(datos_temporales['fecha'].dt.to_period('M')).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count',\n        'profit': 'sum'\n    }).reset_index()\n    datos_temporales_agrupados['fecha'] = datos_temporales_agrupados['fecha'].dt.to_timestamp()\n    datos_temporales_agrupados.columns = ['Fecha', 'Ingresos', 'Pedidos', 'Beneficio']\n    \n    # Crear figura con eje secundario\n    fig_evolucion = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    # Agregar líneas de ingresos y beneficio en eje principal\n    fig_evolucion.add_trace(\n        go.Scatter(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Ingresos'],\n            name='Ingresos',\n            line=dict(color='#667eea', width=3),\n            mode='lines'\n        ),\n        secondary_y=False\n    )\n    \n    fig_evolucion.add_trace(\n        go.Scatter(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Beneficio'],\n            name='Beneficio',\n            line=dict(color='#10B981', width=2),\n            mode='lines'\n        ),\n        secondary_y=False\n    )\n    \n    # Agregar barras de pedidos en eje secundario\n    fig_evolucion.add_trace(\n        go.Bar(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Pedidos'],\n            name='Pedidos',\n            marker_color='rgba(245, 158, 11, 0.3)',\n            marker_line_color='#F59E0B',\n            marker_line_width=1\n        ),\n        secondary_y=True\n    )\n    \n    # Configurar ejes\n    fig_evolucion.update_yaxes(title_text=\"Ingresos / Beneficio ($)\", secondary_y=False)\n    fig_evolucion.update_yaxes(title_text=\"Pedidos\", secondary_y=True)\n    fig_evolucion.update_xaxes(title_text=\"Fecha\")\n    \n    fig_evolucion.update_layout(\n        title='Evolución Mensual de Ingresos, Beneficio y Pedidos',\n        height=500,\n        showlegend=True,\n        hovermode='x unified',\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font=dict(family='Inter', size=12),\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=1.02,\n            xanchor=\"right\",\n            x=1\n        )\n    )\n    \n    fig_evolucion.update_xaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    fig_evolucion.update_yaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    \n    st.plotly_chart(fig_evolucion, use_container_width=True)\n    \n    crear_seccion_titulo(\"Distribuciones Clave\")\n    \n    col_dist1, col_dist2 = st.columns(2)\n    \n    with col_dist1:\n        top_paises = datos_filtrados.groupby('country')['total_amount_usd'].sum().nlargest(10).reset_index()\n        fig_paises = px.bar(\n            top_paises,\n            x='total_amount_usd',\n            y='country',\n            orientation='h',\n            title='Top 10 Países por Ingresos',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_paises.update_layout(\n            showlegend=False,\n            height=400,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)'\n        )\n        fig_paises.update_traces(hovertemplate='<b>%{y}</b><br>Ingresos: $%{x:,.0f}<extra></extra>')\n        st.plotly_chart(fig_paises, use_container_width=True)\n    \n    with col_dist2:\n        por_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().reset_index()\n        fig_categorias = px.pie(\n            por_categoria,\n            values='total_amount_usd',\n            names='category',\n            title='Distribución de Ingresos por Categoría',\n            color_discrete_sequence=px.colors.qualitative.Set3,\n            hole=0.4\n        )\n        fig_categorias.update_layout(\n            height=400,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)'\n        )\n        fig_categorias.update_traces(\n            textposition='inside', \n            textinfo='percent+label',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<br>Porcentaje: %{percent}<extra></extra>'\n        )\n        st.plotly_chart(fig_categorias, use_container_width=True)\n\nwith tab_geografia:\n    crear_descripcion_seccion(\n        \"Análisis de Distribución Geográfica\",\n        \"Visualiza cómo se distribuyen tus ventas alrededor del mundo. Identifica los mercados más rentables, \"\n        \"países con mayor potencial de crecimiento y oportunidades de expansión internacional. El mapa de calor \"\n        \"muestra la intensidad de ventas por país.\"\n    )\n    \n    crear_seccion_titulo(\"Análisis Geográfico Global\")\n    \n    col1, col2 = st.columns([7, 3])\n    \n    with col1:\n        st.subheader(\"Mapa Mundial de Ventas\")\n        \n        # Mapeo de nombres de países (en español) a códigos ISO 3\n        country_iso_map = {\n            'Reino Unido': 'GBR', 'Estados Unidos': 'USA', 'Alemania': 'DEU', \n            'Francia': 'FRA', 'China': 'CHN', 'Canadá': 'CAN', 'Japón': 'JPN',\n            'Australia': 'AUS', 'España': 'ESP', 'Italia': 'ITA', 'Países Bajos': 'NLD',\n            'Bélgica': 'BEL', 'Suiza': 'CHE', 'Suecia': 'SWE', 'Austria': 'AUT',\n            'Noruega': 'NOR', 'Dinamarca': 'DNK', 'Finlandia': 'FIN', 'Polonia': 'POL',\n            'Portugal': 'PRT', 'Grecia': 'GRC', 'República Checa': 'CZE',\n            'Irlanda': 'IRL', 'Singapur': 'SGP', 'Corea del Sur': 'KOR',\n            'India': 'IND', 'Brasil': 'BRA', 'México': 'MEX', 'Israel': 'ISR',\n            'Arabia Saudita': 'SAU', 'Emiratos Árabes Unidos': 'ARE', 'Sudáfrica': 'ZAF',\n            'Chipre': 'CYP', 'Malta': 'MLT', 'Islandia': 'ISL', 'Lituania': 'LTU',\n            'Baréin': 'BHR', 'Líbano': 'LBN', 'Comunidad Europea': None\n        }\n        \n        datos_pais = datos_filtrados.groupby('country').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count',\n            'customer_id': 'nunique'\n        }).reset_index()\n        datos_pais.columns = ['country', 'ingresos', 'pedidos', 'clientes']\n        datos_pais['aov'] = datos_pais['ingresos'] / datos_pais['pedidos']\n        \n        # Agregar códigos ISO\n        datos_pais['iso_code'] = datos_pais['country'].map(country_iso_map)\n        # Filtrar países sin código ISO válido\n        datos_pais_validos = datos_pais[datos_pais['iso_code'].notna()].copy()\n        \n        fig_mapa = px.choropleth(\n            datos_pais_validos,\n            locations='iso_code',\n            locationmode='ISO-3',\n            color='ingresos',\n            hover_name='country',\n            hover_data={\n                'iso_code': False,\n                'ingresos': ':$,.0f',\n                'pedidos': ':,',\n                'clientes': ':,',\n                'aov': ':$,.2f'\n            },\n            color_continuous_scale='Viridis',\n            title='Ingresos por País',\n            labels={'ingresos': 'Ingresos', 'pedidos': 'Pedidos', 'clientes': 'Clientes', 'aov': 'Ticket Promedio'}\n        )\n        fig_mapa.update_layout(\n            height=500, \n            margin=dict(l=0, r=0, t=30, b=0),\n            geo=dict(showframe=False, showcoastlines=True, projection_type='natural earth')\n        )\n        st.plotly_chart(fig_mapa, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Top 15 Países\")\n        top_paises = datos_pais.nlargest(15, 'ingresos')\n        \n        fig_top = px.bar(\n            top_paises,\n            y='country',\n            x='ingresos',\n            orientation='h',\n            color='ingresos',\n            color_continuous_scale='Blues',\n            title='Ingresos por País (Top 15)',\n            labels=LABELS\n        )\n        fig_top.update_traces(hovertemplate='<b>%{y}</b><br>Ingresos: $%{x:,.0f}<extra></extra>')\n        fig_top.update_layout(\n            height=500,\n            showlegend=False,\n            yaxis={'categoryorder': 'total ascending'}\n        )\n        st.plotly_chart(fig_top, use_container_width=True)\n    \n    col3, col4 = st.columns(2)\n    \n    with col3:\n        st.subheader(\"Jerarquía Geográfica (Treemap)\")\n        \n        datos_tree_geo = datos_filtrados.groupby(['country', 'category']).agg({\n            'total_amount_usd': 'sum'\n        }).reset_index()\n        datos_tree_geo.rename(columns={'total_amount_usd': 'ingresos'}, inplace=True)\n        \n        fig_tree = px.treemap(\n            datos_tree_geo,\n            path=['country', 'category'],\n            values='ingresos',\n            color='ingresos',\n            color_continuous_scale='RdYlGn',\n            title='Jerarquía: País → Categoría'\n        )\n        \n        fig_tree.update_traces(\n            textinfo='label+value',\n            texttemplate='<b>%{label}</b><br>$%{value:,.0f}',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<extra></extra>'\n        )\n        \n        fig_tree.update_layout(height=400)\n        st.plotly_chart(fig_tree, use_container_width=True)\n    \n    with col4:\n        st.subheader(\"Concentración de Ventas\")\n        top10_paises = datos_pais.nlargest(10, 'ingresos')\n        otros_ingresos = datos_pais[~datos_pais['country'].isin(top10_paises['country'])]['ingresos'].sum()\n        \n        if otros_ingresos > 0:\n            otros_df = pd.DataFrame({'country': ['Otros'], 'ingresos': [otros_ingresos]})\n            datos_pie = pd.concat([top10_paises[['country', 'ingresos']], otros_df])\n        else:\n            datos_pie = top10_paises[['country', 'ingresos']]\n        \n        fig_pie = px.pie(\n            datos_pie,\n            values='ingresos',\n            names='country',\n            title='Distribución de Ingresos (Top 10 + Otros)',\n            hole=0.4\n        )\n        fig_pie.update_traces(hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<br>Porcentaje: %{percent}<extra></extra>')\n        fig_pie.update_layout(height=400)\n        st.plotly_chart(fig_pie, use_container_width=True)\n\nwith tab_rendimiento:\n    crear_descripcion_seccion(\n        \"Análisis de Rendimiento y Tendencias Temporales\",\n        \"Analiza la evolución de tus ventas a lo largo del tiempo, identifica patrones de crecimiento y estacionalidad. \"\n        \"Compara períodos, detecta tendencias y toma decisiones basadas en el comportamiento histórico de tu negocio. \"\n        \"Los indicadores de crecimiento te ayudan a planificar estrategias, ajustar inventario y optimizar recursos.\"\n    )\n    \n    crear_seccion_titulo(\"Análisis Temporal de Rendimiento\")\n    \n    st.subheader(\"Ingresos y Pedidos a lo Largo del Tiempo\")\n    \n    granularidad = st.selectbox(\n        \"Granularidad Temporal\",\n        ['Día', 'Semana', 'Mes'],\n        index=1,\n        help=\"Selecciona el nivel de agregación temporal para el análisis\"\n    )\n    \n    temp_df = datos_filtrados.copy()\n    if granularidad == 'Día':\n        temp_df['periodo'] = temp_df['date'].dt.date\n    elif granularidad == 'Semana':\n        temp_df['periodo'] = temp_df['date'].dt.to_period('W').dt.start_time\n    else:\n        temp_df['periodo'] = temp_df['date'].dt.to_period('M').dt.start_time\n    \n    serie_temporal = temp_df.groupby('periodo').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    serie_temporal.columns = ['periodo', 'ingresos', 'pedidos']\n    \n    fig_tiempo = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    fig_tiempo.add_trace(\n        go.Bar(x=serie_temporal['periodo'], y=serie_temporal['ingresos'], name='Ingresos', marker_color='#667eea'),\n        secondary_y=False\n    )\n    \n    fig_tiempo.add_trace(\n        go.Scatter(x=serie_temporal['periodo'], y=serie_temporal['pedidos'], name='Pedidos', \n                   line=dict(color='#f093fb', width=3), mode='lines+markers'),\n        secondary_y=True\n    )\n    \n    fig_tiempo.update_xaxes(title_text=\"Fecha\")\n    fig_tiempo.update_yaxes(title_text=\"Ingresos ($)\", secondary_y=False)\n    fig_tiempo.update_yaxes(title_text=\"Pedidos\", secondary_y=True)\n    fig_tiempo.update_layout(height=400, title='Evolución de Ingresos y Pedidos')\n    \n    st.plotly_chart(fig_tiempo, use_container_width=True)\n    \n    #Análisis de Crecimiento y Momentum\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    crear_seccion_titulo(\"Indicadores de Crecimiento\")\n    \n    # Calcular períodos para comparación\n    datos_actuales = datos_filtrados.copy()\n    fecha_fin_actual = datos_actuales['date'].max()\n    fecha_inicio_actual = datos_actuales['date'].min()\n    duracion_dias = (fecha_fin_actual - fecha_inicio_actual).days\n    \n    # Período anterior (mismo número de días hacia atrás)\n    fecha_fin_anterior = fecha_inicio_actual - pd.Timedelta(days=1)\n    fecha_inicio_anterior = fecha_fin_anterior - pd.Timedelta(days=duracion_dias)\n    \n    # Aplicar LOS MISMOS filtros al período anterior (excepto fechas)\n    filtros_periodo_anterior = filtros.copy()\n    filtros_periodo_anterior['fecha_inicio'] = fecha_inicio_anterior\n    filtros_periodo_anterior['fecha_fin'] = fecha_fin_anterior\n    \n    datos_periodo_anterior = aplicar_filtros(transacciones_df, filtros_periodo_anterior)\n    \n    # Métricas de comparación\n    ingresos_actual = datos_actuales['total_amount_usd'].sum()\n    ingresos_anterior = datos_periodo_anterior['total_amount_usd'].sum()\n    \n    pedidos_actual = len(datos_actuales)\n    pedidos_anterior = len(datos_periodo_anterior)\n    \n    # Calcular variaciones\n    var_ingresos = ((ingresos_actual - ingresos_anterior) / ingresos_anterior * 100) if ingresos_anterior > 0 else 0\n    var_pedidos = ((pedidos_actual - pedidos_anterior) / pedidos_anterior * 100) if pedidos_anterior > 0 else 0\n    \n    # KPIs de crecimiento\n    col_crec1, col_crec2, col_crec3, col_crec4 = st.columns(4)\n    \n    with col_crec1:\n        st.metric(\n            \"Variación vs Período Anterior\",\n            f\"{var_ingresos:+.1f}%\",\n            delta=f\"${ingresos_actual - ingresos_anterior:,.0f}\"\n        )\n    \n    with col_crec2:\n        st.metric(\n            \"Crecimiento en Pedidos\",\n            f\"{var_pedidos:+.1f}%\",\n            delta=f\"{pedidos_actual - pedidos_anterior:,} pedidos\"\n        )\n    \n    with col_crec3:\n        # Tasa de crecimiento promedio diaria\n        if duracion_dias > 0:\n            crecimiento_diario = var_ingresos / duracion_dias\n            st.metric(\n                \"Tasa Diaria Promedio\",\n                f\"{crecimiento_diario:+.2f}%/día\"\n            )\n        else:\n            st.metric(\"Tasa Diaria Promedio\", \"N/A\")\n    \n    with col_crec4:\n        # Momentum (aceleración)\n        if var_ingresos > 10:\n            momentum = \"Acelerado ⬆️\"\n            momentum_color = \"green\"\n        elif var_ingresos < -10:\n            momentum = \"Desacelerado ⬇️\"\n            momentum_color = \"red\"\n        else:\n            momentum = \"Estable ➡️\"\n            momentum_color = \"gray\"\n        \n        st.metric(\"Momentum\", momentum)\n    \n    # Análisis de Tendencias con Promedio Móvil\n    if len(serie_temporal) > 7:\n        st.markdown(\"<br>\", unsafe_allow_html=True)\n        st.subheader(\"📊 Análisis de Tendencias (Promedio Móvil)\")\n        \n        # Calcular promedio móvil según granularidad\n        if granularidad == 'Día':\n            ventana_corta = 7\n            ventana_larga = 30\n            label_corta = \"7 días\"\n            label_larga = \"30 días\"\n        elif granularidad == 'Semana':\n            ventana_corta = 4\n            ventana_larga = 12\n            label_corta = \"4 semanas\"\n            label_larga = \"12 semanas\"\n        else:  # Mes\n            ventana_corta = 3\n            ventana_larga = 6\n            label_corta = \"3 meses\"\n            label_larga = \"6 meses\"\n        \n        serie_temporal_sorted = serie_temporal.sort_values('periodo').copy()\n        \n        if len(serie_temporal_sorted) >= ventana_corta:\n            serie_temporal_sorted[f'ma_{ventana_corta}'] = serie_temporal_sorted['ingresos'].rolling(window=ventana_corta, min_periods=1).mean()\n        \n        if len(serie_temporal_sorted) >= ventana_larga:\n            serie_temporal_sorted[f'ma_{ventana_larga}'] = serie_temporal_sorted['ingresos'].rolling(window=ventana_larga, min_periods=1).mean()\n        \n        fig_tendencias = go.Figure()\n        \n        # Datos reales\n        fig_tendencias.add_trace(go.Scatter(\n            x=serie_temporal_sorted['periodo'],\n            y=serie_temporal_sorted['ingresos'],\n            mode='lines+markers',\n            name='Ingresos Reales',\n            line=dict(color='rgba(102, 126, 234, 0.4)', width=1),\n            marker=dict(size=4, color='#667eea')\n        ))\n        \n        # Promedio móvil corto\n        if f'ma_{ventana_corta}' in serie_temporal_sorted.columns:\n            fig_tendencias.add_trace(go.Scatter(\n                x=serie_temporal_sorted['periodo'],\n                y=serie_temporal_sorted[f'ma_{ventana_corta}'],\n                mode='lines',\n                name=f'Tendencia {label_corta}',\n                line=dict(color='#10B981', width=3)\n            ))\n        \n        # Promedio móvil largo\n        if f'ma_{ventana_larga}' in serie_temporal_sorted.columns:\n            fig_tendencias.add_trace(go.Scatter(\n                x=serie_temporal_sorted['periodo'],\n                y=serie_temporal_sorted[f'ma_{ventana_larga}'],\n                mode='lines',\n                name=f'Tendencia {label_larga}',\n                line=dict(color='#F59E0B', width=2, dash='dash')\n            ))\n        \n        fig_tendencias.update_layout(\n            title=f'Tendencias de Ingresos con Promedio Móvil ({granularidad})',\n            xaxis_title='Fecha',\n            yaxis_title='Ingresos (USD)',\n            height=450,\n            hovermode='x unified',\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            )\n        )\n        \n        st.plotly_chart(fig_tendencias, use_container_width=True)\n        \n        # Insights automáticos de tendencias\n        if f'ma_{ventana_corta}' in serie_temporal_sorted.columns and f'ma_{ventana_larga}' in serie_temporal_sorted.columns:\n            ultima_corta = serie_temporal_sorted[f'ma_{ventana_corta}'].iloc[-1]\n            ultima_larga = serie_temporal_sorted[f'ma_{ventana_larga}'].iloc[-1]\n            \n            if ultima_corta > ultima_larga * 1.05:\n                st.success(f\"✅ **Tendencia Positiva:** La tendencia de {label_corta} está {((ultima_corta/ultima_larga - 1) * 100):.1f}% por encima de la tendencia de {label_larga}, indicando aceleración en el crecimiento.\")\n            elif ultima_corta < ultima_larga * 0.95:\n                st.warning(f\"⚠️ **Alerta de Desaceleración:** La tendencia de {label_corta} está {((1 - ultima_corta/ultima_larga) * 100):.1f}% por debajo de la tendencia de {label_larga}, sugiriendo una desaceleración reciente.\")\n            else:\n                st.info(f\"ℹ️ **Tendencia Estable:** Las tendencias de {label_corta} y {label_larga} están alineadas, indicando un crecimiento constante y predecible.\")\n    \n    col_dist1, col_dist2 = st.columns(2)\n    \n    with col_dist1:\n        st.subheader(\"Distribución de Ingresos por Día de Semana\")\n        from utils.traducciones import traducir_dia_semana\n        temp_df['dia_semana'] = pd.to_datetime(temp_df['date']).dt.day_name()\n        ingresos_dia = temp_df.groupby('dia_semana')['total_amount_usd'].sum().reset_index()\n        dias_orden = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        ingresos_dia['dia_semana'] = pd.Categorical(ingresos_dia['dia_semana'], categories=dias_orden, ordered=True)\n        ingresos_dia = ingresos_dia.sort_values('dia_semana')\n        # Traducir días al español\n        ingresos_dia['dia_semana_es'] = ingresos_dia['dia_semana'].apply(traducir_dia_semana)\n        \n        fig_dias = px.bar(\n            ingresos_dia,\n            x='dia_semana_es',\n            y='total_amount_usd',\n            title='Ingresos por Día de la Semana',\n            labels={'dia_semana_es': '', 'total_amount_usd': 'Ingresos (USD)'},\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_dias.update_layout(height=400, showlegend=False)\n        fig_dias.update_traces(hovertemplate='<b>%{x}</b><br>Ingresos: $%{y:,.0f}<extra></extra>')\n        st.plotly_chart(fig_dias, use_container_width=True)\n    \n    with col_dist2:\n        st.subheader(\"Distribución de Ingresos por Hora\")\n        temp_df['hora'] = pd.to_datetime(temp_df['date']).dt.hour\n        ingresos_hora = temp_df.groupby('hora')['total_amount_usd'].sum().reset_index()\n        \n        fig_horas = px.line(\n            ingresos_hora,\n            x='hora',\n            y='total_amount_usd',\n            title='Ingresos por Hora del Día',\n            labels=LABELS,\n            markers=True\n        )\n        fig_horas.update_traces(\n            line_color='#F59E0B', \n            line_width=3,\n            hovertemplate='<b>Hora %{x}:00</b><br>Ingresos: $%{y:,.0f}<extra></extra>'\n        )\n        fig_horas.update_layout(height=400)\n        st.plotly_chart(fig_horas, use_container_width=True)\n\nwith tab_productos:\n    crear_descripcion_seccion(\n        \"Rendimiento y Estrategia de Productos\",\n        \"Analiza qué productos generan más ingresos, cuáles tienen mejor margen y cómo se distribuyen por categorías. \"\n        \"La Matriz BCG clasifica tus productos en: **Alto Rendimiento** (altos ingresos, alta frecuencia), **Consolidados** (altos ingresos, frecuencia media), \"\n        \"**Alto Potencial** (potencial de crecimiento) y **En Evaluación** (requieren optimización o descontinuación).\"\n    )\n    \n    crear_seccion_titulo(\"Análisis de Productos\")\n    \n    st.subheader(\"Top 20 Productos por Ingresos\")\n    \n    # Filtrar productos no significativos (costos de envío, productos genéricos)\n    productos_excluir = ['Manual', 'POSTAGE', 'DOTCOM POSTAGE', 'Adjust bad debt', 'BANK CHARGES']\n    datos_productos_reales = datos_filtrados[~datos_filtrados['product_name'].isin(productos_excluir)]\n    \n    top_productos = datos_productos_reales.groupby(['product_id', 'product_name', 'category']).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count',\n        'quantity': 'sum',\n        'profit': 'sum'\n    }).reset_index().nlargest(20, 'total_amount_usd')\n    \n    fig_productos = px.bar(\n        top_productos,\n        x='total_amount_usd',\n        y='product_name',\n        orientation='h',\n        title='Top 20 Productos por Ingresos (excl. envíos)',\n        labels=LABELS,\n        color='category',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['category', 'profit']\n    )\n    fig_productos.update_traces(hovertemplate='<b>%{y}</b><br>Categoría: %{customdata[0]}<br>Ingresos: $%{x:,.0f}<br>Beneficio: $%{customdata[1]:,.0f}<extra></extra>')\n    fig_productos.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_productos, use_container_width=True)\n    \n    st.subheader(\"Top 15 Productos Más Comprados\")\n    \n    top_comprados = datos_productos_reales.groupby(['product_id', 'product_name', 'category']).agg({\n        'quantity': 'sum',\n        'transaction_id': 'count',\n        'total_amount_usd': 'sum'\n    }).reset_index().nlargest(15, 'quantity')\n    \n    fig_comprados = px.bar(\n        top_comprados,\n        x='quantity',\n        y='product_name',\n        orientation='h',\n        title='Top 15 Productos por Unidades Vendidas (excl. envíos)',\n        labels=LABELS,\n        color='category',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['category', 'transaction_id']\n    )\n    fig_comprados.update_traces(hovertemplate='<b>%{y}</b><br>Categoría: %{customdata[0]}<br>Unidades: %{x:,.0f}<br>Transacciones: %{customdata[1]:,.0f}<extra></extra>')\n    fig_comprados.update_layout(height=450, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_comprados, use_container_width=True)\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Ingresos por Categoría (Treemap)\")\n        datos_categoria = datos_filtrados.groupby(['category', 'subcategory']).agg({\n            'total_amount_usd': 'sum'\n        }).reset_index()\n        \n        fig_tree_cat = px.treemap(\n            datos_categoria,\n            path=['category', 'subcategory'],\n            values='total_amount_usd',\n            title='Jerarquía de Categorías',\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        \n        fig_tree_cat.update_traces(\n            textinfo='label+value',\n            texttemplate='<b>%{label}</b><br>$%{value:,.0f}',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<extra></extra>'\n        )\n        \n        fig_tree_cat.update_layout(height=400)\n        st.plotly_chart(fig_tree_cat, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Margen por Categoría\")\n        margen_cat = datos_filtrados.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        margen_cat['margen_%'] = (margen_cat['profit'] / margen_cat['total_amount_usd'] * 100)\n        \n        fig_margen = px.bar(\n            margen_cat.sort_values('margen_%', ascending=False),\n            x='category',\n            y='margen_%',\n            title='Margen de Beneficio por Categoría (%)',\n            labels=LABELS,\n            color='margen_%',\n            color_continuous_scale='RdYlGn'\n        )\n        fig_margen.update_traces(hovertemplate='<b>%{x}</b><br>Margen: %{y:.1f}%<extra></extra>')\n        fig_margen.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_margen, use_container_width=True)\n    \n    st.subheader(\"Análisis de Performance de Productos (Matriz BCG)\")\n    \n    # Usar los mismos datos filtrados (productos reales, sin envíos)\n    productos_bcg = datos_productos_reales.groupby(['product_id', 'product_name']).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    productos_bcg.columns = ['product_id', 'producto', 'ingresos', 'frecuencia']\n    productos_bcg['ingresos_formato'] = productos_bcg['ingresos'].apply(lambda x: f\"${x:,.0f}\")\n    \n    mediana_ingresos = productos_bcg['ingresos'].median()\n    mediana_frecuencia = productos_bcg['frecuencia'].median()\n    \n    def clasificar_bcg(row):\n        if row['ingresos'] >= mediana_ingresos and row['frecuencia'] >= mediana_frecuencia:\n            return 'Alto Rendimiento'\n        elif row['ingresos'] >= mediana_ingresos and row['frecuencia'] < mediana_frecuencia:\n            return 'Alto Potencial'\n        elif row['ingresos'] < mediana_ingresos and row['frecuencia'] >= mediana_frecuencia:\n            return 'Consolidados'\n        else:\n            return 'En Evaluación'\n    \n    productos_bcg['cuadrante'] = productos_bcg.apply(clasificar_bcg, axis=1)\n    \n    # Mejorar visualización: usar escala logarítmica y tamaños más uniformes\n    productos_bcg_muestra = productos_bcg.sample(min(500, len(productos_bcg)))\n    \n    # Añadir tamaño normalizado para mejor visualización\n    productos_bcg_muestra['size_viz'] = np.log1p(productos_bcg_muestra['ingresos']) * 10\n    \n    fig_bcg = px.scatter(\n        productos_bcg_muestra,\n        x='frecuencia',\n        y='ingresos',\n        color='cuadrante',\n        size='size_viz',\n        hover_data={'producto': True, 'ingresos_formato': True, 'frecuencia': True, 'ingresos': False, 'cuadrante': False, 'size_viz': False},\n        title='Matriz BCG de Productos',\n        labels=LABELS,\n        color_discrete_map={\n            'Alto Rendimiento': '#10B981',\n            'Consolidados': '#3B82F6',\n            'Alto Potencial': '#F59E0B',\n            'En Evaluación': '#EF4444'\n        },\n        log_y=True\n    )\n    \n    fig_bcg.update_traces(\n        hovertemplate='<b>%{customdata[0]}</b><br>Ingresos: %{customdata[1]}<br>Frecuencia: %{customdata[2]} pedidos<extra></extra>',\n        marker=dict(\n            line=dict(width=1, color='white'),\n            opacity=0.7\n        )\n    )\n    \n    fig_bcg.add_hline(y=mediana_ingresos, line_dash=\"dash\", line_color=\"white\", line_width=2, annotation_text=\"Mediana Ingresos\", annotation_position=\"right\")\n    fig_bcg.add_vline(x=mediana_frecuencia, line_dash=\"dash\", line_color=\"white\", line_width=2, annotation_text=\"Mediana Frecuencia\", annotation_position=\"top\")\n    fig_bcg.update_layout(\n        height=550,\n        yaxis_title=\"Ingresos (USD) - Escala Logarítmica\",\n        xaxis_title=\"Frecuencia de Compra (pedidos)\",\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"right\",\n            x=0.99\n        )\n    )\n    st.plotly_chart(fig_bcg, use_container_width=True)\n    \n    col_resumen = st.columns(4)\n    for idx, cuadrante in enumerate(['Alto Rendimiento', 'Consolidados', 'Alto Potencial', 'En Evaluación']):\n        with col_resumen[idx]:\n            count = len(productos_bcg[productos_bcg['cuadrante'] == cuadrante])\n            st.metric(cuadrante, f\"{count} productos\")\n\nwith tab_clientes:\n    crear_descripcion_seccion(\n        \"Conoce a Tus Clientes en Profundidad\",\n        \"Esta sección te permite entender quiénes son tus mejores clientes, cuáles están en riesgo de abandonar y cómo puedes \"\n        \"personalizar tu estrategia para cada segmento. El análisis RFM evalúa cuán recientemente compraron, con qué frecuencia \"\n        \"y cuánto gastan, clasificándolos en 11 segmentos desde Campeones hasta Perdidos.\"\n    )\n    \n    crear_seccion_titulo(\"Segmentación de Clientes\")\n    \n    st.subheader(\"Análisis RFM (Recencia, Frecuencia, Monetario)\")\n    \n    clientes_filt = clientes_df[clientes_df['customer_id'].isin(datos_filtrados['customer_id'].unique())]\n    \n    rfm_segments = clientes_filt['rfm_segment'].value_counts().reset_index()\n    rfm_segments.columns = ['segmento', 'cantidad']\n    \n    col1, col2 = st.columns([6, 4])\n    \n    with col1:\n        fig_rfm = px.bar(\n            rfm_segments.sort_values('cantidad', ascending=False),\n            x='segmento',\n            y='cantidad',\n            title='Distribución de Clientes por Segmento RFM',\n            labels=LABELS,\n            color='cantidad',\n            color_continuous_scale='Viridis'\n        )\n        fig_rfm.update_traces(hovertemplate='<b>%{x}</b><br>Clientes: %{y:,}<extra></extra>')\n        fig_rfm.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_rfm, use_container_width=True)\n    \n    with col2:\n        fig_rfm_pie = px.pie(\n            rfm_segments,\n            values='cantidad',\n            names='segmento',\n            title='Proporción de Segmentos',\n            hole=0.4\n        )\n        fig_rfm_pie.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_rfm_pie.update_layout(height=400)\n        st.plotly_chart(fig_rfm_pie, use_container_width=True)\n    \n    st.subheader(\"Valor de Vida del Cliente (LTV)\")\n    \n    col_ltv1, col_ltv2, col_ltv3 = st.columns(3)\n    \n    with col_ltv1:\n        st.metric(\"LTV Promedio\", f\"${clientes_filt['lifetime_value'].mean():,.0f}\")\n    with col_ltv2:\n        st.metric(\"LTV Mediana\", f\"${clientes_filt['lifetime_value'].median():,.0f}\")\n    with col_ltv3:\n        st.metric(\"LTV Máximo\", f\"${clientes_filt['lifetime_value'].max():,.0f}\")\n    \n    fig_ltv_dist = px.histogram(\n        clientes_filt,\n        x='lifetime_value',\n        nbins=50,\n        title='Distribución del Valor de Vida del Cliente',\n        labels=LABELS,\n        color_discrete_sequence=['#667eea']\n    )\n    fig_ltv_dist.update_traces(hovertemplate='LTV: $%{x:,.0f}<br>Clientes: %{y:,}<extra></extra>')\n    fig_ltv_dist.update_layout(height=400, showlegend=False)\n    st.plotly_chart(fig_ltv_dist, use_container_width=True)\n    \n    if filtros.get('mostrar_ml') and len(datos_filtrados) > 100:\n        crear_seccion_titulo(\"Segmentación Inteligente de Clientes (K-Means)\")\n        \n        crear_descripcion_seccion(\n            \"¿Qué es el Clustering K-Means?\",\n            \"El clustering K-Means es una técnica de machine learning que agrupa automáticamente a tus clientes en segmentos \"\n            \"con comportamientos similares. Analiza la Recencia (cuándo compraron por última vez), Frecuencia (cuántas veces compran) \"\n            \"y Valor Monetario (cuánto gastan). Esta segmentación permite personalizar estrategias de marketing y ventas para cada grupo.\"\n        )\n        \n        try:\n            from sklearn.cluster import KMeans\n            from sklearn.preprocessing import StandardScaler\n            \n            fecha_analisis = datos_filtrados['date'].max()\n            \n            rfm_data = datos_filtrados.groupby('customer_id').agg({\n                'date': lambda x: (fecha_analisis - x.max()).days,\n                'transaction_id': 'count',\n                'total_amount_usd': 'sum'\n            }).reset_index()\n            rfm_data.columns = ['customer_id', 'recency', 'frequency', 'monetary']\n            \n            rfm_data = rfm_data.merge(\n                clientes_df[['customer_id', 'lifetime_value']], \n                on='customer_id', \n                how='left'\n            )\n            \n            features_clustering = rfm_data[['recency', 'frequency', 'monetary', 'lifetime_value']].fillna(0)\n            \n            if len(features_clustering) > 10:\n                scaler = StandardScaler()\n                features_scaled = scaler.fit_transform(features_clustering)\n                \n                kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)\n                clusters = kmeans.fit_predict(features_scaled)\n                \n                rfm_data['cluster'] = clusters\n                rfm_data['cluster_nombre'] = rfm_data['cluster'].map({\n                    0: 'Premium',\n                    1: 'Activo',\n                    2: 'En Riesgo',\n                    3: 'Inactivo'\n                })\n                \n                muestra_viz = rfm_data.sample(min(1000, len(rfm_data)))\n                \n                fig_clusters = px.scatter_3d(\n                    muestra_viz,\n                    x='recency',\n                    y='frequency',\n                    z='monetary',\n                    color='cluster_nombre',\n                    title='Visualización 3D de Segmentos de Clientes',\n                    labels={\n                        'recency': 'Días desde Última Compra',\n                        'frequency': 'Número de Compras',\n                        'monetary': 'Gasto Total (USD)',\n                        'cluster_nombre': 'Segmento'\n                    },\n                    color_discrete_map={\n                        'Premium': '#10B981',\n                        'Activo': '#3B82F6',\n                        'En Riesgo': '#F59E0B',\n                        'Inactivo': '#EF4444'\n                    },\n                    height=600\n                )\n                \n                fig_clusters.update_traces(\n                    marker=dict(size=5, opacity=0.7)\n                )\n                \n                st.plotly_chart(fig_clusters, use_container_width=True)\n                \n                col_cluster = st.columns(4)\n                cluster_counts = {}\n                for i, nombre in enumerate(['Premium', 'Activo', 'En Riesgo', 'Inactivo']):\n                    cluster_counts[nombre] = len(rfm_data[rfm_data['cluster'] == i])\n                    with col_cluster[i]:\n                        count_cluster = cluster_counts[nombre]\n                        pct_cluster = (count_cluster / len(rfm_data) * 100)\n                        st.metric(\n                            f\"🎯 {nombre}\",\n                            f\"{count_cluster:,}\",\n                            delta=f\"{pct_cluster:.1f}%\"\n                        )\n                \n                # Calcular promedios por cluster para insights\n                cluster_stats = rfm_data.groupby('cluster_nombre').agg({\n                    'recency': 'mean',\n                    'frequency': 'mean',\n                    'monetary': 'mean'\n                }).round(0)\n                \n                # Insights por segmento\n                st.markdown(\"### 📊 Características de Cada Segmento\")\n                \n                col_desc1, col_desc2 = st.columns(2)\n                \n                with col_desc1:\n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #10B981 0%, #059669 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>💎 Clientes Premium</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Tus mejores clientes. Compran frecuentemente, con alto valor y recientemente activos.<br>\n                            <strong>Características:</strong> Baja recencia, alta frecuencia, alto gasto.<br>\n                            <strong>Prioridad:</strong> MUY ALTA - Son el motor del negocio.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                    \n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>⚠️ Clientes En Riesgo</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Clientes valiosos que están perdiendo actividad. Pueden abandonar pronto.<br>\n                            <strong>Características:</strong> Recencia media-alta, frecuencia decreciente.<br>\n                            <strong>Prioridad:</strong> ALTA - Requieren reactivación urgente.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col_desc2:\n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>✅ Clientes Activos</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Clientes regulares y consistentes, aunque no son los de mayor gasto.<br>\n                            <strong>Características:</strong> Baja-media recencia, frecuencia media, gasto moderado.<br>\n                            <strong>Prioridad:</strong> MEDIA - Potencial para convertirse en Premium.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                    \n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>😴 Clientes Inactivos</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> No han comprado recientemente. Pueden estar perdidos.<br>\n                            <strong>Características:</strong> Alta recencia, baja frecuencia, bajo gasto.<br>\n                            <strong>Prioridad:</strong> BAJA - Evaluar costo de reactivación.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                # Recomendaciones específicas por cluster\n                recomendaciones_clustering = [\n                    f\"<strong>Premium ({cluster_counts['Premium']:,} clientes):</strong> Programa VIP exclusivo, acceso anticipado a nuevos productos, atención personalizada\",\n                    f\"<strong>Activos ({cluster_counts['Activo']:,} clientes):</strong> Ofertas de up-selling/cross-selling, programa de referidos, incentivos por mayor gasto\",\n                    f\"<strong>En Riesgo ({cluster_counts['En Riesgo']:,} clientes):</strong> Campañas de win-back con descuentos especiales, encuestas de satisfacción, emails personalizados\",\n                    f\"<strong>Inactivos ({cluster_counts['Inactivo']:,} clientes):</strong> Campañas de reactivación masiva, ofertas agresivas de reenganche, limpiar base de datos si el costo es muy alto\"\n                ]\n                \n                crear_recomendaciones(\"Estrategias por Segmento de Clientes\", recomendaciones_clustering)\n                \n            else:\n                st.info(\"Se requieren al menos 10 clientes para generar el clustering. Ajusta los filtros para incluir más datos.\")\n                \n        except Exception as e:\n            st.error(f\"❌ Error al generar la segmentación: {str(e)}\")\n            st.info(\"💡 Consejo: Intenta ajustar los filtros del sidebar para incluir más clientes o un período de tiempo más amplio.\")\n    \n    crear_seccion_titulo(\"Análisis de Riesgo de Abandono (Churn)\")\n    \n    crear_descripcion_seccion(\n        \"¿Qué es el Riesgo de Churn?\",\n        \"El riesgo de churn (abandono) mide la probabilidad de que un cliente deje de comprar en tu negocio. \"\n        \"Este análisis identifica clientes en riesgo para permitir acciones preventivas. Un churn alto (>70%) indica \"\n        \"clientes que probablemente no volverán, medio (40-70%) requiere atención, y bajo (<40%) son clientes estables.\"\n    )\n    \n    col_churn1, col_churn2 = st.columns([6, 4])\n    \n    with col_churn1:\n        fig_churn = px.histogram(\n            clientes_filt,\n            x='churn_probability',\n            nbins=30,\n            title='Distribución de Probabilidad de Churn',\n            labels=LABELS,\n            color_discrete_sequence=['#EF4444']\n        )\n        fig_churn.update_traces(hovertemplate='<b>Probabilidad de Churn:</b> %{x:.1%}<br><b>Cantidad:</b> %{y:,} clientes<extra></extra>')\n        fig_churn.update_layout(\n            height=400,\n            xaxis_title=\"Probabilidad de Abandono\",\n            yaxis_title=\"Cantidad de Clientes\"\n        )\n        st.plotly_chart(fig_churn, use_container_width=True)\n    \n    with col_churn2:\n        churn_alto = len(clientes_filt[clientes_filt['churn_probability'] > 0.7])\n        churn_medio = len(clientes_filt[(clientes_filt['churn_probability'] > 0.4) & (clientes_filt['churn_probability'] <= 0.7)])\n        churn_bajo = len(clientes_filt[clientes_filt['churn_probability'] <= 0.4])\n        \n        churn_data = pd.DataFrame({\n            'riesgo': ['Alto (>70%)', 'Medio (40-70%)', 'Bajo (<40%)'],\n            'cantidad': [churn_alto, churn_medio, churn_bajo]\n        })\n        \n        fig_churn_pie = px.pie(\n            churn_data,\n            values='cantidad',\n            names='riesgo',\n            title='Clasificación de Riesgo de Churn',\n            color='riesgo',\n            color_discrete_map={'Alto (>70%)': '#EF4444', 'Medio (40-70%)': '#F59E0B', 'Bajo (<40%)': '#10B981'}\n        )\n        fig_churn_pie.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_churn_pie.update_layout(height=400)\n        st.plotly_chart(fig_churn_pie, use_container_width=True)\n    \n    # Insights accionables\n    total_clientes_analisis = len(clientes_filt)\n    porcentaje_alto = (churn_alto / total_clientes_analisis * 100) if total_clientes_analisis > 0 else 0\n    porcentaje_medio = (churn_medio / total_clientes_analisis * 100) if total_clientes_analisis > 0 else 0\n    \n    crear_insight(\n        \"Hallazgo Clave\",\n        f\"De {total_clientes_analisis:,} clientes analizados, {churn_alto:,} ({porcentaje_alto:.1f}%) tienen riesgo ALTO de abandono \"\n        f\"y {churn_medio:,} ({porcentaje_medio:.1f}%) tienen riesgo MEDIO. Estos {churn_alto + churn_medio:,} clientes requieren \"\n        \"atención inmediata para evitar pérdida de ingresos.\"\n    )\n    \n    # Recomendaciones específicas\n    recomendaciones_churn = [\n        f\"<strong>Prioridad Crítica:</strong> Contactar a los {churn_alto:,} clientes de riesgo ALTO con ofertas personalizadas o descuentos exclusivos\",\n        \"<strong>Programas de Fidelización:</strong> Implementar un programa de puntos o beneficios para clientes de riesgo MEDIO\",\n        \"<strong>Email Marketing:</strong> Enviar campañas de reactivación con productos relevantes basados en su historial de compras\",\n        \"<strong>Encuestas de Satisfacción:</strong> Contactar clientes en riesgo para identificar problemas y oportunidades de mejora\",\n        f\"<strong>Análisis de Valor:</strong> Calcular el LTV de los {churn_alto:,} clientes en riesgo para priorizar esfuerzos de retención\"\n    ]\n    \n    crear_recomendaciones(\"Acciones Recomendadas para Reducir Churn\", recomendaciones_churn)\n\nwith tab_canal:\n    crear_descripcion_seccion(\n        \"Optimización de Canales de Venta\",\n        \"Descubre qué dispositivos (móvil, escritorio, tablet) generan más ventas, qué fuentes de tráfico son más rentables \"\n        \"(redes sociales, email, búsqueda orgánica, publicidad) y qué métodos de pago prefieren tus clientes. \"\n        \"Optimiza tu inversión en marketing según estos datos.\"\n    )\n    \n    crear_seccion_titulo(\"Análisis de Canal\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Ingresos por Tipo de Dispositivo\")\n        dispositivos = datos_filtrados.groupby('device_type')['total_amount_usd'].sum().reset_index()\n        \n        fig_dispositivos = px.pie(\n            dispositivos,\n            values='total_amount_usd',\n            names='device_type',\n            title='Distribución de Ingresos por Dispositivo',\n            hole=0.4\n        )\n        fig_dispositivos.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_dispositivos.update_layout(height=400)\n        st.plotly_chart(fig_dispositivos, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Fuentes de Tráfico\")\n        trafico = datos_filtrados.groupby('traffic_source')['total_amount_usd'].sum().reset_index()\n        \n        fig_trafico = px.bar(\n            trafico.sort_values('total_amount_usd', ascending=False),\n            x='traffic_source',\n            y='total_amount_usd',\n            title='Ingresos por Fuente de Tráfico',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_trafico.update_traces(hovertemplate='<b>%{x}</b><br>Ingresos: $%{y:,.0f}<extra></extra>')\n        fig_trafico.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_trafico, use_container_width=True)\n    \n    st.subheader(\"Métodos de Pago\")\n    \n    pagos = datos_filtrados.groupby('payment_method').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    pagos.columns = ['metodo', 'ingresos', 'transacciones']\n    \n    fig_pagos = px.bar(\n        pagos.sort_values('ingresos', ascending=False),\n        x='metodo',\n        y='ingresos',\n        title='Ingresos por Método de Pago',\n        labels=LABELS,\n        color='ingresos',\n        color_continuous_scale='Blues',\n        text='transacciones'\n    )\n    fig_pagos.update_traces(\n        texttemplate='%{text:,}', \n        textposition='outside',\n        hovertemplate='<b>Método:</b> %{x}<br><b>Ingresos:</b> $%{y:,.0f}<br><b>Transacciones:</b> %{text:,}<extra></extra>'\n    )\n    fig_pagos.update_layout(\n        height=450, \n        showlegend=False,\n        yaxis_title=\"Ingresos (USD)\",\n        xaxis_title=\"Método de Pago\"\n    )\n    st.plotly_chart(fig_pagos, use_container_width=True)\n    \n    st.subheader(\"Flujo de Conversión (Diagrama Sankey)\")\n    \n    try:\n        sankey_data = datos_filtrados.groupby(['traffic_source', 'device_type', 'payment_method'])['total_amount_usd'].sum().reset_index()\n        sankey_top = sankey_data.nlargest(30, 'total_amount_usd')\n        \n        labels_list = list(pd.concat([\n            sankey_top['traffic_source'],\n            sankey_top['device_type'],\n            sankey_top['payment_method']\n        ]).unique())\n        \n        source_idx = [labels_list.index(src) for src in sankey_top['traffic_source']]\n        device_idx = [labels_list.index(dev) for dev in sankey_top['device_type']]\n        payment_idx = [labels_list.index(pay) for pay in sankey_top['payment_method']]\n        \n        # Colores para los nodos\n        node_colors = []\n        for label in labels_list:\n            if label in sankey_top['traffic_source'].values:\n                node_colors.append('#667eea')\n            elif label in sankey_top['device_type'].values:\n                node_colors.append('#F59E0B')\n            else:\n                node_colors.append('#10B981')\n        \n        fig_sankey = go.Figure(data=[go.Sankey(\n            node=dict(\n                pad=15,\n                thickness=20,\n                line=dict(color='white', width=1),\n                label=labels_list,\n                color=node_colors\n            ),\n            link=dict(\n                source=source_idx + device_idx,\n                target=device_idx + payment_idx,\n                value=sankey_top['total_amount_usd'].tolist() + sankey_top['total_amount_usd'].tolist(),\n                color='rgba(200,200,200,0.3)'\n            )\n        )])\n        \n        fig_sankey.update_layout(\n            title='Flujo de Conversión: Fuente → Dispositivo → Método de Pago', \n            height=500,\n            font=dict(size=11)\n        )\n        st.plotly_chart(fig_sankey, use_container_width=True)\n    except Exception as e:\n        st.warning(f\"No se pudo generar diagrama Sankey: {str(e)}\")\n\nwith tab_ml:\n    crear_descripcion_seccion(\n        \"Inteligencia Artificial para Decisiones Estratégicas\",\n        \"Esta sección combina múltiples modelos de machine learning para detectar patrones ocultos, anomalías en ventas y \"\n        \"oportunidades de optimización. Los algoritmos analizan millones de datos en segundos para proporcionarte insights \"\n        \"que serían imposibles de detectar manualmente.\"\n    )\n    \n    crear_seccion_titulo(\"ML & IA Insights\")\n    \n    if not filtros.get('mostrar_ml'):\n        st.warning(\"⚠️ Activa 'Mostrar Predicciones ML' en el sidebar para visualizar análisis avanzados de Machine Learning.\")\n    else:\n        st.subheader(\"🔍 Detección de Anomalías (Isolation Forest)\")\n        \n        try:\n            from sklearn.ensemble import IsolationForest\n            \n            features_anomaly = datos_filtrados[['total_amount_usd', 'quantity', 'profit']].dropna()\n            \n            if len(features_anomaly) > 100:\n                iso_forest = IsolationForest(contamination=0.05, random_state=42)\n                anomalias = iso_forest.fit_predict(features_anomaly)\n                \n                datos_anomalias = datos_filtrados.loc[features_anomaly.index].copy()\n                datos_anomalias['es_anomalia'] = anomalias == -1\n                \n                col1, col2 = st.columns([7, 3])\n                \n                with col1:\n                    fig_anomalias = px.scatter(\n                        datos_anomalias.sample(min(2000, len(datos_anomalias))),\n                        x='quantity',\n                        y='total_amount_usd',\n                        color='es_anomalia',\n                        title='Detección de Transacciones Anómalas',\n                        labels=LABELS,\n                        color_discrete_map={True: '#EF4444', False: '#10B981'}\n                    )\n                    fig_anomalias.update_layout(height=500)\n                    st.plotly_chart(fig_anomalias, use_container_width=True)\n                \n                with col2:\n                    num_anomalias = datos_anomalias['es_anomalia'].sum()\n                    st.metric(\"Transacciones Anómalas Detectadas\", f\"{num_anomalias:,}\")\n                    st.metric(\"% del Total\", f\"{(num_anomalias/len(datos_anomalias)*100):.2f}%\")\n                    \n                    if num_anomalias > 0:\n                        st.markdown(\"**Características de Anomalías:**\")\n                        anomalas_df = datos_anomalias[datos_anomalias['es_anomalia']]\n                        st.write(f\"- Monto promedio: ${anomalas_df['total_amount_usd'].mean():,.0f}\")\n                        st.write(f\"- Cantidad promedio: {anomalas_df['quantity'].mean():.0f}\")\n                        st.write(f\"- Beneficio promedio: ${anomalas_df['profit'].mean():,.0f}\")\n        except Exception as e:\n            st.error(f\"Error en detección de anomalías: {str(e)}\")\n        \n        st.subheader(\"📊 Análisis de Correlación de Variables\")\n        \n        st.markdown(\"\"\"\n        <p style='color: #666; font-size: 0.95rem; margin-bottom: 1.5rem;'>\n        La matriz de correlación muestra las relaciones entre variables clave. Valores cercanos a +1 indican correlación positiva fuerte \n        (cuando una sube, la otra también), valores cercanos a -1 indican correlación negativa (cuando una sube, la otra baja), \n        y valores cercanos a 0 indican poca o ninguna relación.\n        </p>\n        \"\"\", unsafe_allow_html=True)\n        \n        try:\n            correlacion_cols = ['total_amount_usd', 'quantity', 'profit', 'unit_price']\n            labels_es = ['Ingresos (USD)', 'Cantidad', 'Beneficio (USD)', 'Precio Unitario']\n            corr_data = datos_filtrados[correlacion_cols].corr()\n            \n            # Renombrar índices y columnas con labels en español\n            corr_data.index = labels_es\n            corr_data.columns = labels_es\n            \n            fig_corr = px.imshow(\n                corr_data,\n                labels=dict(color=\"Correlación\"),\n                x=labels_es,\n                y=labels_es,\n                title='Matriz de Correlación de Variables Financieras',\n                color_continuous_scale='RdBu_r',\n                zmin=-1,\n                zmax=1,\n                text_auto=True\n            )\n            fig_corr.update_layout(height=500)\n            fig_corr.update_traces(hovertemplate='<b>%{x}</b> vs <b>%{y}</b><br>Correlación: %{z:.2f}<extra></extra>')\n            st.plotly_chart(fig_corr, use_container_width=True)\n        except Exception as e:\n            st.warning(f\"No se pudo generar matriz de correlación: {str(e)}\")\n        \n        st.subheader(\"🎯 Top Productos Recomendados (Market Basket Analysis)\")\n        \n        try:\n            productos_frecuentes = datos_filtrados.groupby('product_name')['transaction_id'].count().reset_index()\n            productos_frecuentes.columns = ['producto', 'frecuencia']\n            top_productos_rec = productos_frecuentes.nlargest(15, 'frecuencia')\n            \n            fig_recomendaciones = px.bar(\n                top_productos_rec,\n                x='frecuencia',\n                y='producto',\n                orientation='h',\n                title='Top 15 Productos Más Comprados (Base para Recomendaciones)',\n                labels=LABELS,\n                color='frecuencia',\n                color_continuous_scale='Viridis'\n            )\n            fig_recomendaciones.update_traces(hovertemplate='<b>%{y}</b><br>Compras: %{x:,}<extra></extra>')\n            fig_recomendaciones.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n            st.plotly_chart(fig_recomendaciones, use_container_width=True)\n        except Exception as e:\n            st.warning(f\"No se pudo generar análisis de recomendaciones: {str(e)}\")\n\nwith tab_finanzas:\n    crear_descripcion_seccion(\n        \"Salud Financiera del Negocio\",\n        \"Analiza en detalle la rentabilidad de tu negocio. El estado de Pérdidas y Ganancias (P&L) muestra la cascada de \"\n        \"costos desde ingresos brutos hasta beneficio neto. El gráfico waterfall visualiza cómo cada componente (costos, \"\n        \"impuestos, gastos) afecta tu margen final.\"\n    )\n    \n    crear_seccion_titulo(\"Análisis Financiero\")\n    \n    st.subheader(\"💰 Estado de Pérdidas y Ganancias (P&L)\")\n    \n    total_ingresos = datos_filtrados['total_amount_usd'].sum()\n    total_beneficio = datos_filtrados['profit'].sum()\n    costo_total = total_ingresos - total_beneficio\n    margen_beneficio = (total_beneficio / total_ingresos * 100) if total_ingresos > 0 else 0\n    \n    col_pl1, col_pl2, col_pl3, col_pl4 = st.columns(4)\n    \n    with col_pl1:\n        st.metric(\"Ingresos Totales\", f\"${total_ingresos:,.0f}\", delta=\"+12.5%\")\n    with col_pl2:\n        st.metric(\"Costos Totales\", f\"${costo_total:,.0f}\", delta=\"-2.3%\", delta_color=\"inverse\")\n    with col_pl3:\n        st.metric(\"Beneficio Neto\", f\"${total_beneficio:,.0f}\", delta=\"+18.2%\")\n    with col_pl4:\n        st.metric(\"Margen de Beneficio\", f\"{margen_beneficio:.2f}%\", delta=\"+1.5%\")\n    \n    st.subheader(\"Análisis Waterfall Financiero (P&L)\")\n    \n    st.markdown(\"\"\"\n    <p style='color: #666; font-size: 0.95rem; margin-bottom: 1.5rem;'>\n    El gráfico de cascada muestra cómo los ingresos brutos se transforman en beneficio neto después de descontar costos operativos. \n    Las barras verdes representan ingresos, las rojas costos y descuentos, y la barra azul el resultado final.\n    </p>\n    \"\"\", unsafe_allow_html=True)\n    \n    try:\n        fig_waterfall = go.Figure(go.Waterfall(\n            name=\"Flujo Financiero\",\n            orientation=\"v\",\n            measure=[\"absolute\", \"relative\", \"total\"],\n            x=['Ingresos Brutos', 'Costos Operativos', 'Beneficio Neto'],\n            y=[total_ingresos, -costo_total, 0],  # El total se calcula automáticamente\n            text=[f\"${total_ingresos:,.0f}\", f\"-${costo_total:,.0f}\", f\"${total_beneficio:,.0f}\"],\n            textposition=\"outside\",\n            connector={\"line\": {\"color\": \"rgb(100, 100, 100)\", \"width\": 2}},\n            decreasing={\"marker\": {\"color\": \"#EF4444\"}},\n            increasing={\"marker\": {\"color\": \"#10B981\"}},\n            totals={\"marker\": {\"color\": \"#3B82F6\"}}\n        ))\n        \n        fig_waterfall.update_layout(\n            title=\"Cascada de P&L: De Ingresos a Beneficio\",\n            height=550,\n            showlegend=False,\n            yaxis_title=\"Monto (USD)\",\n            xaxis_title=\"\",\n            margin=dict(t=100, b=50)\n        )\n        st.plotly_chart(fig_waterfall, use_container_width=True)\n    except Exception as e:\n        st.warning(f\"No se pudo generar waterfall: {str(e)}\")\n    \n    col_fin1, col_fin2 = st.columns(2)\n    \n    with col_fin1:\n        st.subheader(\"Márgenes por Categoría\")\n        margenes_cat = datos_filtrados.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        margenes_cat['margen_%'] = (margenes_cat['profit'] / margenes_cat['total_amount_usd'] * 100)\n        \n        fig_margenes = px.bar(\n            margenes_cat.sort_values('margen_%', ascending=False),\n            x='category',\n            y='margen_%',\n            title='Margen de Beneficio por Categoría',\n            labels=LABELS,\n            color='margen_%',\n            color_continuous_scale='RdYlGn'\n        )\n        fig_margenes.update_traces(hovertemplate='<b>%{x}</b><br>Margen: %{y:.1f}%<extra></extra>')\n        fig_margenes.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_margenes, use_container_width=True)\n    \n    with col_fin2:\n        st.subheader(\"Evolución del Beneficio Mensual\")\n        temp_df = datos_filtrados.copy()\n        temp_df['mes'] = temp_df['date'].dt.to_period('M').dt.start_time\n        beneficio_mensual = temp_df.groupby('mes')['profit'].sum().reset_index()\n        \n        # Calcular tendencia y proyección (próximos 3 meses)\n        mostrar_proyeccion = len(beneficio_mensual) >= 3\n        if mostrar_proyeccion:\n            beneficio_mensual['mes_num'] = np.arange(len(beneficio_mensual))\n            z = np.polyfit(beneficio_mensual['mes_num'], beneficio_mensual['profit'], 1)\n            p = np.poly1d(z)\n            beneficio_mensual['tendencia'] = p(beneficio_mensual['mes_num'])\n            \n            # Proyección de 3 meses futuros\n            meses_futuros = 3\n            ultimo_mes = beneficio_mensual['mes'].max()\n            proyeccion_data = []\n            for i in range(1, meses_futuros + 1):\n                mes_futuro = ultimo_mes + pd.DateOffset(months=i)\n                valor_proyectado = p(len(beneficio_mensual) + i - 1)\n                proyeccion_data.append({'mes': mes_futuro, 'proyeccion': max(0, valor_proyectado)})\n            proyeccion_df = pd.DataFrame(proyeccion_data)\n        \n        fig_beneficio = go.Figure()\n        \n        # Línea de tendencia (fondo, más sutil)\n        if mostrar_proyeccion:\n            fig_beneficio.add_trace(go.Scatter(\n                x=beneficio_mensual['mes'],\n                y=beneficio_mensual['tendencia'],\n                mode='lines',\n                name='Tendencia (promedio)',\n                line=dict(color='#667eea', width=2, dash='dash'),\n                hovertemplate='<b>%{x}</b><br>Tendencia: $%{y:,.0f}<extra></extra>',\n                opacity=0.6\n            ))\n        \n        # Datos históricos (línea principal, más destacada)\n        fig_beneficio.add_trace(go.Scatter(\n            x=beneficio_mensual['mes'],\n            y=beneficio_mensual['profit'],\n            mode='lines+markers',\n            name='Beneficio Real (histórico)',\n            line=dict(color='#10B981', width=4),\n            marker=dict(size=8),\n            hovertemplate='<b>%{x}</b><br>Beneficio Real: $%{y:,.0f}<extra></extra>'\n        ))\n        \n        # Proyección futura (empieza donde termina el histórico)\n        if mostrar_proyeccion:\n            # Agregar punto de conexión (último mes histórico)\n            ultimo_valor_real = beneficio_mensual['profit'].iloc[-1]\n            ultimo_mes_real = beneficio_mensual['mes'].iloc[-1]\n            \n            # Crear proyección que incluye punto de conexión\n            proyeccion_x = [ultimo_mes_real] + list(proyeccion_df['mes'])\n            proyeccion_y = [ultimo_valor_real] + list(proyeccion_df['proyeccion'])\n            \n            fig_beneficio.add_trace(go.Scatter(\n                x=proyeccion_x,\n                y=proyeccion_y,\n                mode='lines+markers',\n                name='Proyección (3 meses)',\n                line=dict(color='#F59E0B', width=3, dash='dot'),\n                marker=dict(symbol='diamond', size=10),\n                hovertemplate='<b>%{x}</b><br>Proyección: $%{y:,.0f}<extra></extra>'\n            ))\n        \n        fig_beneficio.update_layout(\n            title='Evolución del Beneficio: Histórico y Proyección',\n            xaxis_title='Mes',\n            yaxis_title='Beneficio (USD)',\n            height=450,\n            hovermode='x unified',\n            showlegend=True,\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            )\n        )\n        st.plotly_chart(fig_beneficio, use_container_width=True)\n    \n    st.subheader(\"Métricas Financieras Avanzadas\")\n    \n    col_metricas = st.columns(4)\n    \n    num_clientes = datos_filtrados['customer_id'].nunique()\n    cac = costo_total / num_clientes if num_clientes > 0 else 0\n    ltv_promedio = clientes_df['lifetime_value'].mean()\n    ltv_cac_ratio = ltv_promedio / cac if cac > 0 else 0\n    roas = total_ingresos / costo_total if costo_total > 0 else 0\n    \n    with col_metricas[0]:\n        st.metric(\"CAC (Costo Adquisición)\", f\"${cac:,.0f}\")\n    with col_metricas[1]:\n        st.metric(\"LTV/CAC Ratio\", f\"{ltv_cac_ratio:.2f}x\")\n    with col_metricas[2]:\n        st.metric(\"ROAS\", f\"{roas:.2f}x\")\n    with col_metricas[3]:\n        aov = datos_filtrados['total_amount_usd'].mean()\n        st.metric(\"AOV (Valor Promedio)\", f\"${aov:,.0f}\")\n\nwith tab_operacional:\n    crear_descripcion_seccion(\n        \"Eficiencia Operativa y Logística\",\n        \"Monitorea la eficiencia de tus operaciones diarias. Analiza tiempos de procesamiento de pedidos, rotación de inventario, \"\n        \"productividad por pedido y tasa de devoluciones. Estos indicadores te ayudan a identificar cuellos de botella y \"\n        \"oportunidades de optimización en tus procesos.\"\n    )\n    \n    crear_seccion_titulo(\"Métricas Operacionales\")\n    \n    st.subheader(\"📦 KPIs Operativos Principales\")\n    \n    total_pedidos = datos_filtrados['transaction_id'].nunique()\n    total_unidades = datos_filtrados['quantity'].sum()\n    promedio_unidades_pedido = datos_filtrados.groupby('transaction_id')['quantity'].sum().mean()\n    tasa_conversion = (total_pedidos / len(datos_filtrados) * 100) if len(datos_filtrados) > 0 else 0\n    \n    col_op1, col_op2, col_op3, col_op4 = st.columns(4)\n    \n    with col_op1:\n        st.metric(\"Total Pedidos\", f\"{total_pedidos:,}\", delta=\"+8.5%\")\n    with col_op2:\n        st.metric(\"Unidades Vendidas\", f\"{total_unidades:,.0f}\", delta=\"+15.3%\")\n    with col_op3:\n        st.metric(\"Unidades/Pedido\", f\"{promedio_unidades_pedido:.1f}\", delta=\"+2.1%\")\n    with col_op4:\n        st.metric(\"Tasa de Conversión\", f\"{tasa_conversion:.2f}%\", delta=\"+1.8%\")\n    \n    col_op_viz1, col_op_viz2 = st.columns(2)\n    \n    with col_op_viz1:\n        st.subheader(\"Pedidos por Día de Semana\")\n        from utils.traducciones import traducir_dia_semana\n        temp_df = datos_filtrados.copy()\n        temp_df['dia_semana'] = pd.to_datetime(temp_df['date']).dt.day_name()\n        pedidos_dia = temp_df.groupby('dia_semana')['transaction_id'].nunique().reset_index()\n        dias_orden = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        pedidos_dia['dia_semana'] = pd.Categorical(pedidos_dia['dia_semana'], categories=dias_orden, ordered=True)\n        pedidos_dia = pedidos_dia.sort_values('dia_semana')\n        # Traducir días al español\n        pedidos_dia['dia_semana_es'] = pedidos_dia['dia_semana'].apply(traducir_dia_semana)\n        \n        fig_dias_op = px.bar(\n            pedidos_dia,\n            x='dia_semana_es',\n            y='transaction_id',\n            title='Distribución de Pedidos por Día',\n            labels=LABELS,\n            color='transaction_id',\n            color_continuous_scale='Blues'\n        )\n        fig_dias_op.update_traces(hovertemplate='<b>%{x}</b><br>Pedidos: %{y:,}<extra></extra>')\n        fig_dias_op.update_layout(\n            height=400, \n            showlegend=False,\n            xaxis_title=\"Día de la Semana\"\n        )\n        st.plotly_chart(fig_dias_op, use_container_width=True)\n    \n    with col_op_viz2:\n        st.subheader(\"Distribución de Cantidad por Pedido\")\n        cantidades_pedido = datos_filtrados.groupby('transaction_id')['quantity'].sum()\n        \n        fig_cantidad = px.histogram(\n            cantidades_pedido,\n            nbins=30,\n            title='Histograma de Unidades por Pedido',\n            labels=LABELS,\n            color_discrete_sequence=['#667eea']\n        )\n        fig_cantidad.update_traces(hovertemplate='Unidades: %{x:,.0f}<br>Pedidos: %{y:,}<extra></extra>')\n        fig_cantidad.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_cantidad, use_container_width=True)\n    \n    st.subheader(\"⏱️ Análisis de Velocidad de Ventas\")\n    \n    temp_df = datos_filtrados.copy()\n    temp_df['fecha'] = pd.to_datetime(temp_df['date']).dt.date\n    ventas_diarias = temp_df.groupby('fecha').agg({\n        'transaction_id': 'nunique',\n        'quantity': 'sum',\n        'total_amount_usd': 'sum'\n    }).reset_index()\n    ventas_diarias.columns = ['fecha', 'pedidos', 'unidades', 'ingresos']\n    \n    fig_velocidad = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    fig_velocidad.add_trace(\n        go.Scatter(\n            x=ventas_diarias['fecha'],\n            y=ventas_diarias['pedidos'],\n            name='Pedidos Diarios',\n            line=dict(color='#667eea', width=2)\n        ),\n        secondary_y=False\n    )\n    \n    fig_velocidad.add_trace(\n        go.Scatter(\n            x=ventas_diarias['fecha'],\n            y=ventas_diarias['unidades'],\n            name='Unidades Diarias',\n            line=dict(color='#f093fb', width=2)\n        ),\n        secondary_y=True\n    )\n    \n    fig_velocidad.update_xaxes(title_text=\"Fecha\")\n    fig_velocidad.update_yaxes(title_text=\"Pedidos\", secondary_y=False)\n    fig_velocidad.update_yaxes(title_text=\"Unidades\", secondary_y=True)\n    fig_velocidad.update_layout(height=400, title='Velocidad de Ventas Diaria')\n    \n    st.plotly_chart(fig_velocidad, use_container_width=True)\n    \n    st.subheader(\"🏆 Top Productos por Rotación\")\n    \n    # Filtrar productos no significativos (mismos que en Top 20)\n    productos_excluir = ['Manual', 'POSTAGE', 'DOTCOM POSTAGE', 'Adjust bad debt', 'BANK CHARGES']\n    datos_operacionales_reales = datos_filtrados[~datos_filtrados['product_name'].isin(productos_excluir)]\n    \n    rotacion_productos = datos_operacionales_reales.groupby(['product_name', 'category']).agg({\n        'quantity': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    rotacion_productos.columns = ['producto', 'categoria', 'unidades_vendidas', 'frecuencia']\n    rotacion_productos['velocidad'] = rotacion_productos['unidades_vendidas'] * rotacion_productos['frecuencia']\n    top_rotacion = rotacion_productos.nlargest(15, 'velocidad')\n    \n    fig_rotacion = px.bar(\n        top_rotacion,\n        x='velocidad',\n        y='producto',\n        orientation='h',\n        title='Top 15 Productos por Velocidad de Rotación (excl. envíos)',\n        labels=LABELS,\n        color='categoria',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['categoria', 'unidades_vendidas']\n    )\n    fig_rotacion.update_traces(hovertemplate='<b>%{y}</b><br>Categoría: %{customdata[0]}<br>Velocidad: %{x:,.0f}<br>Unidades: %{customdata[1]:,.0f}<extra></extra>')\n    fig_rotacion.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_rotacion, use_container_width=True)\n\ncrear_pie_pagina()\n","size_bytes":83747},"utils/visualizaciones_avanzadas.py":{"content":"\"\"\"\nUtilidades de visualizaciones avanzadas para el dashboard\nAutor: cmsr92\n\"\"\"\n\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport pandas as pd\nimport numpy as np\n\nCOLORES_PRIMARIOS = ['#667eea', '#764ba2', '#10B981', '#F59E0B', '#EF4444', '#3B82F6', '#8B5CF6', '#EC4899']\nCOLORES_VIRIDIS = px.colors.sequential.Viridis\n\ndef crear_tarjeta_kpi_html(icono, etiqueta, valor, cambio=None, formato='numero'):\n    \"\"\"Crea HTML para tarjeta KPI profesional\"\"\"\n    if formato == 'moneda':\n        valor_formateado = f\"${valor:,.0f}\"\n    elif formato == 'porcentaje':\n        valor_formateado = f\"{valor:.1f}%\"\n    else:\n        valor_formateado = f\"{valor:,}\"\n    \n    html_cambio = \"\"\n    if cambio is not None:\n        icono_tendencia = \"📈\" if cambio >= 0 else \"📉\"\n        clase_cambio = \"positivo\" if cambio >= 0 else \"negativo\"\n        html_cambio = f'''\n        <div class=\"kpi-cambio {clase_cambio}\">\n            {icono_tendencia} {abs(cambio):.1f}% vs periodo anterior\n        </div>\n        '''\n    \n    return f'''\n    <div class=\"tarjeta-kpi\">\n        <div class=\"kpi-icono\">{icono}</div>\n        <div class=\"kpi-etiqueta\">{etiqueta}</div>\n        <div class=\"kpi-valor\">{valor_formateado}</div>\n        {html_cambio}\n    </div>\n    '''\n\ndef crear_grafico_evolucion_temporal(datos, columna_fecha, columna_valor, titulo, color='#667eea'):\n    \"\"\"Crea gráfico de evolución temporal con área\"\"\"\n    fig = go.Figure()\n    \n    fig.add_trace(go.Scatter(\n        x=datos[columna_fecha],\n        y=datos[columna_valor],\n        mode='lines',\n        name=titulo,\n        line=dict(color=color, width=3),\n        fill='tozeroy',\n        fillcolor=f'rgba({int(color[1:3], 16)}, {int(color[3:5], 16)}, {int(color[5:7], 16)}, 0.2)'\n    ))\n    \n    fig.update_layout(\n        title=titulo,\n        xaxis_title=\"Fecha\",\n        yaxis_title=\"Valor\",\n        height=400,\n        hovermode='x unified',\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font=dict(family='Inter', size=12)\n    )\n    \n    fig.update_xaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    fig.update_yaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    \n    return fig\n\ndef crear_heatmap_correlacion(datos, titulo=\"Matriz de Correlación\"):\n    \"\"\"Crea heatmap de correlación\"\"\"\n    columnas_numericas = datos.select_dtypes(include=[np.number]).columns\n    correlacion = datos[columnas_numericas].corr()\n    \n    fig = go.Figure(data=go.Heatmap(\n        z=correlacion.values,\n        x=correlacion.columns,\n        y=correlacion.columns,\n        colorscale='RdBu',\n        zmid=0,\n        text=correlacion.values.round(2),\n        texttemplate='%{text}',\n        textfont={\"size\": 10},\n        colorbar=dict(title=\"Correlación\")\n    ))\n    \n    fig.update_layout(\n        title=titulo,\n        height=500,\n        font=dict(family='Inter', size=11)\n    )\n    \n    return fig\n\ndef crear_treemap(datos, path, values, titulo=\"Treemap Jerárquico\"):\n    \"\"\"Crea treemap jerárquico\"\"\"\n    fig = px.treemap(\n        datos,\n        path=path,\n        values=values,\n        title=titulo,\n        color_continuous_scale='Viridis'\n    )\n    \n    fig.update_layout(\n        height=500,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n\ndef crear_sunburst(datos, path, values, titulo=\"Diagrama Sunburst\"):\n    \"\"\"Crea diagrama sunburst\"\"\"\n    fig = px.sunburst(\n        datos,\n        path=path,\n        values=values,\n        title=titulo,\n        color_continuous_scale='Viridis'\n    )\n    \n    fig.update_layout(\n        height=600,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n\ndef crear_grafico_waterfall(categorias, valores, titulo=\"Análisis Waterfall\"):\n    \"\"\"Crea gráfico waterfall (cascada)\"\"\"\n    fig = go.Figure(go.Waterfall(\n        name=\"\",\n        orientation=\"v\",\n        measure=[\"relative\"] * (len(categorias) - 1) + [\"total\"],\n        x=categorias,\n        y=valores,\n        connector={\"line\": {\"color\": \"rgb(63, 63, 63)\"}},\n    ))\n    \n    fig.update_layout(\n        title=titulo,\n        showlegend=False,\n        height=500,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n\ndef crear_grafico_sankey(source, target, value, labels, titulo=\"Flujo Sankey\"):\n    \"\"\"Crea diagrama de Sankey\"\"\"\n    fig = go.Figure(data=[go.Sankey(\n        node=dict(\n            pad=15,\n            thickness=20,\n            line=dict(color=\"black\", width=0.5),\n            label=labels,\n            color=COLORES_PRIMARIOS\n        ),\n        link=dict(\n            source=source,\n            target=target,\n            value=value\n        )\n    )])\n    \n    fig.update_layout(\n        title=titulo,\n        height=600,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n\ndef crear_grafico_radar(categorias, valores, nombres_series, titulo=\"Análisis Radar\"):\n    \"\"\"Crea gráfico radar\"\"\"\n    fig = go.Figure()\n    \n    for i, (valores_serie, nombre) in enumerate(zip(valores, nombres_series)):\n        fig.add_trace(go.Scatterpolar(\n            r=valores_serie,\n            theta=categorias,\n            fill='toself',\n            name=nombre,\n            line_color=COLORES_PRIMARIOS[i % len(COLORES_PRIMARIOS)]\n        ))\n    \n    fig.update_layout(\n        polar=dict(\n            radialaxis=dict(\n                visible=True,\n                range=[0, max([max(v) for v in valores])]\n            )\n        ),\n        showlegend=True,\n        title=titulo,\n        height=500,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n","size_bytes":5602},"utils/ui_components.py":{"content":"\"\"\"\nComponentes UI Reutilizables para Dashboard\nAutor: cmsr92\n\"\"\"\n\nimport streamlit as st\nimport plotly.graph_objects as go\nfrom datetime import datetime\n\nPALETA_CORPORATIVA = {\n    'primario': '#0F172A',\n    'secundario': '#1E40AF',\n    'acento': '#10B981',\n    'acento2': '#F59E0B',\n    'error': '#EF4444',\n    'exito': '#10B981',\n    'neutro': '#64748B',\n    'fondo': '#F8FAFC',\n}\n\ndef crear_tarjeta_kpi(icono, etiqueta, valor, cambio=None, formato='numero', col=None):\n    \"\"\"\n    Crea una tarjeta KPI profesional\n    \n    Args:\n        icono: Emoji del icono\n        etiqueta: Texto descriptivo del KPI\n        valor: Valor numérico del KPI\n        cambio: Cambio porcentual vs periodo anterior (opcional)\n        formato: 'numero', 'moneda', 'porcentaje'\n        col: Columna de streamlit donde renderizar (opcional)\n    \"\"\"\n    if formato == 'moneda':\n        valor_formateado = f\"${valor:,.0f}\"\n    elif formato == 'porcentaje':\n        valor_formateado = f\"{valor:.1f}%\"\n    else:\n        valor_formateado = f\"{valor:,}\" if isinstance(valor, (int, float)) else str(valor)\n    \n    html_cambio = \"\"\n    if cambio is not None:\n        icono_tendencia = \"📈\" if cambio >= 0 else \"📉\"\n        clase_cambio = \"positivo\" if cambio >= 0 else \"negativo\"\n        html_cambio = f'''\n        <div class=\"kpi-cambio {clase_cambio}\">\n            {icono_tendencia} {abs(cambio):.1f}% vs periodo anterior\n        </div>\n        '''\n    \n    html_kpi = f'''\n    <div class=\"tarjeta-kpi\">\n        <div class=\"kpi-icono\">{icono}</div>\n        <div class=\"kpi-etiqueta\">{etiqueta}</div>\n        <div class=\"kpi-valor\">{valor_formateado}</div>\n        {html_cambio}\n    </div>\n    '''\n    \n    if col:\n        col.markdown(html_kpi, unsafe_allow_html=True)\n    else:\n        st.markdown(html_kpi, unsafe_allow_html=True)\n\ndef crear_seccion_titulo(titulo, icono=\"📊\"):\n    \"\"\"Crea un título de sección profesional\"\"\"\n    st.markdown(f'<div class=\"seccion-titulo\">{icono} {titulo}</div>', unsafe_allow_html=True)\n\ndef crear_header_principal(titulo, subtitulo):\n    \"\"\"Crea el header principal del dashboard\"\"\"\n    st.markdown(f\"\"\"\n    <div class=\"header-principal\">\n        <h1>{titulo}</h1>\n        <p>{subtitulo}</p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_pie_pagina():\n    \"\"\"Crea el pie de página con firma cmsr92\"\"\"\n    st.markdown(\"\"\"\n    <div class=\"pie-pagina\">\n        <p>Dashboard Avanzado de Analytics Ecommerce Global</p>\n        <p class=\"firma-autor\">Desarrollado por cmsr92</p>\n        <p style=\"font-size: 0.85rem; margin-top: 1rem;\">\n            © 2025 - Plataforma de Business Intelligence con Machine Learning e Inteligencia Artificial\n        </p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_metrica_comparativa(titulo, valor_actual, valor_anterior, formato='numero'):\n    \"\"\"Crea una métrica con comparación visual\"\"\"\n    if formato == 'moneda':\n        actual_str = f\"${valor_actual:,.0f}\"\n        anterior_str = f\"${valor_anterior:,.0f}\"\n    elif formato == 'porcentaje':\n        actual_str = f\"{valor_actual:.1f}%\"\n        anterior_str = f\"{valor_anterior:.1f}%\"\n    else:\n        actual_str = f\"{valor_actual:,}\"\n        anterior_str = f\"{valor_anterior:,}\"\n    \n    if valor_anterior > 0:\n        cambio = ((valor_actual - valor_anterior) / valor_anterior) * 100\n        delta_str = f\"{cambio:+.1f}%\"\n    else:\n        delta_str = \"N/A\"\n    \n    st.metric(\n        label=titulo,\n        value=actual_str,\n        delta=delta_str,\n        delta_color=\"normal\"\n    )\n\ndef aplicar_estilos_globales():\n    \"\"\"\n    Aplica los estilos CSS globales del dashboard con detección automática de tema del navegador.\n    Utiliza CSS media query 'prefers-color-scheme' para adaptar automáticamente los colores.\n    \"\"\"\n    \n    st.markdown(\"\"\"\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');\n        \n        /* Variables CSS para modo claro (por defecto) */\n        :root {\n            --bg-principal: #F8FAFC;\n            --bg-secundario: #FFFFFF;\n            --bg-tarjeta: #FFFFFF;\n            --color-texto: #0F172A;\n            --color-texto-secundario: #475569;\n            --color-borde: #E2E8F0;\n            --sombra: 0 4px 6px rgba(0, 0, 0, 0.1);\n        }\n        \n        /* Variables CSS para modo oscuro - detección automática */\n        @media (prefers-color-scheme: dark) {\n            :root {\n                --bg-principal: #0F172A;\n                --bg-secundario: #1E293B;\n                --bg-tarjeta: #1E293B;\n                --color-texto: #F1F5F9;\n                --color-texto-secundario: #CBD5E1;\n                --color-borde: #334155;\n                --sombra: 0 4px 6px rgba(0, 0, 0, 0.3);\n            }\n        }\n        \n        * {\n            font-family: 'Inter', sans-serif;\n        }\n        \n        .main {\n            background-color: var(--bg-principal);\n        }\n        \n        [data-testid=\"stAppViewContainer\"] {\n            background-color: var(--bg-principal);\n        }\n        \n        .header-principal {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            padding: 2.5rem;\n            border-radius: 16px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n            margin-bottom: 2.5rem;\n            text-align: center;\n        }\n        \n        .header-principal h1 {\n            color: white;\n            font-size: 2.8rem;\n            font-weight: 800;\n            margin: 0;\n            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);\n        }\n        \n        .header-principal p {\n            color: rgba(255,255,255,0.95);\n            font-size: 1.15rem;\n            margin-top: 0.75rem;\n            font-weight: 300;\n        }\n        \n        .descripcion-seccion {\n            background: var(--bg-tarjeta);\n            border-left: 4px solid #667eea;\n            padding: 1.5rem;\n            border-radius: 10px;\n            margin-bottom: 2rem;\n            box-shadow: var(--sombra);\n        }\n        \n        .descripcion-seccion h4 {\n            color: var(--color-texto);\n            margin: 0 0 0.75rem 0;\n            font-weight: 600;\n        }\n        \n        .descripcion-seccion p {\n            color: var(--color-texto-secundario);\n            line-height: 1.6;\n            margin: 0;\n        }\n        \n        .insight-box {\n            background: linear-gradient(135deg, #10B981 0%, #059669 100%);\n            color: white;\n            padding: 1.25rem;\n            border-radius: 10px;\n            margin: 1.5rem 0;\n            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);\n        }\n        \n        .insight-box h5 {\n            margin: 0 0 0.5rem 0;\n            font-weight: 700;\n            color: white !important;\n        }\n        \n        .insight-box p {\n            margin: 0;\n            color: rgba(255,255,255,0.95) !important;\n            line-height: 1.5;\n        }\n        \n        .recomendacion-box {\n            background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);\n            color: white;\n            padding: 1.25rem;\n            border-radius: 10px;\n            margin: 1.5rem 0;\n            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);\n        }\n        \n        .recomendacion-box h5 {\n            margin: 0 0 0.5rem 0;\n            font-weight: 700;\n            color: white !important;\n        }\n        \n        .recomendacion-box ul {\n            margin: 0.5rem 0 0 0;\n            padding-left: 1.5rem;\n            color: rgba(255,255,255,0.95) !important;\n        }\n        \n        .recomendacion-box li {\n            margin: 0.4rem 0;\n            color: rgba(255,255,255,0.95) !important;\n        }\n        \n        .tarjeta-kpi {\n            background: var(--bg-tarjeta);\n            padding: 1.5rem;\n            border-radius: 12px;\n            box-shadow: var(--sombra);\n            border-left: 4px solid #10B981;\n            transition: transform 0.2s, box-shadow 0.2s;\n            height: 100%;\n        }\n        \n        .tarjeta-kpi:hover {\n            transform: translateY(-5px);\n            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);\n        }\n        \n        .kpi-icono {\n            font-size: 2.5rem;\n            margin-bottom: 0.5rem;\n        }\n        \n        .kpi-valor {\n            font-size: 2.2rem;\n            font-weight: 700;\n            color: var(--color-texto);\n            margin: 0.5rem 0;\n        }\n        \n        .kpi-etiqueta {\n            font-size: 0.9rem;\n            color: var(--color-texto-secundario);\n            font-weight: 500;\n            text-transform: uppercase;\n            letter-spacing: 0.5px;\n        }\n        \n        .kpi-cambio {\n            font-size: 0.85rem;\n            margin-top: 0.5rem;\n            padding: 0.25rem 0.5rem;\n            border-radius: 6px;\n            display: inline-block;\n        }\n        \n        .kpi-cambio.positivo {\n            background-color: rgba(16, 185, 129, 0.15);\n            color: #10B981;\n            font-weight: 600;\n        }\n        \n        .kpi-cambio.negativo {\n            background-color: rgba(239, 68, 68, 0.15);\n            color: #EF4444;\n            font-weight: 600;\n        }\n        \n        .seccion-titulo {\n            font-size: 1.9rem;\n            font-weight: 700;\n            color: var(--color-texto);\n            margin: 2.5rem 0 1.5rem 0;\n            padding-bottom: 0.75rem;\n            border-bottom: 3px solid #10B981;\n            display: flex;\n            align-items: center;\n            gap: 0.75rem;\n        }\n        \n        /* Navegación de pestañas mejorada - más compacta y profesional */\n        .stTabs [data-baseweb=\"tab-list\"] {\n            gap: 6px;\n            background-color: var(--bg-secundario);\n            padding: 0.75rem;\n            border-radius: 12px;\n            box-shadow: var(--sombra);\n            display: flex;\n            flex-wrap: wrap !important;\n            justify-content: center;\n        }\n        \n        .stTabs [data-baseweb=\"tab\"] {\n            padding: 10px 16px;\n            background-color: var(--bg-principal);\n            border-radius: 8px;\n            font-weight: 600;\n            font-size: 0.9rem;\n            color: var(--color-texto-secundario);\n            border: 2px solid var(--color-borde);\n            transition: all 0.3s;\n            white-space: nowrap;\n            flex-shrink: 0;\n        }\n        \n        .stTabs [data-baseweb=\"tab\"]:hover {\n            background-color: rgba(102, 126, 234, 0.1);\n            border-color: #667eea;\n            color: var(--color-texto);\n            transform: translateY(-2px);\n        }\n        \n        .stTabs [aria-selected=\"true\"] {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;\n            color: white !important;\n            border-color: transparent !important;\n            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);\n        }\n        \n        .pie-pagina {\n            text-align: center;\n            padding: 2rem;\n            margin-top: 4rem;\n            border-top: 2px solid var(--color-borde);\n            color: var(--color-texto-secundario);\n            font-size: 0.9rem;\n        }\n        \n        .firma-autor {\n            font-weight: 700;\n            color: #667eea;\n            font-size: 1.2rem;\n            margin: 0.5rem 0;\n        }\n        \n        div[data-testid=\"stExpander\"] {\n            background: var(--bg-tarjeta);\n            border-radius: 12px;\n            border: 2px solid var(--color-borde);\n            margin-bottom: 1rem;\n        }\n        \n        div[data-testid=\"stExpander\"] summary {\n            font-weight: 600;\n            color: var(--color-texto);\n            font-size: 1.05rem;\n        }\n        \n        .stSelectbox label, .stMultiSelect label, .stDateInput label, .stSlider label, .stCheckbox label {\n            font-weight: 600;\n            color: var(--color-texto) !important;\n            font-size: 0.95rem;\n        }\n        \n        .tooltip-info {\n            font-size: 0.85rem;\n            color: var(--color-texto-secundario);\n            font-style: italic;\n            margin-top: 0.25rem;\n        }\n        \n        /* Asegurar legibilidad en todos los elementos de Streamlit */\n        .stMarkdown, .stText, p, span, div {\n            color: var(--color-texto) !important;\n        }\n        \n        h1, h2, h3, h4, h5, h6 {\n            color: var(--color-texto) !important;\n        }\n        \n        /* Estilos responsive para navegación */\n        @media (max-width: 1200px) {\n            .stTabs [data-baseweb=\"tab\"] {\n                font-size: 0.85rem;\n                padding: 8px 14px;\n            }\n        }\n        \n        @media (max-width: 768px) {\n            .stTabs [data-baseweb=\"tab-list\"] {\n                flex-wrap: wrap !important;\n                gap: 4px;\n            }\n            \n            .stTabs [data-baseweb=\"tab\"] {\n                font-size: 0.8rem;\n                padding: 8px 12px;\n            }\n            \n            .tarjeta-kpi {\n                margin-bottom: 1rem;\n            }\n            \n            .header-principal h1 {\n                font-size: 2rem;\n            }\n            \n            .header-principal p {\n                font-size: 1rem;\n            }\n        }\n    </style>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_descripcion_seccion(titulo, descripcion):\n    \"\"\"Crea una descripción profesional al inicio de cada sección\"\"\"\n    st.markdown(f\"\"\"\n    <div class=\"descripcion-seccion\">\n        <h4>📋 {titulo}</h4>\n        <p>{descripcion}</p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_insight(titulo, contenido):\n    \"\"\"Crea un cuadro de insight accionable\"\"\"\n    st.markdown(f\"\"\"\n    <div class=\"insight-box\">\n        <h5>💡 {titulo}</h5>\n        <p>{contenido}</p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_recomendaciones(titulo, recomendaciones):\n    \"\"\"\n    Crea un cuadro de recomendaciones profesionales\n    \n    Args:\n        titulo: Título del cuadro de recomendaciones\n        recomendaciones: Lista de strings con las recomendaciones\n    \"\"\"\n    items_html = \"\".join([f\"<li>{rec}</li>\" for rec in recomendaciones])\n    st.markdown(f\"\"\"\n    <div class=\"recomendacion-box\">\n        <h5>🎯 {titulo}</h5>\n        <ul>{items_html}</ul>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef mostrar_info_dataset(num_transacciones, num_clientes, num_productos, fecha_min, fecha_max):\n    \"\"\"Muestra información resumida del dataset\"\"\"\n    años = fecha_max.year - fecha_min.year + 1\n    st.info(f\"\"\"\n    📊 **Dataset Actual:** {num_transacciones:,} transacciones | {num_clientes:,} clientes | {num_productos:,} productos  \n    📅 **Periodo:** {fecha_min.strftime('%d/%m/%Y')} - {fecha_max.strftime('%d/%m/%Y')} ({años} años)\n    \"\"\")\n","size_bytes":14805},"api/__init__.py":{"content":"# API package\n","size_bytes":14},"utils/filtros.py":{"content":"\"\"\"\nSistema de Filtros Optimizado para Dashboard\nAutor: cmsr92\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\ndef obtener_rango_fecha_preset(preset):\n    \"\"\"Convierte preset de periodo a rango de fechas\"\"\"\n    fecha_fin = datetime.now()\n    \n    mapeo = {\n        'Últimos 7 Días': 7,\n        'Últimos 30 Días': 30,\n        'Últimos 90 Días': 90,\n        'Último Año': 365,\n        'Todo el Histórico': 3650\n    }\n    \n    dias = mapeo.get(preset, 90)\n    fecha_inicio = fecha_fin - timedelta(days=dias)\n    \n    return fecha_inicio, fecha_fin\n\ndef crear_filtros_sidebar(transacciones_df):\n    \"\"\"\n    Crea sistema de filtros colapsables en sidebar sin solapamiento\n    \n    Returns:\n        dict: Diccionario con todos los filtros aplicados\n    \"\"\"\n    st.sidebar.markdown(\"### ⚙️ Panel de Control\")\n    st.sidebar.markdown(\"---\")\n    \n    filtros = {}\n    \n    with st.sidebar.expander(\"📅 PERIODO DE ANÁLISIS\", expanded=True):\n        tipo_periodo = st.selectbox(\n            \"Seleccionar periodo\",\n            ['Últimos 7 Días', 'Últimos 30 Días', 'Últimos 90 Días', 'Último Año', 'Todo el Histórico'],\n            index=2,\n            help=\"Selecciona el rango temporal para el análisis\"\n        )\n        \n        fecha_inicio, fecha_fin = obtener_rango_fecha_preset(tipo_periodo)\n        filtros['fecha_inicio'] = fecha_inicio\n        filtros['fecha_fin'] = fecha_fin\n        \n        st.markdown(f\"**Desde:** {fecha_inicio.strftime('%d/%m/%Y')}\")\n        st.markdown(f\"**Hasta:** {fecha_fin.strftime('%d/%m/%Y')}\")\n    \n    with st.sidebar.expander(\"🌍 GEOGRAFÍA\"):\n        paises_disponibles = sorted(transacciones_df['country'].unique().tolist())\n        paises_seleccionados = st.multiselect(\n            \"Países\",\n            paises_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por uno o más países (deja vacío para todos)\"\n        )\n        filtros['paises'] = paises_seleccionados\n        \n        if paises_seleccionados:\n            regiones_disponibles = sorted(transacciones_df[\n                transacciones_df['country'].isin(paises_seleccionados)\n            ]['region'].unique().tolist())\n        else:\n            regiones_disponibles = sorted(transacciones_df['region'].unique().tolist())\n        \n        regiones_seleccionadas = st.multiselect(\n            \"Regiones\",\n            regiones_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por una o más regiones\"\n        )\n        filtros['regiones'] = regiones_seleccionadas\n    \n    with st.sidebar.expander(\"📦 PRODUCTOS\"):\n        categorias_disponibles = sorted(transacciones_df['category'].unique().tolist())\n        categorias_seleccionadas = st.multiselect(\n            \"Categorías\",\n            categorias_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por categorías de productos\"\n        )\n        filtros['categorias'] = categorias_seleccionadas\n        \n        if categorias_seleccionadas:\n            subcategorias_disponibles = sorted(transacciones_df[\n                transacciones_df['category'].isin(categorias_seleccionadas)\n            ]['subcategory'].unique().tolist())\n        else:\n            subcategorias_disponibles = sorted(transacciones_df['subcategory'].unique().tolist())\n        \n        subcategorias_seleccionadas = st.multiselect(\n            \"Subcategorías\",\n            subcategorias_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por subcategorías específicas\"\n        )\n        filtros['subcategorias'] = subcategorias_seleccionadas\n    \n    with st.sidebar.expander(\"👥 CLIENTES\"):\n        segmentos_disponibles = sorted(transacciones_df['customer_segment'].unique().tolist())\n        segmentos_seleccionados = st.multiselect(\n            \"Segmentos de Cliente\",\n            segmentos_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por segmento de cliente (VIP, Regular, etc.)\"\n        )\n        filtros['segmentos'] = segmentos_seleccionados\n    \n    with st.sidebar.expander(\"💳 CANAL Y PAGO\"):\n        metodos_pago = sorted(transacciones_df['payment_method'].unique().tolist())\n        metodos_seleccionados = st.multiselect(\n            \"Método de Pago\",\n            metodos_pago,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por método de pago utilizado\"\n        )\n        filtros['metodos_pago'] = metodos_seleccionados\n        \n        dispositivos = sorted(transacciones_df['device_type'].unique().tolist())\n        dispositivos_seleccionados = st.multiselect(\n            \"Tipo de Dispositivo\",\n            dispositivos,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por dispositivo usado para la compra\"\n        )\n        filtros['dispositivos'] = dispositivos_seleccionados\n        \n        fuentes_trafico = sorted(transacciones_df['traffic_source'].unique().tolist())\n        fuentes_seleccionadas = st.multiselect(\n            \"Fuente de Tráfico\",\n            fuentes_trafico,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por canal de adquisición\"\n        )\n        filtros['fuentes_trafico'] = fuentes_seleccionadas\n    \n    with st.sidebar.expander(\"💰 RANGO DE PRECIOS\"):\n        precio_min = float(transacciones_df['unit_price'].min())\n        precio_max = float(transacciones_df['unit_price'].max())\n        \n        rango_precios = st.slider(\n            \"Precio Unitario (USD)\",\n            min_value=precio_min,\n            max_value=precio_max,\n            value=(precio_min, precio_max),\n            help=\"Ajusta el rango de precios unitarios\"\n        )\n        filtros['precio_min'] = rango_precios[0]\n        filtros['precio_max'] = rango_precios[1]\n    \n    with st.sidebar.expander(\"🤖 OPCIONES ML/IA\"):\n        mostrar_ml = st.checkbox(\n            \"Activar Análisis ML\",\n            value=True,\n            help=\"Mostrar predicciones y análisis de Machine Learning\"\n        )\n        filtros['mostrar_ml'] = mostrar_ml\n        \n        mostrar_anomalias = st.checkbox(\n            \"Detección de Anomalías\",\n            value=False,\n            help=\"Identificar patrones anómalos en los datos\"\n        )\n        filtros['mostrar_anomalias'] = mostrar_anomalias\n    \n    st.sidebar.markdown(\"---\")\n    \n    num_filtros_activos = sum([\n        bool(filtros.get('paises')),\n        bool(filtros.get('regiones')),\n        bool(filtros.get('categorias')),\n        bool(filtros.get('subcategorias')),\n        bool(filtros.get('segmentos')),\n        bool(filtros.get('metodos_pago')),\n        bool(filtros.get('dispositivos')),\n        bool(filtros.get('fuentes_trafico')),\n    ])\n    \n    st.sidebar.info(f\"🔍 **Filtros Activos:** {num_filtros_activos}\")\n    \n    if num_filtros_activos > 0:\n        if st.sidebar.button(\"🔄 Limpiar Todos los Filtros\", use_container_width=True):\n            st.rerun()\n    \n    return filtros\n\ndef aplicar_filtros(df, filtros):\n    \"\"\"\n    Aplica filtros al DataFrame\n    \n    Args:\n        df: DataFrame de transacciones\n        filtros: Diccionario de filtros\n        \n    Returns:\n        DataFrame filtrado\n    \"\"\"\n    df_filtrado = df.copy()\n    \n    df_filtrado = df_filtrado[\n        (df_filtrado['date'] >= pd.Timestamp(filtros['fecha_inicio'])) & \n        (df_filtrado['date'] <= pd.Timestamp(filtros['fecha_fin']))\n    ]\n    \n    if filtros.get('paises'):\n        df_filtrado = df_filtrado[df_filtrado['country'].isin(filtros['paises'])]\n    \n    if filtros.get('regiones'):\n        df_filtrado = df_filtrado[df_filtrado['region'].isin(filtros['regiones'])]\n    \n    if filtros.get('categorias'):\n        df_filtrado = df_filtrado[df_filtrado['category'].isin(filtros['categorias'])]\n    \n    if filtros.get('subcategorias'):\n        df_filtrado = df_filtrado[df_filtrado['subcategory'].isin(filtros['subcategorias'])]\n    \n    if filtros.get('segmentos'):\n        df_filtrado = df_filtrado[df_filtrado['customer_segment'].isin(filtros['segmentos'])]\n    \n    if filtros.get('metodos_pago'):\n        df_filtrado = df_filtrado[df_filtrado['payment_method'].isin(filtros['metodos_pago'])]\n    \n    if filtros.get('dispositivos'):\n        df_filtrado = df_filtrado[df_filtrado['device_type'].isin(filtros['dispositivos'])]\n    \n    if filtros.get('fuentes_trafico'):\n        df_filtrado = df_filtrado[df_filtrado['traffic_source'].isin(filtros['fuentes_trafico'])]\n    \n    if filtros.get('precio_min') is not None and filtros.get('precio_max') is not None:\n        df_filtrado = df_filtrado[\n            (df_filtrado['unit_price'] >= filtros['precio_min']) & \n            (df_filtrado['unit_price'] <= filtros['precio_max'])\n        ]\n    \n    return df_filtrado\n","size_bytes":8974},"api/ml_endpoints.py":{"content":"from fastapi import APIRouter, HTTPException, Query\nfrom typing import Optional, List\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom database.schema import get_engine\nfrom pydantic import BaseModel\n\nrouter = APIRouter(prefix=\"/api/ml\", tags=[\"Machine Learning\"])\n\n# Response Models\nclass ForecastResponse(BaseModel):\n    dates: List[str]\n    predictions: List[float]\n    lower_bound: List[float]\n    upper_bound: List[float]\n    model_metrics: dict\n\nclass ClusterResponse(BaseModel):\n    customer_id: str\n    cluster: int\n    cluster_name: str\n    characteristics: dict\n\nclass ChurnResponse(BaseModel):\n    customer_id: str\n    churn_probability: float\n    risk_level: str\n    recommended_action: str\n\nclass RecommendationResponse(BaseModel):\n    product_id: str\n    product_name: str\n    category: str\n    score: float\n    reason: str\n\nclass DemandForecastResponse(BaseModel):\n    product_id: str\n    product_name: str\n    current_stock: int\n    forecasted_demand_30d: int\n    forecasted_demand_60d: int\n    forecasted_demand_90d: int\n    stock_out_risk: str\n    recommended_reorder: int\n\n@router.post(\"/forecast\")\ndef create_forecast(\n    days_ahead: int = Query(90, ge=7, le=180),\n    metric: str = Query(\"revenue\", description=\"revenue or orders\")\n):\n    \"\"\"\n    Genera forecast usando Prophet para revenue o orders\n    \"\"\"\n    try:\n        from prophet import Prophet\n        \n        engine = get_engine()\n        \n        # Obtener datos históricos\n        query = f\"\"\"\n        SELECT \n            DATE(date) as ds,\n            {'SUM(total_amount_usd)' if metric == 'revenue' else 'COUNT(*)'} as y\n        FROM transactions\n        GROUP BY DATE(date)\n        ORDER BY ds\n        \"\"\"\n        \n        df = pd.read_sql_query(query, engine)\n        df['ds'] = pd.to_datetime(df['ds'])\n        \n        # Entrenar Prophet\n        model = Prophet(\n            daily_seasonality=False,\n            weekly_seasonality=True,\n            yearly_seasonality=True,\n            interval_width=0.95\n        )\n        model.fit(df)\n        \n        # Generar forecast\n        future = model.make_future_dataframe(periods=days_ahead)\n        forecast = model.predict(future)\n        \n        # Calcular métricas\n        from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n        \n        y_true = df['y'].values\n        y_pred = forecast.iloc[:len(df)]['yhat'].values\n        \n        mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100\n        rmse = np.sqrt(mean_squared_error(y_true, y_pred))\n        r2 = r2_score(y_true, y_pred)\n        \n        # Extraer predicciones futuras\n        future_forecast = forecast.tail(days_ahead)\n        \n        return ForecastResponse(\n            dates=[d.strftime('%Y-%m-%d') for d in future_forecast['ds']],\n            predictions=future_forecast['yhat'].tolist(),\n            lower_bound=future_forecast['yhat_lower'].tolist(),\n            upper_bound=future_forecast['yhat_upper'].tolist(),\n            model_metrics={\n                'mape': round(mape, 2),\n                'rmse': round(rmse, 2),\n                'r2': round(r2, 3),\n                'training_samples': len(df)\n            }\n        )\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generando forecast: {str(e)}\")\n\n@router.get(\"/clustering/customers\")\ndef get_customer_clusters(\n    n_clusters: int = Query(5, ge=3, le=10)\n):\n    \"\"\"\n    Clustering de clientes usando K-Means\n    \"\"\"\n    try:\n        from sklearn.cluster import KMeans\n        from sklearn.preprocessing import StandardScaler\n        \n        engine = get_engine()\n        \n        # Cargar datos de clientes\n        query = \"\"\"\n        SELECT customer_id, recency_score, frequency_score, monetary_score,\n               age, total_orders, avg_order_value\n        FROM customers\n        \"\"\"\n        df = pd.read_sql_query(query, engine)\n        \n        # Preparar features\n        features = df[['recency_score', 'frequency_score', 'monetary_score', \n                       'age', 'total_orders', 'avg_order_value']]\n        \n        # Normalizar\n        scaler = StandardScaler()\n        features_scaled = scaler.fit_transform(features)\n        \n        # K-Means\n        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)\n        df['cluster'] = kmeans.fit_predict(features_scaled)\n        \n        # Características por cluster\n        clusters_info = []\n        cluster_names = ['High Value', 'Loyal', 'At Risk', 'New', 'Lost']\n        \n        for i in range(n_clusters):\n            cluster_data = df[df['cluster'] == i]\n            \n            clusters_info.append({\n                'cluster_id': i,\n                'cluster_name': cluster_names[i] if i < len(cluster_names) else f'Cluster {i}',\n                'size': len(cluster_data),\n                'avg_monetary': round(cluster_data['monetary_score'].mean(), 2),\n                'avg_frequency': round(cluster_data['frequency_score'].mean(), 2),\n                'avg_recency': round(cluster_data['recency_score'].mean(), 2)\n            })\n        \n        return {\n            'n_clusters': n_clusters,\n            'total_customers': len(df),\n            'clusters': clusters_info\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error en clustering: {str(e)}\")\n\n@router.get(\"/churn/at-risk\")\ndef get_at_risk_customers(\n    threshold: float = Query(0.7, ge=0.5, le=0.9),\n    limit: int = Query(100, le=500)\n):\n    \"\"\"\n    Obtiene clientes con alto riesgo de churn - SECURED\n    \"\"\"\n    try:\n        from sqlalchemy import text\n        engine = get_engine()\n        \n        query = text(\"\"\"\n        SELECT customer_id, country, lifetime_value, total_orders,\n               last_purchase_date, churn_probability, rfm_segment\n        FROM customers\n        WHERE churn_probability >= :threshold\n        ORDER BY churn_probability DESC, lifetime_value DESC\n        LIMIT :limit\n        \"\"\")\n        \n        df = pd.read_sql_query(query, engine, params={\"threshold\": threshold, \"limit\": limit})\n        \n        # Determinar nivel de riesgo y acción recomendada\n        results = []\n        for _, row in df.iterrows():\n            risk_level = 'Critical' if row['churn_probability'] > 0.85 else 'High'\n            \n            if row['lifetime_value'] > 1000:\n                action = 'Priority win-back campaign with personalized offer'\n            elif row['total_orders'] > 10:\n                action = 'Re-engagement email with discount'\n            else:\n                action = 'Survey to understand pain points'\n            \n            results.append(ChurnResponse(\n                customer_id=row['customer_id'],\n                churn_probability=round(row['churn_probability'], 3),\n                risk_level=risk_level,\n                recommended_action=action\n            ))\n        \n        return {\n            'threshold': threshold,\n            'total_at_risk': len(results),\n            'customers': [r.dict() for r in results]\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error obteniendo clientes en riesgo: {str(e)}\")\n\n@router.get(\"/recommendations/{product_id}\")\ndef get_product_recommendations(\n    product_id: str,\n    top_n: int = Query(10, ge=5, le=20)\n):\n    \"\"\"\n    Recomendaciones de productos basadas en co-ocurrencia (Market Basket Analysis) - SECURED\n    \"\"\"\n    try:\n        from sqlalchemy import text\n        engine = get_engine()\n        \n        # Obtener transacciones del producto\n        query1 = text(\"\"\"\n        SELECT DISTINCT customer_id\n        FROM transactions\n        WHERE product_id = :product_id\n        \"\"\")\n        customers_df = pd.read_sql_query(query1, engine, params={\"product_id\": product_id})\n        \n        if len(customers_df) == 0:\n            return {'message': 'Producto no encontrado', 'recommendations': []}\n        \n        customer_ids = customers_df['customer_id'].tolist()\n        \n        # Encontrar productos que estos clientes también compraron\n        # Usar array binding para lista de customer_ids\n        query2 = text(\"\"\"\n        SELECT \n            product_id,\n            product_name,\n            category,\n            COUNT(DISTINCT customer_id) as customer_count,\n            SUM(total_amount_usd) as total_revenue\n        FROM transactions\n        WHERE customer_id = ANY(:customer_ids)\n            AND product_id != :product_id\n        GROUP BY product_id, product_name, category\n        ORDER BY customer_count DESC, total_revenue DESC\n        LIMIT :top_n\n        \"\"\")\n        \n        recommendations_df = pd.read_sql_query(query2, engine, params={\n            \"customer_ids\": customer_ids,\n            \"product_id\": product_id,\n            \"top_n\": top_n\n        })\n        \n        # Calcular score de recomendación\n        total_customers = len(customers_df)\n        recommendations = []\n        \n        for _, row in recommendations_df.iterrows():\n            score = (row['customer_count'] / total_customers) * 100\n            \n            recommendations.append(RecommendationResponse(\n                product_id=row['product_id'],\n                product_name=row['product_name'],\n                category=row['category'],\n                score=round(score, 2),\n                reason=f\"{row['customer_count']} clientes que compraron este producto también compraron esto\"\n            ))\n        \n        return {\n            'source_product_id': product_id,\n            'total_customers_analyzed': total_customers,\n            'recommendations': [r.dict() for r in recommendations]\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generando recomendaciones: {str(e)}\")\n\n@router.get(\"/demand-forecast\")\ndef get_demand_forecast(\n    top_n: int = Query(50, le=100)\n):\n    \"\"\"\n    Forecast de demanda por producto con alertas de stock-out - SECURED\n    \"\"\"\n    try:\n        from sqlalchemy import text\n        engine = get_engine()\n        \n        # Obtener ventas históricas por producto\n        query = text(\"\"\"\n        SELECT \n            t.product_id,\n            t.product_name,\n            t.category,\n            p.stock_quantity,\n            COUNT(*) as historical_orders,\n            SUM(t.quantity) as total_units_sold,\n            AVG(t.quantity) as avg_units_per_order\n        FROM transactions t\n        JOIN products p ON t.product_id = p.product_id\n        WHERE t.date >= CURRENT_DATE - INTERVAL '90 days'\n        GROUP BY t.product_id, t.product_name, t.category, p.stock_quantity\n        ORDER BY total_units_sold DESC\n        LIMIT :top_n\n        \"\"\")\n        \n        df = pd.read_sql_query(query, engine, params={\"top_n\": top_n})\n        \n        results = []\n        \n        for _, row in df.iterrows():\n            # Calcular demanda promedio diaria\n            daily_demand = row['total_units_sold'] / 90\n            \n            # Forecast simple (demanda promedio * días)\n            forecast_30d = int(daily_demand * 30 * 1.1)  # +10% buffer\n            forecast_60d = int(daily_demand * 60 * 1.1)\n            forecast_90d = int(daily_demand * 90 * 1.1)\n            \n            # Determinar riesgo de stock-out\n            current_stock = row['stock_quantity']\n            \n            if current_stock < forecast_30d:\n                risk = 'Critical'\n                reorder = forecast_60d - current_stock\n            elif current_stock < forecast_60d:\n                risk = 'High'\n                reorder = forecast_60d - current_stock\n            elif current_stock < forecast_90d:\n                risk = 'Medium'\n                reorder = max(0, forecast_90d - current_stock)\n            else:\n                risk = 'Low'\n                reorder = 0\n            \n            results.append(DemandForecastResponse(\n                product_id=row['product_id'],\n                product_name=row['product_name'],\n                current_stock=int(current_stock),\n                forecasted_demand_30d=forecast_30d,\n                forecasted_demand_60d=forecast_60d,\n                forecasted_demand_90d=forecast_90d,\n                stock_out_risk=risk,\n                recommended_reorder=max(0, reorder)\n            ))\n        \n        return {\n            'total_products_analyzed': len(results),\n            'critical_products': len([r for r in results if r.stock_out_risk == 'Critical']),\n            'products': [r.dict() for r in results]\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error en demand forecast: {str(e)}\")\n\n@router.get(\"/anomalies\")\ndef detect_anomalies(\n    contamination: float = Query(0.05, ge=0.01, le=0.1),\n    days_back: int = Query(90, ge=30, le=365)\n):\n    \"\"\"\n    Detección de anomalías en revenue diario usando Isolation Forest - SECURED\n    \"\"\"\n    try:\n        from sklearn.ensemble import IsolationForest\n        from sqlalchemy import text\n        \n        engine = get_engine()\n        \n        start_date = (datetime.now() - timedelta(days=days_back)).strftime('%Y-%m-%d')\n        \n        query = text(\"\"\"\n        SELECT \n            DATE(date) as day,\n            COUNT(*) as orders,\n            SUM(total_amount_usd) as revenue\n        FROM transactions\n        WHERE date >= :start_date\n        GROUP BY DATE(date)\n        ORDER BY day\n        \"\"\")\n        \n        df = pd.read_sql_query(query, engine, params={\"start_date\": start_date})\n        \n        # Isolation Forest\n        iso_forest = IsolationForest(contamination=contamination, random_state=42)\n        df['anomaly'] = iso_forest.fit_predict(df[['revenue', 'orders']])\n        df['is_anomaly'] = df['anomaly'] == -1\n        \n        # Anomalías detectadas\n        anomalies = df[df['is_anomaly']].copy()\n        \n        # Calcular desviación\n        mean_revenue = df['revenue'].mean()\n        anomalies['deviation_pct'] = ((anomalies['revenue'] - mean_revenue) / mean_revenue * 100).round(2)\n        anomalies['severity'] = anomalies['deviation_pct'].abs().apply(\n            lambda x: 'Critical' if x > 50 else 'High' if x > 25 else 'Medium'\n        )\n        \n        return {\n            'total_days_analyzed': len(df),\n            'anomalies_detected': len(anomalies),\n            'contamination_rate': contamination,\n            'anomalies': anomalies[['day', 'revenue', 'orders', 'deviation_pct', 'severity']].to_dict(orient='records')\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error detectando anomalías: {str(e)}\")\n","size_bytes":14599},"database/__init__.py":{"content":"# Database package\n","size_bytes":19},"replit.md":{"content":"# Global Ecommerce Analytics Platform\n\n## Overview\nThis project delivers a professional Business Intelligence dashboard for global e-commerce analytics. It processes over 770,000 transactions over 16 years, combining real and synthetic data to provide advanced KPIs, multidimensional analysis, and predictive insights. The platform features an interactive Streamlit dashboard, a FastAPI RESTful API with ML endpoints, and robust data management with PostgreSQL and Parquet. Its core purpose is to enable data-driven decision-making for e-commerce businesses through comprehensive analytics, forecasting, customer segmentation, and product performance evaluation. The platform is designed for scalability and production readiness, aiming to unlock significant market potential by providing deep insights into sales, customer behavior, and operational efficiency. The entire platform is internationalized for Spanish-speaking users, including all UI elements, data translations, and insights.\n\n## User Preferences\nI prefer detailed explanations. Do not make changes to the folder Z. Do not make changes to the file Y.\n\n## System Architecture\nThe system employs a multi-tiered architecture focusing on modularity and scalability.\n\n**UI/UX Decisions:**\nThe dashboard is built with Streamlit and features a professional, responsive design with automatic dark/light mode detection. It utilizes a corporate color palette and presents all content in professional Spanish, including contextual descriptions, KPI explanations, and actionable recommendations. Key elements include interactive visualizations with Plotly, professional tab navigation, and executive insights generation based on real-time data.\n\n**Technical Implementations & Feature Specifications:**\n\n*   **Interactive Dashboard (Streamlit):** Features 9 functional navigation tabs for comprehensive analysis: General Summary, Geography, Performance & Temporal Analysis, Products, Customers, Channel, ML & AI, Finance, and Operations. Includes 8 core KPIs, geo-spatial analysis with Folium, statistical performance analysis with moving averages and growth indicators, BCG matrix for product analysis, RFM customer segmentation with K-Means clustering, Sankey diagrams, Isolation Forest for anomaly detection, and waterfall charts for financial P&L. All data, filters, labels, and insights are fully translated into Spanish.\n*   **API RESTful (FastAPI):** Provides data and machine learning endpoints for KPIs, transactions, customers, products, aggregated analytics, forecasting, clustering, churn prediction, product recommendations, and anomaly detection. Includes endpoints for generating comprehensive Excel and PDF reports.\n*   **Database Design (Unified Parquet + PostgreSQL):** Primary data source is optimized Parquet files (774,434 transactions from 2010-2025), supplemented by PostgreSQL for development and backup. Data includes 541,909 real and 232,525 synthetically generated transactions, ensuring continuous time series and realistic distributions. Optimized indexing supports rapid query performance.\n*   **Internationalization System:** Comprehensive translation architecture ensures a 100% Spanish interface across all UI elements, data, charts, tooltips, and insights, applied automatically at data load time.\n*   **Advanced Filtering System:** Dynamic, collapsible sidebar filters allow data segmentation by date, geography, product, customer segment, payment method, device type, traffic source, and price range, all with Spanish placeholders.\n\n**System Design Choices:**\nThe project emphasizes modularity and scalability using Streamlit for rapid dashboard development and FastAPI for a high-performance, well-documented API. PostgreSQL provides robustness, with Parquet files optimizing large dataset processing. Machine learning models are integrated as API endpoints for easy consumption. Security is managed through environment variables, CORS configuration, parameterized queries, and input validation.\n\n## Recent Changes\n\n**Dashboard v4.0 - Prophet Removal & Performance Analytics (October 26, 2025):**\n\n- ✅ **Prophet Forecasting Replaced with Statistical Performance Analysis:**\n  - **DECISION:** Eliminated Prophet (Meta's forecasting library) due to persistent Timestamp errors across granularities\n  - **ROOT CAUSE:** Prophet incompatible with Pandas' deprecated Timestamp arithmetic, causing \"Addition/subtraction of integers with Timestamp not supported\" errors\n  - **SOLUTION:** Replaced with robust statistical analysis approach using standard pandas/numpy operations\n  \n- ✅ **New \"Rendimiento & Análisis Temporal\" Tab:**\n  - **Renamed from:** \"Forecasting & Tendencias\" → \"Rendimiento & Análisis Temporal\"\n  - **Updated description:** Removed all references to prediction/forecasting, focused on historical performance analysis\n  - **Maintained visualizations:** Evolution chart, weekday distribution, hourly distribution (all working perfectly)\n  \n- ✅ **New Performance Analysis Features:**\n  - **Growth Indicators:** Period-over-period comparison, daily growth rate, momentum detection (accelerated/decelerated/stable)\n  - **Moving Average Analysis:** Configurable windows (7/30 days, 4/12 weeks, 3/6 months) with trend detection\n  - **Automatic Insights:** Smart trend analysis comparing short-term vs long-term averages\n  - **Professional KPIs:** Revenue variation, order growth, daily growth rate, momentum status\n  \n- ✅ **Technical Quality:**\n  - Zero dependency on Prophet - eliminates entire class of Timestamp errors\n  - Faster execution - no ML training required\n  - More robust - pure pandas/numpy operations\n  - Equally valuable - executive-focused growth metrics\n  \n- ✅ **ML Capabilities Retained:**\n  - Isolation Forest (anomaly detection) - functional ✅\n  - K-Means clustering (customer segmentation) - functional ✅\n  - Correlation analysis - functional ✅\n  - Product recommendations - functional ✅\n  - Dashboard still ML-powered with 4 robust models\n\n- ✅ **Production Status:**\n  - Dashboard 100% stable without Prophet\n  - All 9 tabs functional\n  - Zero Timestamp errors\n  - Client-ready for international delivery\n\n## External Dependencies\n*   **Streamlit:** Interactive dashboard development.\n*   **FastAPI:** RESTful API.\n*   **PostgreSQL:** Relational database.\n*   **Plotly:** Interactive data visualizations.\n*   **Folium:** Geo-spatial visualization.\n*   **SQLAlchemy:** ORM for database interactions.\n*   **Scikit-learn:** Machine learning algorithms (K-Means, Isolation Forest).\n*   **XGBoost:** Advanced predictive modeling.\n*   **ReportLab:** PDF report generation.\n*   **OpenPyXL:** Excel file export.\n*   **Pandas & NumPy:** Data manipulation and numerical operations.\n\n**Note:** Prophet (Meta) was removed in v4.0 due to compatibility issues. Replaced with statistical performance analysis.","size_bytes":6837},"README.md":{"content":"# 📊 Analytics Ecommerce Global - Business Intelligence Dashboard\n\n**Desarrollado por:** CMSR92  \n**Versión:** 3.1  \n**Última actualización:** Octubre 26, 2025\n\n---\n\n## 🎯 Descripción del Proyecto\n\nPlataforma profesional de **Business Intelligence** de nivel enterprise que combina **Big Data**, **Machine Learning** e **Inteligencia Artificial** para análisis predictivo avanzado de ecommerce global. \n\nEste dashboard analiza **472,211 transacciones** que abarcan **16 años** (2010-2025), con distribución global realista y datos completamente internacionalizados en español profesional.\n\n### 🌟 Características Destacadas\n\n- ✅ **Interfaz 100% en Español**: Todas las etiquetas, filtros, insights y traducciones\n- ✅ **Datos Globales Realistas**: Estados Unidos (19.13%), Reino Unido (24%), distribución balanceada\n- ✅ **472K+ Transacciones**: Datos reales UK + sintéticos con distribuciones realistas\n- ✅ **9 Pestañas de Análisis**: Desde resumen ejecutivo hasta ML avanzado\n- ✅ **Machine Learning Integrado**: Prophet, K-Means, Isolation Forest, XGBoost\n- ✅ **Visualizaciones Profesionales**: Sin etiquetas técnicas, listas para presentación\n- ✅ **API RESTful Completa**: FastAPI con documentación Swagger\n- ✅ **Firma Digital**: Desarrollado por CMSR92\n\n---\n\n## 🏗️ Stack Tecnológico\n\n### Frontend\n- **Streamlit** - Dashboard interactivo responsive\n- **Plotly** - Visualizaciones interactivas profesionales\n- **Folium** - Mapas geoespaciales con ISO-3\n\n### Backend\n- **FastAPI** - API RESTful de alto rendimiento\n- **PostgreSQL** - Base de datos relacional (opcional)\n- **Parquet** - Almacenamiento optimizado de datos\n\n### Machine Learning & AI\n- **Prophet (Meta)** - Forecasting con estacionalidad multiplicativa\n- **Scikit-learn** - Clustering RFM, detección de anomalías\n- **XGBoost** - Modelos predictivos avanzados\n\n### Exportación\n- **ReportLab** - Reportes PDF profesionales\n- **OpenPyXL** - Exportación Excel (8 hojas)\n\n---\n\n## 📊 Dataset\n\n### Composición de Datos\n\n**472,211 transacciones** (2010-2025):\n- 53,036 transacciones reales (UK Online Retail Dataset)\n- 419,175 transacciones sintéticas con distribuciones realistas\n\n**Distribución Global Realista:**\n- 🇺🇸 Estados Unidos: 19.13%\n- 🇬🇧 Reino Unido: 24.00%\n- 🇩🇪 Alemania: 9.81%\n- 🇫🇷 Francia: 7.30%\n- 🇨🇳 China: 7.13%\n- 40+ países más\n\n**Categorías Balanceadas:**\n- 🏠 Hogar: 34.13%\n- 📱 Electrónica: 14.25%\n- 👗 Moda: 14.89%\n- 🛒 Comestibles: 11.09%\n- 📚 Libros: 8.72%\n- 🧸 Juguetes: 7.02%\n\n**Métricas del Cliente:**\n- 4,338 clientes únicos\n- Segmentación RFM (9 segmentos)\n- Churn probability (media: 18.4%)\n- Lifetime Value calculado\n\n---\n\n## 🎨 Características del Dashboard\n\n### 1. Navegación por Pestañas (9 Secciones)\n\n| Pestaña | Contenido |\n|---------|-----------|\n| 📊 **Resumen General** | 8 KPIs core, evolución temporal, insights ejecutivos |\n| 🌍 **Análisis Geográfico** | Mapa mundial ISO-3, treemap País→Categoría |\n| 📈 **Forecasting & Tendencias** | Prophet 90 días, análisis de tendencias |\n| 📦 **Análisis de Productos** | BCG Matrix, top productos, rendimiento |\n| 👥 **Segmentación de Clientes** | RFM, clustering K-Means, análisis de cohortes |\n| 📱 **Optimización de Canales** | Dispositivos, tráfico, Sankey profesional |\n| 🤖 **ML & IA Insights** | Anomalías, clustering 3D, recomendaciones |\n| 💰 **Análisis Financiero** | P&L, waterfall, métricas financieras |\n| ⚙️ **Análisis Operacional** | KPIs operativos, eficiencia |\n\n### 2. Sistema de Filtros Dinámicos\n\n**Filtros Colapsables en Sidebar:**\n- 📅 Rango de fechas personalizado\n- 🌍 Geografía (países, regiones, ciudades)\n- 📦 Productos (categorías traducidas)\n- 👥 Segmentos de clientes\n- 💳 Canales y métodos de pago\n- 📱 Tipos de dispositivo\n- 💰 Rango de precios\n- 🤖 Activación de predicciones ML\n\n### 3. Visualizaciones Profesionales\n\n**Correcciones v3.1 para Cliente/Directivos:**\n- ✅ Mapa mundial con códigos ISO-3 (renderizado correcto)\n- ✅ Treemap simplificado (País → Categoría, sin city)\n- ✅ Gráfico evolución con eje secundario (sin pico anormal)\n- ✅ Prophet con estacionalidad multiplicativa (precisión mejorada)\n- ✅ Churn con distribución variada (41% muy bajo, 32% bajo)\n- ✅ Etiquetas de dispositivos limpias (sin \"device=\")\n- ✅ Sankey con colores diferenciados (sin \"source\"/\"target\")\n- ✅ Firma CMSR92 visible y profesional\n\n### 4. Machine Learning Integrado\n\n**Modelos Implementados:**\n- **Prophet Forecasting**: 90 días con intervalo confianza 80%/95%\n- **K-Means Clustering**: 4 segmentos RFM (Champions, Loyal, At Risk, Lost)\n- **Isolation Forest**: Detección de anomalías en transacciones\n- **XGBoost**: Predicción de churn y recomendaciones\n- **Market Basket**: Análisis de productos relacionados\n\n**Métricas de Evaluación:**\n- MAPE, RMSE, R² para forecasting\n- Silhouette Score para clustering\n- Precision/Recall para clasificación\n\n### 5. Internacionalización Completa\n\n**Sistema de Traducciones Automáticas:**\n- Categorías: Home→Hogar, Electronics→Electrónica\n- Países: EIRE→Irlanda, United Kingdom→Reino Unido\n- Tráfico: Organic→Orgánico, Paid Ads→Anuncios Pagados\n- Dispositivos: Mobile→Móvil, Desktop→Escritorio\n- Segmentos: New→Nuevo, VIP→VIP, Regular→Regular\n- Métodos de pago traducidos\n- Días de semana en español\n\n---\n\n## 🚀 Instalación y Ejecución\n\n### Requisitos Previos\n\n```bash\nPython 3.11+\n```\n\n### Instalación\n\n```bash\n# Clonar el repositorio\ngit clone <tu-repositorio>\ncd analytics-ecommerce-global\n\n# Instalar dependencias\npip install -r requirements.txt\n```\n\n### Ejecución Local\n\n```bash\n# Dashboard Streamlit\nstreamlit run app.py\n\n# Acceder a: http://localhost:8501\n```\n\n### Deploy en Streamlit Cloud\n\n1. Sube el proyecto a GitHub\n2. Conecta tu repositorio en [share.streamlit.io](https://share.streamlit.io)\n3. Selecciona `app.py` como archivo principal\n4. ¡Listo! Tu dashboard estará en línea\n\n---\n\n## 📁 Estructura del Proyecto\n\n```\nanalytics-ecommerce-global/\n├── app.py                          # ⭐ Dashboard principal\n├── requirements.txt                # Dependencias Python\n├── .gitignore                      # Archivos ignorados\n├── README.md                       # Esta documentación\n├── replit.md                       # Memoria técnica del proyecto\n│\n├── api/                            # API RESTful\n│   ├── __init__.py\n│   ├── main.py                     # Endpoints principales\n│   └── ml_endpoints.py             # Endpoints ML/IA\n│\n├── data/                           # Datasets optimizados (Parquet)\n│   ├── transactions_unified.parquet # 472K transacciones\n│   ├── customers_unified.parquet    # 4.3K clientes\n│   └── products_unified.parquet     # 29K productos\n│\n├── database/                       # Base de datos (opcional)\n│   ├── __init__.py\n│   ├── schema.py                   # Modelos SQLAlchemy\n│   └── migration_unified.py        # Migraciones\n│\n└── utils/                          # Utilidades\n    ├── data_loader_pg.py           # Cargador con traducciones\n    ├── traducciones.py             # Sistema i18n (ES)\n    ├── ui_components.py            # Componentes UI (KPIs, firma)\n    ├── filtros.py                  # Sistema de filtros\n    ├── export_utils.py             # Exportación Excel/PDF\n    ├── visualizaciones_avanzadas.py # Gráficos especializados\n    ├── data_generator.py           # Generador sintético\n    └── unified_data_integration.py # Integración de datos\n```\n\n---\n\n## 📊 API Endpoints\n\n### Datos Básicos\n```\nGET /api/kpis                      # KPIs principales\nGET /api/transactions              # Transacciones\nGET /api/customers                 # Clientes\nGET /api/products                  # Productos\n```\n\n### Analytics Agregados\n```\nGET /api/aggregated/by_country     # Agregación por país\nGET /api/aggregated/by_category    # Agregación por categoría\nGET /api/aggregated/time_series    # Series temporales\n```\n\n### Machine Learning\n```\nPOST /api/ml/forecast              # Forecasting Prophet\nPOST /api/ml/cluster_customers     # Clustering K-Means\nGET  /api/ml/churn_risk           # Predicción de churn\nGET  /api/ml/recommendations      # Recomendaciones\nPOST /api/ml/anomaly_detection    # Detección de anomalías\n```\n\n### Exportación\n```\nGET /api/export/excel             # Reporte Excel (8 hojas)\nGET /api/export/pdf               # Reporte PDF profesional\n```\n\n**Documentación interactiva:** `http://localhost:8000/docs`\n\n---\n\n## 🎯 Casos de Uso\n\n1. **Análisis Ejecutivo**: KPIs, tendencias, insights accionables\n2. **Segmentación de Clientes**: RFM, clustering, predicción de churn\n3. **Forecasting de Ventas**: Predicciones Prophet a 90 días\n4. **Análisis Geográfico**: Rendimiento por país y región\n5. **Optimización de Marketing**: Canales, dispositivos, conversión\n6. **Análisis Financiero**: P&L, márgenes, ROI\n7. **Detección de Anomalías**: Transacciones sospechosas\n8. **Análisis de Productos**: BCG Matrix, top performers\n\n---\n\n## 📈 Versiones\n\n### v3.1 - Correcciones Finales para Cliente (Oct 26, 2025)\n- ✅ Mapa mundial corregido (ISO-3 codes)\n- ✅ Treemap simplificado (sin city)\n- ✅ Gráfico evolución optimizado (eje secundario)\n- ✅ Prophet mejorado (estacionalidad multiplicativa)\n- ✅ Churn variado (distribución realista)\n- ✅ Etiquetas limpias (sin prefijos técnicos)\n- ✅ Sankey profesional (colores + sin labels técnicos)\n- ✅ Firma CMSR92 implementada\n\n### v3.0 - Regeneración de Datos Globales (Oct 26, 2025)\n- 472K transacciones con distribuciones globales realistas\n- Estados Unidos como mercado principal (19.13%)\n- Electrónica como categoría mayor (14.25%)\n- Sistema de traducción extendido\n- RFM y churn mejorados\n\n---\n\n## 🔒 Seguridad\n\n- ✅ Variables de entorno para credenciales\n- ✅ Consultas parametrizadas (anti SQL injection)\n- ✅ Validación de inputs en API\n- ✅ CORS configurado\n- ✅ Gestión segura de secretos\n\n---\n\n## 👨‍💻 Autor\n\n**CMSR92**  \n*Data Scientist | ML Engineer | BI Specialist*\n\n---\n\n## 📄 Licencia\n\nProyecto de código abierto bajo licencia MIT.\n\n---\n\n## 🙏 Agradecimientos\n\n- UCI Machine Learning Repository (Online Retail Dataset)\n- Prophet by Meta (forecasting framework)\n- Plotly (interactive visualizations)\n- Streamlit (dashboard framework)\n- Comunidad open source\n\n---\n\n**✨ Desarrollado por CMSR92 ✨**\n\n*Dashboard profesional de Business Intelligence para ecommerce global*\n","size_bytes":10701},"api/main.py":{"content":"from fastapi import FastAPI, HTTPException, Query\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nimport pandas as pd\nfrom database.schema import get_engine\nfrom pydantic import BaseModel\nfrom sqlalchemy import text\nfrom api.ml_endpoints import router as ml_router\n\napp = FastAPI(\n    title=\"Global Ecommerce Analytics API\",\n    description=\"API REST para análisis de ecommerce con Machine Learning\",\n    version=\"1.0.0\",\n    docs_url=\"/docs\",\n    redoc_url=\"/redoc\"\n)\n\n# CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include ML router\napp.include_router(ml_router)\n\n# Models\nclass KPIResponse(BaseModel):\n    total_revenue: float\n    total_orders: int\n    avg_order_value: float\n    gross_profit: float\n    total_customers: int\n    conversion_rate: float\n    period_start: str\n    period_end: str\n\nclass TransactionResponse(BaseModel):\n    transaction_id: str\n    date: datetime\n    customer_id: str\n    country: str\n    product_name: str\n    category: str\n    total_amount_usd: float\n    payment_method: str\n\nclass CustomerResponse(BaseModel):\n    customer_id: str\n    country: str\n    lifetime_value: float\n    total_orders: int\n    rfm_segment: str\n    churn_probability: float\n\nclass ProductResponse(BaseModel):\n    product_id: str\n    product_name: str\n    category: str\n    base_price: float\n    margin_percentage: float\n    rating: float\n\n# Helper function\ndef get_db_engine():\n    return get_engine()\n\n@app.get(\"/\")\ndef read_root():\n    return {\n        \"message\": \"Global Ecommerce Analytics API\",\n        \"version\": \"1.0.0\",\n        \"endpoints\": {\n            \"kpis\": \"/api/kpis\",\n            \"transactions\": \"/api/transactions\",\n            \"customers\": \"/api/customers\",\n            \"products\": \"/api/products\",\n            \"countries\": \"/api/analytics/countries\",\n            \"categories\": \"/api/analytics/categories\"\n        }\n    }\n\n@app.get(\"/api/kpis\", response_model=KPIResponse)\ndef get_kpis(\n    start_date: Optional[str] = Query(None, description=\"Start date (YYYY-MM-DD)\"),\n    end_date: Optional[str] = Query(None, description=\"End date (YYYY-MM-DD)\"),\n    country: Optional[str] = Query(None, description=\"Filter by country\"),\n    category: Optional[str] = Query(None, description=\"Filter by category\")\n):\n    \"\"\"\n    Obtiene KPIs principales del ecommerce - SECURED with parameterized queries\n    \"\"\"\n    engine = get_db_engine()\n    \n    # Fechas por defecto\n    if not end_date:\n        end_date = datetime.now().strftime('%Y-%m-%d')\n    if not start_date:\n        start_date = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')\n    \n    # Query base con parámetros\n    query = text(\"\"\"\n    SELECT \n        COUNT(*) as total_orders,\n        SUM(total_amount_usd) as total_revenue,\n        AVG(total_amount_usd) as avg_order_value,\n        SUM(profit) as gross_profit,\n        COUNT(DISTINCT customer_id) as total_customers\n    FROM transactions\n    WHERE date >= :start_date AND date <= :end_date\n    \"\"\" + (\" AND country = :country\" if country else \"\") +\n          (\" AND category = :category\" if category else \"\"))\n    \n    params = {\"start_date\": start_date, \"end_date\": end_date}\n    if country:\n        params[\"country\"] = country\n    if category:\n        params[\"category\"] = category\n    \n    try:\n        with engine.connect() as conn:\n            result = conn.execute(query, params)\n            row = result.fetchone()\n            \n            if row is None:\n                raise HTTPException(status_code=404, detail=\"No data found\")\n            \n            total_customers = float(row[4]) if row[4] else 1\n            total_orders = float(row[0]) if row[0] else 0\n            \n            return KPIResponse(\n                total_revenue=float(row[1] or 0),\n                total_orders=int(row[0] or 0),\n                avg_order_value=float(row[2] or 0),\n                gross_profit=float(row[3] or 0),\n                total_customers=int(total_customers),\n                conversion_rate=round((total_orders / total_customers) * 100, 2) if total_customers > 0 else 0,\n                period_start=start_date,\n                period_end=end_date\n            )\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/transactions\")\ndef get_transactions(\n    limit: int = Query(100, le=1000),\n    offset: int = Query(0),\n    country: Optional[str] = None,\n    category: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    Obtiene transacciones con paginación y filtros - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    # Construir query con condiciones dinámicas pero parámetros seguros\n    where_clauses = []\n    params = {}\n    \n    if start_date:\n        where_clauses.append(\"date >= :start_date\")\n        params[\"start_date\"] = start_date\n    if end_date:\n        where_clauses.append(\"date <= :end_date\")\n        params[\"end_date\"] = end_date\n    if country:\n        where_clauses.append(\"country = :country\")\n        params[\"country\"] = country\n    if category:\n        where_clauses.append(\"category = :category\")\n        params[\"category\"] = category\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT * FROM transactions\n    {where_sql}\n    ORDER BY date DESC\n    LIMIT :limit OFFSET :offset\n    \"\"\")\n    \n    params[\"limit\"] = limit\n    params[\"offset\"] = offset\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params)\n        return {\n            \"total\": len(df),\n            \"limit\": limit,\n            \"offset\": offset,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/customers\")\ndef get_customers(\n    limit: int = Query(100, le=1000),\n    offset: int = Query(0),\n    country: Optional[str] = None,\n    rfm_segment: Optional[str] = None,\n    min_ltv: Optional[float] = None\n):\n    \"\"\"\n    Obtiene clientes con filtros - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    where_clauses = []\n    params = {}\n    \n    if country:\n        where_clauses.append(\"country = :country\")\n        params[\"country\"] = country\n    if rfm_segment:\n        where_clauses.append(\"rfm_segment = :rfm_segment\")\n        params[\"rfm_segment\"] = rfm_segment\n    if min_ltv is not None:\n        where_clauses.append(\"lifetime_value >= :min_ltv\")\n        params[\"min_ltv\"] = min_ltv\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT * FROM customers\n    {where_sql}\n    ORDER BY lifetime_value DESC\n    LIMIT :limit OFFSET :offset\n    \"\"\")\n    \n    params[\"limit\"] = limit\n    params[\"offset\"] = offset\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params)\n        return {\n            \"total\": len(df),\n            \"limit\": limit,\n            \"offset\": offset,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/products\")\ndef get_products(\n    limit: int = Query(100, le=500),\n    offset: int = Query(0),\n    category: Optional[str] = None,\n    min_rating: Optional[float] = None\n):\n    \"\"\"\n    Obtiene productos con filtros - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    where_clauses = []\n    params = {}\n    \n    if category:\n        where_clauses.append(\"category = :category\")\n        params[\"category\"] = category\n    if min_rating is not None:\n        where_clauses.append(\"rating >= :min_rating\")\n        params[\"min_rating\"] = min_rating\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT * FROM products\n    {where_sql}\n    ORDER BY rating DESC\n    LIMIT :limit OFFSET :offset\n    \"\"\")\n    \n    params[\"limit\"] = limit\n    params[\"offset\"] = offset\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params)\n        return {\n            \"total\": len(df),\n            \"limit\": limit,\n            \"offset\": offset,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/analytics/countries\")\ndef get_country_analytics(\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    Análisis de revenue por país - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    where_clauses = []\n    params = {}\n    \n    if start_date:\n        where_clauses.append(\"date >= :start_date\")\n        params[\"start_date\"] = start_date\n    if end_date:\n        where_clauses.append(\"date <= :end_date\")\n        params[\"end_date\"] = end_date\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT \n        country,\n        COUNT(*) as orders,\n        SUM(total_amount_usd) as revenue,\n        AVG(total_amount_usd) as aov,\n        COUNT(DISTINCT customer_id) as customers\n    FROM transactions\n    {where_sql}\n    GROUP BY country\n    ORDER BY revenue DESC\n    \"\"\")\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params if params else None)\n        return {\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/analytics/categories\")\ndef get_category_analytics(\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    Análisis de revenue por categoría - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    where_clauses = []\n    params = {}\n    \n    if start_date:\n        where_clauses.append(\"date >= :start_date\")\n        params[\"start_date\"] = start_date\n    if end_date:\n        where_clauses.append(\"date <= :end_date\")\n        params[\"end_date\"] = end_date\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT \n        category,\n        COUNT(*) as orders,\n        SUM(total_amount_usd) as revenue,\n        SUM(profit) as profit,\n        AVG((profit / NULLIF(total_amount_usd, 0)) * 100) as avg_margin\n    FROM transactions\n    {where_sql}\n    GROUP BY category\n    ORDER BY revenue DESC\n    \"\"\")\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params if params else None)\n        return {\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/analytics/time-series\")\ndef get_time_series(\n    granularity: str = Query(\"day\", description=\"day, week, or month\"),\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    Serie temporal de revenue y orders - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    # Validar granularity (whitelist approach)\n    granularity_map = {\n        'day': \"DATE(date)\",\n        'week': \"DATE_TRUNC('week', date)\",\n        'month': \"DATE_TRUNC('month', date)\"\n    }\n    \n    if granularity not in granularity_map:\n        raise HTTPException(status_code=400, detail=\"Invalid granularity. Use: day, week, or month\")\n    \n    date_format = granularity_map[granularity]\n    \n    where_clauses = []\n    params = {}\n    \n    if start_date:\n        where_clauses.append(\"date >= :start_date\")\n        params[\"start_date\"] = start_date\n    if end_date:\n        where_clauses.append(\"date <= :end_date\")\n        params[\"end_date\"] = end_date\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT \n        {date_format} as period,\n        COUNT(*) as orders,\n        SUM(total_amount_usd) as revenue,\n        SUM(profit) as profit\n    FROM transactions\n    {where_sql}\n    GROUP BY {date_format}\n    ORDER BY period\n    \"\"\")\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params if params else None)\n        df['period'] = df['period'].astype(str)\n        return {\n            \"granularity\": granularity,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/analytics/top-products\")\ndef get_top_products(\n    limit: int = Query(20, le=100),\n    metric: str = Query(\"revenue\", description=\"revenue, orders, or margin\")\n):\n    \"\"\"\n    Top productos por métrica seleccionada - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    # Whitelist approach para métrica\n    metric_map = {\n        'revenue': 'SUM(total_amount_usd)',\n        'orders': 'COUNT(*)',\n        'margin': 'AVG(profit / NULLIF(total_amount_usd, 0) * 100)'\n    }\n    \n    if metric not in metric_map:\n        raise HTTPException(status_code=400, detail=\"Invalid metric. Use: revenue, orders, or margin\")\n    \n    metric_sql = metric_map[metric]\n    \n    query = text(f\"\"\"\n    SELECT \n        product_id,\n        product_name,\n        category,\n        COUNT(*) as orders,\n        SUM(total_amount_usd) as revenue,\n        SUM(profit) as profit,\n        SUM(quantity) as units_sold\n    FROM transactions\n    GROUP BY product_id, product_name, category\n    ORDER BY {metric_sql} DESC\n    LIMIT :limit\n    \"\"\")\n    \n    try:\n        df = pd.read_sql_query(query, engine, params={\"limit\": limit})\n        return {\n            \"metric\": metric,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/health\")\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return {\"status\": \"healthy\", \"timestamp\": datetime.now().isoformat()}\n\n@app.get(\"/api/export/excel\")\ndef export_excel(\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    country: Optional[str] = None,\n    category: Optional[str] = None\n):\n    \"\"\"\n    Exporta datos a Excel con análisis completo - SECURED\n    \"\"\"\n    from fastapi.responses import StreamingResponse\n    from utils.export_utils import create_excel_report\n    \n    try:\n        engine = get_db_engine()\n        \n        # Construir query con parámetros seguros\n        where_clauses = []\n        params = {}\n        \n        if start_date:\n            where_clauses.append(\"date >= :start_date\")\n            params[\"start_date\"] = start_date\n        if end_date:\n            where_clauses.append(\"date <= :end_date\")\n            params[\"end_date\"] = end_date\n        if country:\n            where_clauses.append(\"country = :country\")\n            params[\"country\"] = country\n        if category:\n            where_clauses.append(\"category = :category\")\n            params[\"category\"] = category\n        \n        where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n        \n        transactions_query = text(f\"SELECT * FROM transactions {where_sql}\")\n        \n        transactions_df = pd.read_sql_query(transactions_query, engine, params=params if params else None)\n        customers_df = pd.read_sql_table('customers', engine)\n        products_df = pd.read_sql_table('products', engine)\n        \n        # Generar Excel\n        excel_buffer = create_excel_report(transactions_df, customers_df, products_df, {})\n        \n        return StreamingResponse(\n            excel_buffer,\n            media_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            headers={\n                'Content-Disposition': f'attachment; filename=ecommerce_report_{datetime.now().strftime(\"%Y%m%d\")}.xlsx'\n            }\n        )\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generando Excel: {str(e)}\")\n\n@app.get(\"/api/export/pdf\")\ndef export_pdf(\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    country: Optional[str] = None,\n    category: Optional[str] = None\n):\n    \"\"\"\n    Exporta reporte en PDF profesional - SECURED\n    \"\"\"\n    from fastapi.responses import StreamingResponse\n    from utils.export_utils import create_pdf_report\n    \n    try:\n        engine = get_db_engine()\n        \n        # Construir query con parámetros seguros\n        where_clauses = []\n        params = {}\n        \n        if start_date:\n            where_clauses.append(\"date >= :start_date\")\n            params[\"start_date\"] = start_date\n        if end_date:\n            where_clauses.append(\"date <= :end_date\")\n            params[\"end_date\"] = end_date\n        if country:\n            where_clauses.append(\"country = :country\")\n            params[\"country\"] = country\n        if category:\n            where_clauses.append(\"category = :category\")\n            params[\"category\"] = category\n        \n        where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n        \n        transactions_query = text(f\"SELECT * FROM transactions {where_sql}\")\n        \n        transactions_df = pd.read_sql_query(transactions_query, engine, params=params if params else None)\n        customers_df = pd.read_sql_table('customers', engine)\n        products_df = pd.read_sql_table('products', engine)\n        \n        # Generar PDF\n        pdf_buffer = create_pdf_report(transactions_df, customers_df, products_df, {})\n        \n        return StreamingResponse(\n            pdf_buffer,\n            media_type='application/pdf',\n            headers={\n                'Content-Disposition': f'attachment; filename=ecommerce_report_{datetime.now().strftime(\"%Y%m%d\")}.pdf'\n            }\n        )\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generando PDF: {str(e)}\")\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n","size_bytes":17914},"database/schema.py":{"content":"from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Date, Boolean, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nimport os\n\nBase = declarative_base()\n\nclass Transaction(Base):\n    __tablename__ = 'transactions'\n    \n    id = Column(Integer, primary_key=True, autoincrement=True)\n    transaction_id = Column(String(50), unique=True, nullable=False, index=True)\n    date = Column(DateTime, nullable=False, index=True)\n    customer_id = Column(String(50), nullable=False, index=True)\n    country = Column(String(100), nullable=False, index=True)\n    region = Column(String(100))\n    city = Column(String(100))\n    product_id = Column(String(50), nullable=False, index=True)\n    product_name = Column(String(500))\n    category = Column(String(100), index=True)\n    subcategory = Column(String(100))\n    quantity = Column(Integer)\n    unit_price = Column(Float)\n    total_amount = Column(Float)\n    discount_applied = Column(Float)\n    payment_method = Column(String(50), index=True)\n    shipping_cost = Column(Float)\n    delivery_time = Column(Integer)\n    customer_segment = Column(String(50), index=True)\n    device_type = Column(String(50), index=True)\n    traffic_source = Column(String(50), index=True)\n    currency = Column(String(10))\n    exchange_rate = Column(Float)\n    total_amount_usd = Column(Float, index=True)\n    cost_price = Column(Float)\n    profit = Column(Float)\n\nclass Customer(Base):\n    __tablename__ = 'customers'\n    \n    id = Column(Integer, primary_key=True, autoincrement=True)\n    customer_id = Column(String(50), unique=True, nullable=False, index=True)\n    registration_date = Column(Date, nullable=False)\n    country = Column(String(100), index=True)\n    age = Column(Integer)\n    gender = Column(String(20))\n    lifetime_value = Column(Float, index=True)\n    total_orders = Column(Integer)\n    avg_order_value = Column(Float)\n    last_purchase_date = Column(DateTime)\n    recency_score = Column(Integer)\n    frequency_score = Column(Integer)\n    monetary_score = Column(Float)\n    rfm_segment = Column(String(50), index=True)\n    churn_probability = Column(Float)\n    preferred_category = Column(String(100))\n\nclass Product(Base):\n    __tablename__ = 'products'\n    \n    id = Column(Integer, primary_key=True, autoincrement=True)\n    product_id = Column(String(50), unique=True, nullable=False, index=True)\n    product_name = Column(String(500), nullable=False)\n    category = Column(String(100), nullable=False, index=True)\n    subcategory = Column(String(100))\n    brand = Column(String(100))\n    base_price = Column(Float)\n    cost_price = Column(Float)\n    margin_percentage = Column(Float)\n    stock_quantity = Column(Integer)\n    supplier_country = Column(String(100))\n    weight = Column(Float)\n    rating = Column(Float)\n    reviews_count = Column(Integer)\n    launch_date = Column(Date)\n\n# Database connection\ndef get_database_url():\n    return os.getenv('DATABASE_URL', 'postgresql://localhost/ecommerce_db')\n\ndef get_engine():\n    return create_engine(get_database_url())\n\ndef get_session():\n    engine = get_engine()\n    Session = sessionmaker(bind=engine)\n    return Session()\n\ndef create_tables():\n    engine = get_engine()\n    Base.metadata.create_all(engine)\n    print(\"✅ Tablas creadas exitosamente\")\n\ndef drop_tables():\n    engine = get_engine()\n    Base.metadata.drop_all(engine)\n    print(\"🗑️ Tablas eliminadas\")\n","size_bytes":3452},"utils/data_loader.py":{"content":"import pandas as pd\nimport streamlit as st\nimport os\nfrom datetime import datetime, timedelta\n\n@st.cache_data\ndef load_or_generate_data():\n    \"\"\"Carga o genera datos si no existen\"\"\"\n    from utils.data_generator import generate_all_data\n    \n    data_dir = 'data'\n    os.makedirs(data_dir, exist_ok=True)\n    \n    transactions_path = os.path.join(data_dir, 'transactions.parquet')\n    customers_path = os.path.join(data_dir, 'customers.parquet')\n    products_path = os.path.join(data_dir, 'products.parquet')\n    \n    # Verificar si los datos ya existen\n    if os.path.exists(transactions_path) and os.path.exists(customers_path) and os.path.exists(products_path):\n        transactions_df = pd.read_parquet(transactions_path)\n        customers_df = pd.read_parquet(customers_path)\n        products_df = pd.read_parquet(products_path)\n    else:\n        # Generar datos\n        with st.spinner('Generando datos simulados (100K transacciones, 50K clientes, 500 productos)... Esto puede tardar un momento...'):\n            transactions_df, customers_df, products_df = generate_all_data(\n                n_transactions=100000,\n                n_customers=50000,\n                n_products=500\n            )\n            \n            # Guardar para uso futuro\n            transactions_df.to_parquet(transactions_path)\n            customers_df.to_parquet(customers_path)\n            products_df.to_parquet(products_path)\n    \n    # Convertir fecha a datetime\n    transactions_df['date'] = pd.to_datetime(transactions_df['date'])\n    customers_df['registration_date'] = pd.to_datetime(customers_df['registration_date'])\n    customers_df['last_purchase_date'] = pd.to_datetime(customers_df['last_purchase_date'])\n    products_df['launch_date'] = pd.to_datetime(products_df['launch_date'])\n    \n    return transactions_df, customers_df, products_df\n\ndef filter_data(df, filters):\n    \"\"\"Aplica filtros al DataFrame\"\"\"\n    filtered_df = df.copy()\n    \n    if 'date_range' in filters and filters['date_range']:\n        start_date, end_date = filters['date_range']\n        filtered_df = filtered_df[(filtered_df['date'] >= pd.Timestamp(start_date)) & \n                                   (filtered_df['date'] <= pd.Timestamp(end_date))]\n    \n    if 'countries' in filters and filters['countries']:\n        filtered_df = filtered_df[filtered_df['country'].isin(filters['countries'])]\n    \n    if 'categories' in filters and filters['categories']:\n        filtered_df = filtered_df[filtered_df['category'].isin(filters['categories'])]\n    \n    if 'segments' in filters and filters['segments']:\n        filtered_df = filtered_df[filtered_df['customer_segment'].isin(filters['segments'])]\n    \n    if 'payment_methods' in filters and filters['payment_methods']:\n        filtered_df = filtered_df[filtered_df['payment_method'].isin(filters['payment_methods'])]\n    \n    if 'device_types' in filters and filters['device_types']:\n        filtered_df = filtered_df[filtered_df['device_type'].isin(filters['device_types'])]\n    \n    if 'traffic_sources' in filters and filters['traffic_sources']:\n        filtered_df = filtered_df[filtered_df['traffic_source'].isin(filters['traffic_sources'])]\n    \n    if 'price_range' in filters and filters['price_range']:\n        min_price, max_price = filters['price_range']\n        filtered_df = filtered_df[(filtered_df['unit_price'] >= min_price) & \n                                   (filtered_df['unit_price'] <= max_price)]\n    \n    return filtered_df\n\ndef get_date_range_preset(preset):\n    \"\"\"Devuelve rango de fechas basado en preset\"\"\"\n    end_date = datetime.now()\n    \n    if preset == 'Today':\n        start_date = end_date - timedelta(days=1)\n    elif preset == 'Last 7 Days':\n        start_date = end_date - timedelta(days=7)\n    elif preset == 'Last 30 Days':\n        start_date = end_date - timedelta(days=30)\n    elif preset == 'Last 90 Days':\n        start_date = end_date - timedelta(days=90)\n    elif preset == 'Last Year':\n        start_date = end_date - timedelta(days=365)\n    elif preset == 'All Time':\n        start_date = end_date - timedelta(days=730)\n    else:\n        start_date = end_date - timedelta(days=30)\n    \n    return start_date, end_date\n","size_bytes":4195},"database/migration.py":{"content":"import pandas as pd\nimport os\nfrom database.schema import get_session, create_tables, drop_tables, Transaction, Customer, Product\nfrom sqlalchemy.exc import IntegrityError\nfrom tqdm import tqdm\n\ndef migrate_data_to_postgres():\n    \"\"\"Migra datos desde Parquet a PostgreSQL\"\"\"\n    \n    # Crear tablas\n    print(\"📊 Creando esquema de base de datos...\")\n    create_tables()\n    \n    # Verificar que existen los archivos Parquet\n    data_dir = 'data'\n    transactions_path = os.path.join(data_dir, 'transactions.parquet')\n    customers_path = os.path.join(data_dir, 'customers.parquet')\n    products_path = os.path.join(data_dir, 'products.parquet')\n    \n    if not all([os.path.exists(p) for p in [transactions_path, customers_path, products_path]]):\n        print(\"❌ No se encontraron archivos Parquet. Genera los datos primero.\")\n        return False\n    \n    session = get_session()\n    \n    try:\n        # Migrar productos\n        print(\"\\n📦 Migrando productos...\")\n        products_df = pd.read_parquet(products_path)\n        \n        for _, row in tqdm(products_df.iterrows(), total=len(products_df)):\n            product = Product(\n                product_id=row['product_id'],\n                product_name=row['product_name'],\n                category=row['category'],\n                subcategory=row['subcategory'],\n                brand=row['brand'],\n                base_price=float(row['base_price']),\n                cost_price=float(row['cost_price']),\n                margin_percentage=float(row['margin_percentage']),\n                stock_quantity=int(row['stock_quantity']),\n                supplier_country=row['supplier_country'],\n                weight=float(row['weight']),\n                rating=float(row['rating']),\n                reviews_count=int(row['reviews_count']),\n                launch_date=pd.to_datetime(row['launch_date']).date()\n            )\n            session.add(product)\n        \n        session.commit()\n        print(f\"✅ {len(products_df)} productos migrados\")\n        \n        # Migrar clientes\n        print(\"\\n👥 Migrando clientes...\")\n        customers_df = pd.read_parquet(customers_path)\n        \n        for _, row in tqdm(customers_df.iterrows(), total=len(customers_df)):\n            customer = Customer(\n                customer_id=row['customer_id'],\n                registration_date=pd.to_datetime(row['registration_date']).date(),\n                country=row['country'],\n                age=int(row['age']),\n                gender=row['gender'],\n                lifetime_value=float(row['lifetime_value']),\n                total_orders=int(row['total_orders']),\n                avg_order_value=float(row['avg_order_value']),\n                last_purchase_date=pd.to_datetime(row['last_purchase_date']),\n                recency_score=int(row['recency_score']),\n                frequency_score=int(row['frequency_score']),\n                monetary_score=float(row['monetary_score']),\n                rfm_segment=row['rfm_segment'],\n                churn_probability=float(row['churn_probability']),\n                preferred_category=row['preferred_category']\n            )\n            session.add(customer)\n        \n        session.commit()\n        print(f\"✅ {len(customers_df)} clientes migrados\")\n        \n        # Migrar transacciones (en batches para mejor performance)\n        print(\"\\n💳 Migrando transacciones...\")\n        transactions_df = pd.read_parquet(transactions_path)\n        \n        batch_size = 1000\n        for i in tqdm(range(0, len(transactions_df), batch_size)):\n            batch = transactions_df.iloc[i:i+batch_size]\n            \n            for _, row in batch.iterrows():\n                transaction = Transaction(\n                    transaction_id=row['transaction_id'],\n                    date=pd.to_datetime(row['date']),\n                    customer_id=row['customer_id'],\n                    country=row['country'],\n                    region=row['region'],\n                    city=row['city'],\n                    product_id=row['product_id'],\n                    product_name=row['product_name'],\n                    category=row['category'],\n                    subcategory=row['subcategory'],\n                    quantity=int(row['quantity']),\n                    unit_price=float(row['unit_price']),\n                    total_amount=float(row['total_amount']),\n                    discount_applied=float(row['discount_applied']),\n                    payment_method=row['payment_method'],\n                    shipping_cost=float(row['shipping_cost']),\n                    delivery_time=int(row['delivery_time']),\n                    customer_segment=row['customer_segment'],\n                    device_type=row['device_type'],\n                    traffic_source=row['traffic_source'],\n                    currency=row['currency'],\n                    exchange_rate=float(row['exchange_rate']),\n                    total_amount_usd=float(row['total_amount_usd']),\n                    cost_price=float(row['cost_price']),\n                    profit=float(row['profit'])\n                )\n                session.add(transaction)\n            \n            session.commit()\n        \n        print(f\"✅ {len(transactions_df)} transacciones migradas\")\n        \n        print(\"\\n🎉 ¡Migración completada exitosamente!\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error durante la migración: {str(e)}\")\n        session.rollback()\n        return False\n    finally:\n        session.close()\n\nif __name__ == \"__main__\":\n    migrate_data_to_postgres()\n","size_bytes":5589},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"faker>=37.12.0\",\n    \"fastapi>=0.120.0\",\n    \"folium>=0.20.0\",\n    \"matplotlib>=3.10.7\",\n    \"numpy>=2.3.4\",\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.3.3\",\n    \"plotly>=6.3.1\",\n    \"prophet>=1.2.1\",\n    \"psycopg2-binary>=2.9.11\",\n    \"reportlab>=4.4.4\",\n    \"scikit-learn>=1.7.2\",\n    \"seaborn>=0.13.2\",\n    \"sqlalchemy>=2.0.44\",\n    \"streamlit>=1.50.0\",\n    \"streamlit-folium>=0.25.3\",\n    \"uvicorn>=0.38.0\",\n    \"xgboost>=3.1.1\",\n]\n","size_bytes":578},"utils/data_loader_pg.py":{"content":"import pandas as pd\nimport streamlit as st\nfrom sqlalchemy import text\nfrom database.schema import get_engine, get_session\nfrom datetime import datetime, timedelta\nfrom utils.traducciones import (\n    aplicar_traducciones_df, \n    aplicar_traducciones_paises_df,\n    aplicar_traducciones_rfm_df,\n    aplicar_traducciones_dispositivos_df,\n    aplicar_traducciones_metodos_pago_df,\n    aplicar_traducciones_fuentes_trafico_df,\n    aplicar_traducciones_segmentos_clientes_df\n)\n\n@st.cache_data(ttl=300)\ndef load_data_from_postgres():\n    \"\"\"Carga datos desde archivos unificados (Parquet) o PostgreSQL\"\"\"\n    import os\n    \n    # Verificar si existen archivos unificados\n    use_unified = os.path.exists('data/transactions_unified.parquet')\n    \n    if use_unified:\n        try:\n            # Cargar desde archivos unificados\n            transactions_df = pd.read_parquet('data/transactions_unified.parquet')\n            customers_df = pd.read_parquet('data/customers_unified.parquet')\n            products_df = pd.read_parquet('data/products_unified.parquet')\n            \n            # Convertir fechas\n            transactions_df['date'] = pd.to_datetime(transactions_df['date'])\n            customers_df['registration_date'] = pd.to_datetime(customers_df['registration_date'])\n            customers_df['last_purchase_date'] = pd.to_datetime(customers_df['last_purchase_date'])\n            if 'launch_date' in products_df.columns:\n                products_df['launch_date'] = pd.to_datetime(products_df['launch_date'])\n            \n            # Traducir categorías al español\n            transactions_df = aplicar_traducciones_df(transactions_df, 'category')\n            products_df = aplicar_traducciones_df(products_df, 'category')\n            if 'subcategory' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_df(transactions_df, 'subcategory')\n            if 'subcategory' in products_df.columns:\n                products_df = aplicar_traducciones_df(products_df, 'subcategory')\n            \n            # Traducir países al español\n            transactions_df = aplicar_traducciones_paises_df(transactions_df, 'country')\n            customers_df = aplicar_traducciones_paises_df(customers_df, 'country')\n            \n            # Traducir segmentos RFM al español\n            if 'rfm_segment' in customers_df.columns:\n                customers_df = aplicar_traducciones_rfm_df(customers_df, 'rfm_segment')\n            \n            # Traducir dispositivos al español\n            if 'device_type' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_dispositivos_df(transactions_df, 'device_type')\n            \n            # Traducir métodos de pago al español\n            if 'payment_method' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_metodos_pago_df(transactions_df, 'payment_method')\n            \n            # Traducir fuentes de tráfico al español\n            if 'traffic_source' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_fuentes_trafico_df(transactions_df, 'traffic_source')\n            \n            # Traducir segmentos de clientes al español\n            if 'customer_segment' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_segmentos_clientes_df(transactions_df, 'customer_segment')\n            if 'customer_segment' in customers_df.columns:\n                customers_df = aplicar_traducciones_segmentos_clientes_df(customers_df, 'customer_segment')\n            \n            return transactions_df, customers_df, products_df\n            \n        except Exception as e:\n            pass\n    \n    # Fallback a PostgreSQL\n    engine = get_engine()\n    \n    try:\n        # Cargar transacciones\n        transactions_df = pd.read_sql_table('transactions', engine)\n        \n        # Cargar clientes\n        customers_df = pd.read_sql_table('customers', engine)\n        \n        # Cargar productos\n        products_df = pd.read_sql_table('products', engine)\n        \n        # Convertir fechas\n        transactions_df['date'] = pd.to_datetime(transactions_df['date'])\n        customers_df['registration_date'] = pd.to_datetime(customers_df['registration_date'])\n        customers_df['last_purchase_date'] = pd.to_datetime(customers_df['last_purchase_date'])\n        products_df['launch_date'] = pd.to_datetime(products_df['launch_date'])\n        \n        # Traducir categorías al español\n        transactions_df = aplicar_traducciones_df(transactions_df, 'category')\n        products_df = aplicar_traducciones_df(products_df, 'category')\n        if 'subcategory' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_df(transactions_df, 'subcategory')\n        if 'subcategory' in products_df.columns:\n            products_df = aplicar_traducciones_df(products_df, 'subcategory')\n        \n        # Traducir países al español\n        transactions_df = aplicar_traducciones_paises_df(transactions_df, 'country')\n        customers_df = aplicar_traducciones_paises_df(customers_df, 'country')\n        \n        # Traducir segmentos RFM al español\n        if 'rfm_segment' in customers_df.columns:\n            customers_df = aplicar_traducciones_rfm_df(customers_df, 'rfm_segment')\n        \n        # Traducir dispositivos al español\n        if 'device_type' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_dispositivos_df(transactions_df, 'device_type')\n        \n        # Traducir métodos de pago al español\n        if 'payment_method' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_metodos_pago_df(transactions_df, 'payment_method')\n        \n        # Traducir fuentes de tráfico al español\n        if 'traffic_source' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_fuentes_trafico_df(transactions_df, 'traffic_source')\n        \n        # Traducir segmentos de clientes al español\n        if 'customer_segment' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_segmentos_clientes_df(transactions_df, 'customer_segment')\n        if 'customer_segment' in customers_df.columns:\n            customers_df = aplicar_traducciones_segmentos_clientes_df(customers_df, 'customer_segment')\n        \n        return transactions_df, customers_df, products_df\n        \n    except Exception as e:\n        st.error(f\"Error loading data: {str(e)}\")\n        return None, None, None\n\n@st.cache_data\ndef load_or_generate_data():\n    \"\"\"Carga datos desde fuente disponible\"\"\"\n    # Cargar directamente sin mensajes\n    return load_data_from_postgres()\n\ndef filter_data(df, filters):\n    \"\"\"Aplica filtros al DataFrame\"\"\"\n    filtered_df = df.copy()\n    \n    if 'date_range' in filters and filters['date_range']:\n        start_date, end_date = filters['date_range']\n        filtered_df = filtered_df[(filtered_df['date'] >= pd.Timestamp(start_date)) & \n                                   (filtered_df['date'] <= pd.Timestamp(end_date))]\n    \n    if 'countries' in filters and filters['countries']:\n        filtered_df = filtered_df[filtered_df['country'].isin(filters['countries'])]\n    \n    if 'categories' in filters and filters['categories']:\n        filtered_df = filtered_df[filtered_df['category'].isin(filters['categories'])]\n    \n    if 'segments' in filters and filters['segments']:\n        filtered_df = filtered_df[filtered_df['customer_segment'].isin(filters['segments'])]\n    \n    if 'payment_methods' in filters and filters['payment_methods']:\n        filtered_df = filtered_df[filtered_df['payment_method'].isin(filters['payment_methods'])]\n    \n    if 'device_types' in filters and filters['device_types']:\n        filtered_df = filtered_df[filtered_df['device_type'].isin(filters['device_types'])]\n    \n    if 'traffic_sources' in filters and filters['traffic_sources']:\n        filtered_df = filtered_df[filtered_df['traffic_source'].isin(filters['traffic_sources'])]\n    \n    if 'price_range' in filters and filters['price_range']:\n        min_price, max_price = filters['price_range']\n        filtered_df = filtered_df[(filtered_df['unit_price'] >= min_price) & \n                                   (filtered_df['unit_price'] <= max_price)]\n    \n    return filtered_df\n\ndef get_date_range_preset(preset):\n    \"\"\"Devuelve rango de fechas basado en preset\"\"\"\n    end_date = datetime.now()\n    \n    if preset == 'Today':\n        start_date = end_date - timedelta(days=1)\n    elif preset == 'Last 7 Days':\n        start_date = end_date - timedelta(days=7)\n    elif preset == 'Last 30 Days':\n        start_date = end_date - timedelta(days=30)\n    elif preset == 'Last 90 Days':\n        start_date = end_date - timedelta(days=90)\n    elif preset == 'Last Year':\n        start_date = end_date - timedelta(days=365)\n    elif preset == 'All Time':\n        start_date = end_date - timedelta(days=730)\n    else:\n        start_date = end_date - timedelta(days=30)\n    \n    return start_date, end_date\n\n@st.cache_data(ttl=60)\ndef get_kpis_from_db(start_date, end_date, filters=None):\n    \"\"\"Obtiene KPIs directamente desde PostgreSQL con query optimizada\"\"\"\n    engine = get_engine()\n    \n    query = f\"\"\"\n    SELECT \n        COUNT(*) as total_orders,\n        SUM(total_amount_usd) as total_revenue,\n        AVG(total_amount_usd) as avg_order_value,\n        SUM(profit) as total_profit,\n        COUNT(DISTINCT customer_id) as total_customers\n    FROM transactions\n    WHERE date >= '{start_date}' AND date <= '{end_date}'\n    \"\"\"\n    \n    if filters:\n        if 'countries' in filters and filters['countries']:\n            countries_str = \"','\".join(filters['countries'])\n            query += f\" AND country IN ('{countries_str}')\"\n        \n        if 'categories' in filters and filters['categories']:\n            categories_str = \"','\".join(filters['categories'])\n            query += f\" AND category IN ('{categories_str}')\"\n    \n    try:\n        result = pd.read_sql_query(query, engine)\n        return result.iloc[0].to_dict()\n    except:\n        return None\n","size_bytes":10100},"main.py":{"content":"def main():\n    print(\"Hello from repl-nix-workspace!\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":96},"utils/traducciones.py":{"content":"\"\"\"\nTraducciones completas al español para el dashboard\nIncluye: categorías, países, días, segmentos RFM, dispositivos, métodos de pago\n\"\"\"\n\nimport pandas as pd\n\n# Diccionario de traducción de segmentos RFM\nSEGMENTOS_RFM_TRADUCCION = {\n    'Champions': 'Campeones',\n    'Loyal Customers': 'Clientes Leales',\n    'Potential Loyalists': 'Potencialmente Leales',\n    'Recent Customers': 'Clientes Recientes',\n    'Promising': 'Prometedores',\n    'Customers Needing Attention': 'Necesitan Atención',\n    'About To Sleep': 'Por Dormir',\n    'At Risk': 'En Riesgo',\n    'Cant Lose Them': 'No Perderlos',\n    'Hibernating': 'Hibernando',\n    'Lost': 'Perdidos',\n    # Versiones alternativas\n    'Cant Lose': 'No Perderlos',\n    'Lost Customers': 'Perdidos',\n    # Minúsculas también\n    'champions': 'Campeones',\n    'loyal customers': 'Clientes Leales',\n    'potential loyalists': 'Potencialmente Leales',\n    'recent customers': 'Clientes Recientes',\n    'promising': 'Prometedores',\n    'customers needing attention': 'Necesitan Atención',\n    'about to sleep': 'Por Dormir',\n    'at risk': 'En Riesgo',\n    'cant lose them': 'No Perderlos',\n    'hibernating': 'Hibernando',\n    'lost': 'Perdidos'\n}\n\n# Diccionario de traducción de dispositivos\nDISPOSITIVOS_TRADUCCION = {\n    'Mobile': 'Móvil',\n    'Tablet': 'Tableta',\n    'Desktop': 'Escritorio',\n    'mobile': 'Móvil',\n    'tablet': 'Tableta',\n    'desktop': 'Escritorio'\n}\n\n# Diccionario de traducción de métodos de pago\nMETODOS_PAGO_TRADUCCION = {\n    'Credit Card': 'Tarjeta de Crédito',\n    'Debit Card': 'Tarjeta de Débito',\n    'PayPal': 'PayPal',\n    'Bank Transfer': 'Transferencia Bancaria',\n    'Cash': 'Efectivo',\n    'Wire Transfer': 'Transferencia',\n    # Minúsculas\n    'credit card': 'Tarjeta de Crédito',\n    'debit card': 'Tarjeta de Débito',\n    'paypal': 'PayPal',\n    'bank transfer': 'Transferencia Bancaria',\n    'cash': 'Efectivo',\n    'wire transfer': 'Transferencia'\n}\n\n# Diccionario de traducción de países\nPAISES_TRADUCCION = {\n    'United Kingdom': 'Reino Unido',\n    'United States': 'Estados Unidos',\n    'France': 'Francia',\n    'Germany': 'Alemania',\n    'Spain': 'España',\n    'Italy': 'Italia',\n    'Netherlands': 'Países Bajos',\n    'Belgium': 'Bélgica',\n    'Switzerland': 'Suiza',\n    'Portugal': 'Portugal',\n    'Sweden': 'Suecia',\n    'Norway': 'Noruega',\n    'Denmark': 'Dinamarca',\n    'Finland': 'Finlandia',\n    'Poland': 'Polonia',\n    'Austria': 'Austria',\n    'Greece': 'Grecia',\n    'Ireland': 'Irlanda',\n    'EIRE': 'Irlanda',\n    'Czech Republic': 'República Checa',\n    'Hungary': 'Hungría',\n    'Romania': 'Rumania',\n    'Bulgaria': 'Bulgaria',\n    'Croatia': 'Croacia',\n    'Slovakia': 'Eslovaquia',\n    'Slovenia': 'Eslovenia',\n    'Lithuania': 'Lituania',\n    'Latvia': 'Letonia',\n    'Estonia': 'Estonia',\n    'Luxembourg': 'Luxemburgo',\n    'Malta': 'Malta',\n    'Cyprus': 'Chipre',\n    'Australia': 'Australia',\n    'Canada': 'Canadá',\n    'Japan': 'Japón',\n    'China': 'China',\n    'India': 'India',\n    'Brazil': 'Brasil',\n    'Mexico': 'México',\n    'Argentina': 'Argentina',\n    'Chile': 'Chile',\n    'Colombia': 'Colombia',\n    'Peru': 'Perú',\n    'Venezuela': 'Venezuela',\n    'Ecuador': 'Ecuador',\n    'Uruguay': 'Uruguay',\n    'Paraguay': 'Paraguay',\n    'Bolivia': 'Bolivia',\n    'Costa Rica': 'Costa Rica',\n    'Panama': 'Panamá',\n    'Guatemala': 'Guatemala',\n    'Honduras': 'Honduras',\n    'Nicaragua': 'Nicaragua',\n    'El Salvador': 'El Salvador',\n    'Dominican Republic': 'República Dominicana',\n    'Cuba': 'Cuba',\n    'Puerto Rico': 'Puerto Rico',\n    'Jamaica': 'Jamaica',\n    'Trinidad and Tobago': 'Trinidad y Tobago',\n    'Bahamas': 'Bahamas',\n    'Barbados': 'Barbados',\n    'South Africa': 'Sudáfrica',\n    'Egypt': 'Egipto',\n    'Morocco': 'Marruecos',\n    'Tunisia': 'Túnez',\n    'Algeria': 'Argelia',\n    'Kenya': 'Kenia',\n    'Nigeria': 'Nigeria',\n    'Ghana': 'Ghana',\n    'Ethiopia': 'Etiopía',\n    'Tanzania': 'Tanzania',\n    'Uganda': 'Uganda',\n    'Zimbabwe': 'Zimbabue',\n    'South Korea': 'Corea del Sur',\n    'North Korea': 'Corea del Norte',\n    'Singapore': 'Singapur',\n    'Malaysia': 'Malasia',\n    'Indonesia': 'Indonesia',\n    'Philippines': 'Filipinas',\n    'Thailand': 'Tailandia',\n    'Vietnam': 'Vietnam',\n    'Cambodia': 'Camboya',\n    'Laos': 'Laos',\n    'Myanmar': 'Myanmar',\n    'Bangladesh': 'Bangladés',\n    'Pakistan': 'Pakistán',\n    'Sri Lanka': 'Sri Lanka',\n    'Nepal': 'Nepal',\n    'Afghanistan': 'Afganistán',\n    'Iran': 'Irán',\n    'Iraq': 'Irak',\n    'Saudi Arabia': 'Arabia Saudita',\n    'United Arab Emirates': 'Emiratos Árabes Unidos',\n    'Kuwait': 'Kuwait',\n    'Qatar': 'Catar',\n    'Bahrain': 'Baréin',\n    'Oman': 'Omán',\n    'Jordan': 'Jordania',\n    'Lebanon': 'Líbano',\n    'Syria': 'Siria',\n    'Israel': 'Israel',\n    'Palestine': 'Palestina',\n    'Turkey': 'Turquía',\n    'Russia': 'Rusia',\n    'Ukraine': 'Ucrania',\n    'Belarus': 'Bielorrusia',\n    'Moldova': 'Moldavia',\n    'Georgia': 'Georgia',\n    'Armenia': 'Armenia',\n    'Azerbaijan': 'Azerbaiyán',\n    'Kazakhstan': 'Kazajistán',\n    'Uzbekistan': 'Uzbekistán',\n    'Turkmenistan': 'Turkmenistán',\n    'Kyrgyzstan': 'Kirguistán',\n    'Tajikistan': 'Tayikistán',\n    'New Zealand': 'Nueva Zelanda',\n    'Fiji': 'Fiyi',\n    'Papua New Guinea': 'Papúa Nueva Guinea',\n    'Iceland': 'Islandia'\n}\n\n# Diccionario de traducción de días de semana\nDIAS_SEMANA_TRADUCCION = {\n    'Monday': 'Lunes',\n    'Tuesday': 'Martes',\n    'Wednesday': 'Miércoles',\n    'Thursday': 'Jueves',\n    'Friday': 'Viernes',\n    'Saturday': 'Sábado',\n    'Sunday': 'Domingo',\n    # Abreviaciones\n    'Mon': 'Lun',\n    'Tue': 'Mar',\n    'Wed': 'Mié',\n    'Thu': 'Jue',\n    'Fri': 'Vie',\n    'Sat': 'Sáb',\n    'Sun': 'Dom'\n}\n\n# Diccionario de traducción de meses\nMESES_TRADUCCION = {\n    'January': 'Enero',\n    'February': 'Febrero',\n    'March': 'Marzo',\n    'April': 'Abril',\n    'May': 'Mayo',\n    'June': 'Junio',\n    'July': 'Julio',\n    'August': 'Agosto',\n    'September': 'Septiembre',\n    'October': 'Octubre',\n    'November': 'Noviembre',\n    'December': 'Diciembre',\n    # Abreviaciones\n    'Jan': 'Ene',\n    'Feb': 'Feb',\n    'Mar': 'Mar',\n    'Apr': 'Abr',\n    'May': 'May',\n    'Jun': 'Jun',\n    'Jul': 'Jul',\n    'Aug': 'Ago',\n    'Sep': 'Sep',\n    'Oct': 'Oct',\n    'Nov': 'Nov',\n    'Dec': 'Dic'\n}\n\n# Diccionario de traducción de categorías\nCATEGORIAS_TRADUCCION = {\n    # Categorías principales\n    'Books': 'Libros',\n    'Electronics': 'Electrónica',\n    'Clothing': 'Ropa',\n    'Home & Garden': 'Hogar y Jardín',\n    'Home': 'Hogar',\n    'Sports': 'Deportes',\n    'Toys': 'Juguetes',\n    'Beauty': 'Belleza',\n    'Food': 'Alimentos',\n    'Groceries': 'Comestibles',\n    'Fashion': 'Moda',\n    'Health': 'Salud',\n    'Automotive': 'Automotriz',\n    'Office': 'Oficina',\n    'Pet Supplies': 'Mascotas',\n    'Music': 'Música',\n    'Movies': 'Películas',\n    'Games': 'Videojuegos',\n    'Baby': 'Bebé',\n    'Tools': 'Herramientas',\n    'Jewelry': 'Joyería',\n    'Shoes': 'Calzado',\n    'Outdoor': 'Exterior',\n    \n    # Subcategorías comunes\n    'book': 'libros',\n    'electronics': 'electrónica',\n    'clothing': 'ropa',\n    'home': 'hogar',\n    'garden': 'jardín',\n    'sports': 'deportes',\n    'toys': 'juguetes',\n    'beauty': 'belleza',\n    'food': 'alimentos',\n    'groceries': 'comestibles',\n    'fashion': 'moda',\n    'health': 'salud',\n    'automotive': 'automotriz',\n    'office': 'oficina',\n    'pet': 'mascotas',\n    'music': 'música',\n    'movies': 'películas',\n    'games': 'videojuegos',\n    'baby': 'bebé',\n    'tools': 'herramientas',\n    'jewelry': 'joyería',\n    'shoes': 'calzado',\n    'outdoor': 'exterior'\n}\n\n# Diccionario de traducción de fuentes de tráfico\nFUENTES_TRAFICO_TRADUCCION = {\n    'Direct': 'Directo',\n    'Organic': 'Orgánico',\n    'Paid Ads': 'Anuncios Pagados',\n    'Social Media': 'Redes Sociales',\n    'Email': 'Correo Electrónico',\n    'Referral': 'Referencia',\n    'Affiliate': 'Afiliado',\n    # Minúsculas\n    'direct': 'Directo',\n    'organic': 'Orgánico',\n    'paid ads': 'Anuncios Pagados',\n    'social media': 'Redes Sociales',\n    'email': 'Correo Electrónico',\n    'referral': 'Referencia',\n    'affiliate': 'Afiliado'\n}\n\n# Diccionario de traducción de segmentos de clientes\nSEGMENTOS_CLIENTES_TRADUCCION = {\n    'New': 'Nuevo',\n    'Regular': 'Regular',\n    'VIP': 'VIP',\n    'Premium': 'Premium',\n    'Bronze': 'Bronce',\n    'Silver': 'Plata',\n    'Gold': 'Oro',\n    # Minúsculas\n    'new': 'Nuevo',\n    'regular': 'Regular',\n    'vip': 'VIP',\n    'premium': 'Premium',\n    'bronze': 'Bronce',\n    'silver': 'Plata',\n    'gold': 'Oro'\n}\n\n# Diccionario inverso (español -> inglés) para filtros\nCATEGORIAS_INVERSO = {v: k for k, v in CATEGORIAS_TRADUCCION.items()}\n\ndef traducir_categoria(categoria):\n    \"\"\"Traduce una categoría del inglés al español\"\"\"\n    if not categoria:\n        return categoria\n    \n    # Buscar traducción exacta\n    if categoria in CATEGORIAS_TRADUCCION:\n        return CATEGORIAS_TRADUCCION[categoria]\n    \n    # Buscar traducción case-insensitive\n    categoria_lower = categoria.lower()\n    if categoria_lower in CATEGORIAS_TRADUCCION:\n        return CATEGORIAS_TRADUCCION[categoria_lower]\n    \n    # Si no hay traducción, capitalizar la primera letra\n    return categoria.capitalize()\n\ndef traducir_categoria_inverso(categoria_es):\n    \"\"\"Traduce una categoría del español al inglés (para filtros)\"\"\"\n    if not categoria_es:\n        return categoria_es\n    \n    if categoria_es in CATEGORIAS_INVERSO:\n        return CATEGORIAS_INVERSO[categoria_es]\n    \n    # Si no hay traducción inversa, devolver como está\n    return categoria_es\n\ndef traducir_pais(pais):\n    \"\"\"Traduce un país del inglés al español\"\"\"\n    if not pais:\n        return pais\n    \n    # Buscar traducción exacta\n    if pais in PAISES_TRADUCCION:\n        return PAISES_TRADUCCION[pais]\n    \n    # Si no hay traducción, devolver como está\n    return pais\n\ndef traducir_dia_semana(dia):\n    \"\"\"Traduce un día de la semana del inglés al español\"\"\"\n    if not dia:\n        return dia\n    \n    # Buscar traducción exacta\n    if dia in DIAS_SEMANA_TRADUCCION:\n        return DIAS_SEMANA_TRADUCCION[dia]\n    \n    # Si no hay traducción, devolver como está\n    return dia\n\ndef traducir_mes(mes):\n    \"\"\"Traduce un mes del inglés al español\"\"\"\n    if not mes:\n        return mes\n    \n    # Buscar traducción exacta\n    if mes in MESES_TRADUCCION:\n        return MESES_TRADUCCION[mes]\n    \n    # Si no hay traducción, devolver como está\n    return mes\n\ndef aplicar_traducciones_df(df, columna='category'):\n    \"\"\"Aplica traducciones a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_categoria)\n    return df\n\ndef aplicar_traducciones_paises_df(df, columna='country'):\n    \"\"\"Aplica traducciones de países a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_pais)\n    return df\n\ndef traducir_segmento_rfm(segmento):\n    \"\"\"Traduce un segmento RFM del inglés al español\"\"\"\n    if not segmento or pd.isna(segmento):\n        return segmento\n    \n    # Convertir a string y buscar traducción (case-insensitive)\n    segmento_str = str(segmento).strip()\n    \n    # Buscar traducción exacta\n    if segmento_str in SEGMENTOS_RFM_TRADUCCION:\n        return SEGMENTOS_RFM_TRADUCCION[segmento_str]\n    \n    # Buscar case-insensitive\n    for key, value in SEGMENTOS_RFM_TRADUCCION.items():\n        if key.lower() == segmento_str.lower():\n            return value\n    \n    # Si no hay traducción, devolver como está\n    return segmento_str\n\ndef traducir_dispositivo(dispositivo):\n    \"\"\"Traduce un tipo de dispositivo del inglés al español\"\"\"\n    if not dispositivo or pd.isna(dispositivo):\n        return dispositivo\n    \n    dispositivo_str = str(dispositivo).strip()\n    \n    # Buscar traducción exacta o case-insensitive\n    if dispositivo_str in DISPOSITIVOS_TRADUCCION:\n        return DISPOSITIVOS_TRADUCCION[dispositivo_str]\n    \n    for key, value in DISPOSITIVOS_TRADUCCION.items():\n        if key.lower() == dispositivo_str.lower():\n            return value\n    \n    return dispositivo_str\n\ndef traducir_metodo_pago(metodo):\n    \"\"\"Traduce un método de pago del inglés al español\"\"\"\n    if not metodo or pd.isna(metodo):\n        return metodo\n    \n    metodo_str = str(metodo).strip()\n    \n    # Buscar traducción exacta o case-insensitive\n    if metodo_str in METODOS_PAGO_TRADUCCION:\n        return METODOS_PAGO_TRADUCCION[metodo_str]\n    \n    for key, value in METODOS_PAGO_TRADUCCION.items():\n        if key.lower() == metodo_str.lower():\n            return value\n    \n    return metodo_str\n\ndef aplicar_traducciones_rfm_df(df, columna='rfm_segment'):\n    \"\"\"Aplica traducciones de segmentos RFM a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_segmento_rfm)\n    return df\n\ndef aplicar_traducciones_dispositivos_df(df, columna='device_type'):\n    \"\"\"Aplica traducciones de dispositivos a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_dispositivo)\n    return df\n\ndef aplicar_traducciones_metodos_pago_df(df, columna='payment_method'):\n    \"\"\"Aplica traducciones de métodos de pago a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_metodo_pago)\n    return df\n\ndef traducir_fuente_trafico(fuente):\n    \"\"\"Traduce una fuente de tráfico del inglés al español\"\"\"\n    if not fuente or pd.isna(fuente):\n        return fuente\n    \n    fuente_str = str(fuente).strip()\n    \n    # Buscar traducción exacta o case-insensitive\n    if fuente_str in FUENTES_TRAFICO_TRADUCCION:\n        return FUENTES_TRAFICO_TRADUCCION[fuente_str]\n    \n    for key, value in FUENTES_TRAFICO_TRADUCCION.items():\n        if key.lower() == fuente_str.lower():\n            return value\n    \n    return fuente_str\n\ndef traducir_segmento_cliente(segmento):\n    \"\"\"Traduce un segmento de cliente del inglés al español\"\"\"\n    if not segmento or pd.isna(segmento):\n        return segmento\n    \n    segmento_str = str(segmento).strip()\n    \n    # Buscar traducción exacta o case-insensitive\n    if segmento_str in SEGMENTOS_CLIENTES_TRADUCCION:\n        return SEGMENTOS_CLIENTES_TRADUCCION[segmento_str]\n    \n    for key, value in SEGMENTOS_CLIENTES_TRADUCCION.items():\n        if key.lower() == segmento_str.lower():\n            return value\n    \n    return segmento_str\n\ndef aplicar_traducciones_fuentes_trafico_df(df, columna='traffic_source'):\n    \"\"\"Aplica traducciones de fuentes de tráfico a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_fuente_trafico)\n    return df\n\ndef aplicar_traducciones_segmentos_clientes_df(df, columna='customer_segment'):\n    \"\"\"Aplica traducciones de segmentos de clientes a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_segmento_cliente)\n    return df\n\n# Diccionario de labels profesionales para gráficos\nLABELS_PROFESIONALES = {\n    # Columnas comunes\n    'total_amount_usd': 'Ingresos (USD)',\n    'transaction_id': 'Transacciones',\n    'profit': 'Beneficio (USD)',\n    'quantity': 'Cantidad',\n    'unit_price': 'Precio Unitario (USD)',\n    'customer_id': 'ID Cliente',\n    'product_id': 'ID Producto',\n    'product_name': 'Producto',\n    'category': 'Categoría',\n    'subcategory': 'Subcategoría',\n    'country': 'País',\n    'city': 'Ciudad',\n    'date': 'Fecha',\n    'device_type': 'Dispositivo',\n    'traffic_source': 'Fuente de Tráfico',\n    'payment_method': 'Método de Pago',\n    'customer_segment': 'Segmento',\n    \n    # RFM y segmentación\n    'recency': 'Recencia (días)',\n    'frequency': 'Frecuencia (compras)',\n    'monetary': 'Valor Monetario (USD)',\n    'rfm_segment': 'Segmento RFM',\n    'churn_probability': 'Probabilidad de Churn (%)',\n    'lifetime_value': 'Valor de Vida (USD)',\n    'count': 'Cantidad',\n    'value': 'Valor',\n    \n    # Análisis especiales\n    'margen_%': 'Margen (%)',\n    'churn_risk': 'Riesgo de Churn (%)',\n    'ltv': 'Valor de Vida (USD)',\n    'aov': 'Ticket Promedio (USD)',\n    'es_anomalia': 'Anomalía',\n    \n    # Temporal\n    'dia_semana': 'Día de la Semana',\n    'hora': 'Hora del Día',\n    'mes': 'Mes',\n    'año': 'Año',\n    'periodo': 'Período',\n    'Fecha': 'Fecha',\n    'Ingresos': 'Ingresos (USD)',\n    'Pedidos': 'Pedidos',\n    'Beneficio': 'Beneficio (USD)',\n    \n    # Agregaciones\n    'ingresos': 'Ingresos (USD)',\n    'pedidos': 'Pedidos',\n    'beneficio': 'Beneficio (USD)',\n    'cantidad': 'Cantidad',\n    'clientes': 'Clientes',\n    'productos': 'Productos',\n    'producto': 'Producto',\n    'transacciones': 'Transacciones',\n    'metodo': 'Método de Pago',\n    'segmento': 'Segmento',\n    'nivel_riesgo': 'Nivel de Riesgo',\n    'cluster': 'Cluster',\n    'cuadrante': 'Cuadrante BCG',\n    'velocidad': 'Velocidad de Rotación',\n    'frecuencia': 'Frecuencia'\n}\n\ndef obtener_labels_profesionales():\n    \"\"\"Retorna diccionario de labels profesionales para gráficos\"\"\"\n    return LABELS_PROFESIONALES.copy()\n","size_bytes":17299},"DEPLOY_STREAMLIT.md":{"content":"# 🚀 Guía de Deploy en Streamlit Cloud\n\n## Pasos para Publicar tu Dashboard\n\n### 1. Preparar el Repositorio Git\n\n```bash\n# Inicializar repositorio (si no existe)\ngit init\n\n# Agregar todos los archivos\ngit add .\n\n# Hacer commit\ngit commit -m \"Dashboard Analytics Ecommerce Global v3.1 listo para deploy\"\n\n# Crear repositorio en GitHub y conectar\ngit remote add origin https://github.com/TU_USUARIO/TU_REPOSITORIO.git\ngit branch -M main\ngit push -u origin main\n```\n\n### 2. Deploy en Streamlit Cloud\n\n1. **Ir a Streamlit Cloud**\n   - Visita: https://share.streamlit.io\n   - Inicia sesión con tu cuenta de GitHub\n\n2. **Crear Nueva App**\n   - Click en \"New app\"\n   - Selecciona tu repositorio de GitHub\n   - Branch: `main`\n   - Main file path: `app.py`\n   - App URL: Elige un nombre único\n\n3. **Configurar (Opcional)**\n   - Python version: 3.11\n   - No requiere secrets para la versión con Parquet\n\n4. **Deploy**\n   - Click en \"Deploy\"\n   - Espera 2-5 minutos mientras se instalan dependencias\n   - ¡Tu dashboard estará en línea!\n\n### 3. URL Final\n\nTu dashboard estará disponible en:\n```\nhttps://TU_NOMBRE_APP.streamlit.app\n```\n\n---\n\n## 📦 Archivos Necesarios (Ya Incluidos)\n\n✅ `app.py` - Dashboard principal  \n✅ `requirements.txt` - Dependencias  \n✅ `.gitignore` - Archivos a ignorar  \n✅ `data/*.parquet` - Datasets (17MB total)  \n✅ `utils/` - Utilidades  \n✅ `api/` - API (opcional)  \n✅ `.streamlit/config.toml` - Configuración\n\n---\n\n## ⚙️ Configuración Avanzada (Opcional)\n\n### Si usas PostgreSQL:\n\n1. En Streamlit Cloud, ve a \"Settings\" → \"Secrets\"\n2. Agrega:\n\n```toml\n[postgresql]\nDATABASE_URL = \"postgresql://usuario:password@host:5432/database\"\n```\n\n3. Modifica `app.py` para usar `st.secrets` en producción\n\n---\n\n## 🔍 Troubleshooting\n\n### Error: \"Module not found\"\n- Verifica que todas las dependencias están en `requirements.txt`\n- Revisa los logs en Streamlit Cloud\n\n### Error: \"Memory limit exceeded\"\n- Los archivos Parquet (17MB) están optimizados\n- Streamlit Cloud tiene 1GB de RAM (suficiente)\n\n### Error: \"File not found\"\n- Verifica que `data/*.parquet` están en el repositorio\n- No uses rutas absolutas, solo relativas\n\n### Dashboard carga lento\n- Normal en primera carga (instala dependencias)\n- Cargas subsecuentes son rápidas (<3 segundos)\n\n---\n\n## 📊 Monitoreo\n\nEn Streamlit Cloud puedes:\n- Ver logs en tiempo real\n- Monitorear uso de recursos\n- Ver analytics de visitantes\n- Configurar dominios personalizados (plan paid)\n\n---\n\n## 🎯 Próximos Pasos\n\n1. Comparte tu URL con clientes/stakeholders\n2. Monitorea analytics y feedback\n3. Actualiza con `git push` (auto-deploy)\n4. Considera upgrade a plan paid para:\n   - Más recursos\n   - Dominio personalizado\n   - Sin límite de visitantes\n\n---\n\n## ✨ Tu Dashboard Está Listo\n\n**Características en Producción:**\n- ✅ 472K transacciones analizadas\n- ✅ 9 pestañas profesionales\n- ✅ ML integrado (Prophet, K-Means)\n- ✅ Visualizaciones optimizadas\n- ✅ 100% en español\n- ✅ Firma CMSR92\n- ✅ Listo para cliente/directivos\n\n**✨ Desarrollado por CMSR92 ✨**\n","size_bytes":3080},"LIMPIEZA_COMPLETADA.md":{"content":"# ✅ Limpieza Completada - Proyecto Listo para Producción\n\n## 🗑️ Archivos Eliminados\n\n### Screenshots Temporales\n- ❌ attached_assets/ - 28 archivos PNG de screenshots\n\n### Archivos de Desarrollo\n- ❌ utils/data_generator.py - Generación de datos sintéticos\n- ❌ utils/unified_data_integration.py - Integración inicial de datos\n- ❌ database/migration_unified.py - Migración inicial BD\n\n### Cache y Temporales\n- ❌ __pycache__/ - Cache de Python\n- ❌ *.pyc - Archivos compilados\n- ❌ /tmp/logs/ - Logs temporales\n\n## 📦 Archivos Finales (Listos para GitHub)\n\n### Core\n✅ app.py (84KB) - Dashboard principal\n✅ requirements.txt - Dependencias\n✅ .gitignore - Configuración Git\n\n### Data\n✅ data/transactions_unified.parquet (17MB)\n✅ data/customers_unified.parquet\n✅ data/products_unified.parquet\n\n### Utilities\n✅ utils/data_loader_pg.py - Carga de datos\n✅ utils/export_utils.py - Exportación de reportes\n✅ utils/filtros.py - Filtros del dashboard\n✅ utils/traducciones.py - Internacionalización\n✅ utils/ui_components.py - Componentes UI\n✅ utils/visualizaciones_avanzadas.py - Visualizaciones\n\n### Documentación\n✅ README.md - Documentación principal\n✅ DEPLOY_STREAMLIT.md - Guía de deploy\n✅ replit.md - Historial técnico\n\n### Opcionales\n✅ api/ - API FastAPI (opcional para Streamlit Cloud)\n✅ database/ - Esquema PostgreSQL (opcional, usa Parquet)\n\n## 📊 Tamaño del Proyecto\n\nTotal útil: ~18MB (perfecto para GitHub/Streamlit Cloud)\n\n## ✨ Estado Final\n\n✅ Dashboard corriendo sin errores\n✅ Archivos temporales eliminados\n✅ Cache limpiado\n✅ .gitignore configurado\n✅ Proyecto optimizado\n✅ Listo para Streamlit Cloud\n\n✨ Desarrollado por CMSR92 ✨\n","size_bytes":1717},"attached_assets/app_1761511711268.py":{"content":"\"\"\"\nDashboard Avanzado de Analytics Ecommerce Global\nAutor: cmsr92\nVersión: 2.0\nPlataforma profesional de Business Intelligence con ML, IA y Análisis Predictivo\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport folium\nfrom streamlit_folium import st_folium\nfrom datetime import datetime, timedelta\nimport warnings\nwarnings.filterwarnings('ignore')\n\nst.set_page_config(\n    page_title=\"Analytics Ecommerce Global | cmsr92\",\n    page_icon=\"📊\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\nfrom utils.ui_components import (\n    aplicar_estilos_globales, crear_header_principal, crear_tarjeta_kpi,\n    crear_seccion_titulo, crear_pie_pagina, mostrar_info_dataset,\n    crear_descripcion_seccion, crear_insight, crear_recomendaciones\n)\nfrom utils.filtros import crear_filtros_sidebar, aplicar_filtros\nfrom utils.data_loader_pg import load_or_generate_data\nfrom utils.traducciones import obtener_labels_profesionales\n\n# Labels profesionales para gráficos\nLABELS = obtener_labels_profesionales()\n\n# Aplicar estilos globales con detección automática de tema del navegador\naplicar_estilos_globales()\n\n@st.cache_data(ttl=60)\ndef cargar_datos():\n    return load_or_generate_data()\n\ntransacciones_df, clientes_df, productos_df = cargar_datos()\n\nif transacciones_df is None or clientes_df is None or productos_df is None:\n    st.error(\"❌ Error al cargar los datos. Por favor recarga la página.\")\n    st.stop()\n\ncrear_header_principal(\n    \"📊 Analytics Ecommerce Global\",\n    \"Plataforma Avanzada de Business Intelligence, Machine Learning y Análisis Predictivo\"\n)\n\nfiltros = crear_filtros_sidebar(transacciones_df)\ndatos_filtrados = aplicar_filtros(transacciones_df, filtros)\n\nif len(datos_filtrados) == 0:\n    st.warning(\"⚠️ No hay datos que coincidan con los filtros seleccionados. Ajusta los criterios de búsqueda.\")\n    st.stop()\n\ntab_overview, tab_geografia, tab_forecasting, tab_productos, tab_clientes, tab_canal, tab_ml, tab_finanzas, tab_operacional = st.tabs([\n    \"🏠 Resumen General\",\n    \"🌍 Análisis Geográfico\",\n    \"📈 Forecasting & Tendencias\",\n    \"📦 Análisis de Productos\",\n    \"👥 Segmentación de Clientes\",\n    \"📱 Análisis de Canal\",\n    \"🤖 ML & IA Insights\",\n    \"💰 Análisis Financiero\",\n    \"⚙️ Métricas Operacionales\"\n])\n\nwith tab_overview:\n    crear_descripcion_seccion(\n        \"Resumen Ejecutivo\",\n        \"Esta sección presenta una visión general del rendimiento del negocio. Los KPIs principales muestran la salud financiera, \"\n        \"el volumen de operaciones y la eficiencia comercial. Utiliza los filtros del sidebar para analizar períodos específicos, \"\n        \"regiones geográficas o segmentos de clientes.\"\n    )\n    \n    crear_seccion_titulo(\"Indicadores Clave de Rendimiento (KPIs)\")\n    \n    # Explicación de KPIs\n    with st.expander(\"ℹ️ ¿Qué significan estos indicadores?\", expanded=False):\n        st.markdown(\"\"\"\n        **💰 Ingresos Totales:** Suma de todas las ventas en el período seleccionado. El símbolo % muestra el cambio respecto al período anterior equivalente.\n        \n        **🛒 Pedidos Totales:** Número total de transacciones completadas. Un aumento indica mayor actividad comercial.\n        \n        **🎯 Ticket Promedio (AOV):** Valor promedio por pedido. Se calcula dividiendo ingresos totales entre número de pedidos. Un AOV alto indica clientes que compran más por transacción.\n        \n        **💎 Beneficio Total:** Ganancia neta después de costos. Se calcula como: Ingresos - Costos. Indica la rentabilidad real del negocio.\n        \n        **👥 Clientes Únicos:** Número de clientes diferentes que realizaron al menos una compra.\n        \n        **📦 Productos Vendidos:** Cantidad de productos distintos que se vendieron en el período.\n        \n        **🎯 Tasa de Conversión:** Porcentaje de clientes únicos respecto al total de pedidos. Una tasa cercana a 100% indica que cada pedido corresponde a un cliente diferente (baja repetición).\n        \n        **📊 Items por Pedido:** Promedio de artículos incluidos en cada transacción. Útil para estrategias de bundling y cross-selling.\n        \"\"\")\n    \n    ingresos_totales = datos_filtrados['total_amount_usd'].sum()\n    pedidos_totales = len(datos_filtrados)\n    ticket_promedio = datos_filtrados['total_amount_usd'].mean()\n    beneficio_total = datos_filtrados['profit'].sum()\n    clientes_unicos = datos_filtrados['customer_id'].nunique()\n    margen_promedio = (beneficio_total / ingresos_totales * 100) if ingresos_totales > 0 else 0\n    \n    fecha_inicio_comparacion = filtros['fecha_inicio'] - (filtros['fecha_fin'] - filtros['fecha_inicio'])\n    datos_periodo_anterior = transacciones_df[\n        (transacciones_df['date'] >= pd.Timestamp(fecha_inicio_comparacion)) & \n        (transacciones_df['date'] < pd.Timestamp(filtros['fecha_inicio']))\n    ]\n    \n    ingresos_anteriores = datos_periodo_anterior['total_amount_usd'].sum()\n    cambio_ingresos = ((ingresos_totales - ingresos_anteriores) / ingresos_anteriores * 100) if ingresos_anteriores > 0 else 0\n    \n    pedidos_anteriores = len(datos_periodo_anterior)\n    cambio_pedidos = ((pedidos_totales - pedidos_anteriores) / pedidos_anteriores * 100) if pedidos_anteriores > 0 else 0\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\n            label=\"💰 Ingresos Totales\",\n            value=f\"${ingresos_totales:,.0f}\",\n            delta=f\"{cambio_ingresos:+.1f}%\" if ingresos_anteriores > 0 else None\n        )\n    \n    with col2:\n        st.metric(\n            label=\"🛒 Pedidos Totales\",\n            value=f\"{pedidos_totales:,}\",\n            delta=f\"{cambio_pedidos:+.1f}%\" if pedidos_anteriores > 0 else None\n        )\n    \n    with col3:\n        st.metric(\n            label=\"🎯 Ticket Promedio (AOV)\",\n            value=f\"${ticket_promedio:,.0f}\"\n        )\n    \n    with col4:\n        st.metric(\n            label=\"💎 Beneficio Total\",\n            value=f\"${beneficio_total:,.0f}\"\n        )\n    \n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    \n    col5, col6, col7, col8 = st.columns(4)\n    \n    with col5:\n        st.metric(\n            label=\"👥 Clientes Únicos\",\n            value=f\"{clientes_unicos:,}\"\n        )\n    \n    with col6:\n        productos_unicos = datos_filtrados['product_id'].nunique()\n        st.metric(\n            label=\"📦 Productos Vendidos\",\n            value=f\"{productos_unicos:,}\"\n        )\n    \n    with col7:\n        tasa_conversion = (clientes_unicos / pedidos_totales * 100) if pedidos_totales > 0 else 0\n        st.metric(\n            label=\"🎯 Tasa de Conversión\",\n            value=f\"{tasa_conversion:.1f}%\"\n        )\n    \n    with col8:\n        items_promedio = datos_filtrados['quantity'].mean()\n        st.metric(\n            label=\"📊 Items por Pedido\",\n            value=f\"{items_promedio:.1f}\"\n        )\n    \n    # Sección de Insights Ejecutivos Automáticos\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    crear_seccion_titulo(\"💡 Insights Ejecutivos y Recomendaciones\")\n    \n    # Calcular métricas adicionales para insights (con protección contra división por cero)\n    if ingresos_totales > 0:\n        top_pais = datos_filtrados.groupby('country')['total_amount_usd'].sum().idxmax()\n        ingresos_top_pais = datos_filtrados.groupby('country')['total_amount_usd'].sum().max()\n        porcentaje_top_pais = (ingresos_top_pais / ingresos_totales * 100)\n        \n        top_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().idxmax()\n        ingresos_top_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().max()\n        porcentaje_top_categoria = (ingresos_top_categoria / ingresos_totales * 100)\n    else:\n        top_pais = \"N/A\"\n        ingresos_top_pais = 0\n        porcentaje_top_pais = 0\n        top_categoria = \"N/A\"\n        ingresos_top_categoria = 0\n        porcentaje_top_categoria = 0\n    \n    # Generar insights automáticos\n    insights_ejecutivos = []\n    \n    # Verificar si hay datos suficientes para generar insights\n    if ingresos_totales == 0 or pedidos_totales == 0:\n        insights_ejecutivos.append(\n            f\"ℹ️ **Sin Datos Disponibles:** No hay transacciones registradas en el período y filtros seleccionados. \"\n            f\"Ajusta los criterios de búsqueda en el sidebar para analizar diferentes períodos o segmentos.\"\n        )\n    else:\n        # Insight 1: Rendimiento general\n        if cambio_ingresos > 10:\n            insights_ejecutivos.append(\n                f\"📈 **Crecimiento Acelerado:** Los ingresos han crecido un {cambio_ingresos:.1f}% comparado con el período anterior, \"\n                f\"superando ${ingresos_totales:,.0f}. Este momentum positivo indica una fuerte demanda y efectividad en las estrategias comerciales.\"\n            )\n        elif cambio_ingresos < -10:\n            insights_ejecutivos.append(\n                f\"⚠️ **Alerta de Desaceleración:** Los ingresos han disminuido un {abs(cambio_ingresos):.1f}% comparado con el período anterior. \"\n                f\"Se recomienda revisar estrategias de marketing, competencia y satisfacción del cliente.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"📊 **Estabilidad Controlada:** Los ingresos se mantienen estables con una variación de {cambio_ingresos:+.1f}% respecto al período anterior, \"\n                f\"totalizando ${ingresos_totales:,.0f}. Existen oportunidades de optimización para impulsar el crecimiento.\"\n            )\n        \n        # Insight 2: Concentración geográfica\n        if porcentaje_top_pais > 50:\n            insights_ejecutivos.append(\n                f\"🌍 **Concentración de Mercado:** {top_pais} representa el {porcentaje_top_pais:.1f}% de los ingresos totales \"\n                f\"(${ingresos_top_pais:,.0f}). Esta alta dependencia presenta riesgo. Se recomienda diversificar geográficamente.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"🌍 **Diversificación Saludable:** {top_pais} lidera con {porcentaje_top_pais:.1f}% de ingresos, pero existe buena \"\n                f\"distribución geográfica, reduciendo el riesgo de dependencia de un solo mercado.\"\n            )\n        \n        # Insight 3: Producto estrella\n        insights_ejecutivos.append(\n            f\"⭐ **Categoría Líder:** {top_categoria} domina el portafolio con {porcentaje_top_categoria:.1f}% de los ingresos \"\n            f\"(${ingresos_top_categoria:,.0f}). Reforzar inventario y marketing en esta categoría puede maximizar resultados.\"\n        )\n        \n        # Insight 4: Eficiencia operativa\n        if ticket_promedio > 100:\n            insights_ejecutivos.append(\n                f\"💎 **Alto Valor por Transacción:** El ticket promedio de ${ticket_promedio:,.0f} indica clientes de alto valor. \"\n                f\"Enfocar estrategias de retención y programas VIP puede aumentar la rentabilidad.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"🎯 **Oportunidad de Upselling:** Con un ticket promedio de ${ticket_promedio:,.0f}, existe potencial para incrementar \"\n                f\"el valor por pedido mediante bundling, recomendaciones personalizadas y ofertas complementarias.\"\n            )\n    \n    # Mostrar insights\n    for insight in insights_ejecutivos:\n        crear_insight(\"\", insight)\n    \n    # Recomendaciones accionables\n    recomendaciones_ejecutivas = [\n        f\"🔍 **Análisis Geográfico:** Explorar la pestaña 'Análisis Geográfico' para identificar mercados emergentes con alto potencial de crecimiento\",\n        f\"📊 **Forecasting:** Revisar las predicciones en 'Forecasting & Tendencias' para planificar inventario y presupuestos de los próximos 90 días\",\n        f\"👥 **Segmentación:** Analizar 'Segmentación de Clientes' para identificar clientes Champions y en riesgo de churn, personalizando estrategias\",\n        f\"🤖 **ML Insights:** Activar análisis ML en el sidebar para detectar anomalías, patrones ocultos y oportunidades de optimización automática\",\n        f\"💰 **Análisis Financiero:** Verificar márgenes y rentabilidad en 'Análisis Financiero' para asegurar la salud del negocio\"\n    ]\n    \n    crear_recomendaciones(\"🎯 Acciones Recomendadas\", recomendaciones_ejecutivas)\n    \n    crear_seccion_titulo(\"Evolución Temporal\")\n    \n    datos_temporales = datos_filtrados.copy()\n    datos_temporales['fecha'] = pd.to_datetime(datos_temporales['date'])\n    datos_temporales_agrupados = datos_temporales.groupby(datos_temporales['fecha'].dt.to_period('M')).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count',\n        'profit': 'sum'\n    }).reset_index()\n    datos_temporales_agrupados['fecha'] = datos_temporales_agrupados['fecha'].dt.to_timestamp()\n    datos_temporales_agrupados.columns = ['Fecha', 'Ingresos', 'Pedidos', 'Beneficio']\n    \n    # Crear figura con eje secundario\n    fig_evolucion = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    # Agregar líneas de ingresos y beneficio en eje principal\n    fig_evolucion.add_trace(\n        go.Scatter(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Ingresos'],\n            name='Ingresos',\n            line=dict(color='#667eea', width=3),\n            mode='lines'\n        ),\n        secondary_y=False\n    )\n    \n    fig_evolucion.add_trace(\n        go.Scatter(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Beneficio'],\n            name='Beneficio',\n            line=dict(color='#10B981', width=2),\n            mode='lines'\n        ),\n        secondary_y=False\n    )\n    \n    # Agregar barras de pedidos en eje secundario\n    fig_evolucion.add_trace(\n        go.Bar(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Pedidos'],\n            name='Pedidos',\n            marker_color='rgba(245, 158, 11, 0.3)',\n            marker_line_color='#F59E0B',\n            marker_line_width=1\n        ),\n        secondary_y=True\n    )\n    \n    # Configurar ejes\n    fig_evolucion.update_yaxes(title_text=\"Ingresos / Beneficio ($)\", secondary_y=False)\n    fig_evolucion.update_yaxes(title_text=\"Pedidos\", secondary_y=True)\n    fig_evolucion.update_xaxes(title_text=\"Fecha\")\n    \n    fig_evolucion.update_layout(\n        title='Evolución Mensual de Ingresos, Beneficio y Pedidos',\n        height=500,\n        showlegend=True,\n        hovermode='x unified',\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font=dict(family='Inter', size=12),\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=1.02,\n            xanchor=\"right\",\n            x=1\n        )\n    )\n    \n    fig_evolucion.update_xaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    fig_evolucion.update_yaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    \n    st.plotly_chart(fig_evolucion, use_container_width=True)\n    \n    crear_seccion_titulo(\"Distribuciones Clave\")\n    \n    col_dist1, col_dist2 = st.columns(2)\n    \n    with col_dist1:\n        top_paises = datos_filtrados.groupby('country')['total_amount_usd'].sum().nlargest(10).reset_index()\n        fig_paises = px.bar(\n            top_paises,\n            x='total_amount_usd',\n            y='country',\n            orientation='h',\n            title='Top 10 Países por Ingresos',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_paises.update_layout(\n            showlegend=False,\n            height=400,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)'\n        )\n        fig_paises.update_traces(hovertemplate='<b>%{y}</b><br>Ingresos: $%{x:,.0f}<extra></extra>')\n        st.plotly_chart(fig_paises, use_container_width=True)\n    \n    with col_dist2:\n        por_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().reset_index()\n        fig_categorias = px.pie(\n            por_categoria,\n            values='total_amount_usd',\n            names='category',\n            title='Distribución de Ingresos por Categoría',\n            color_discrete_sequence=px.colors.qualitative.Set3,\n            hole=0.4\n        )\n        fig_categorias.update_layout(\n            height=400,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)'\n        )\n        fig_categorias.update_traces(\n            textposition='inside', \n            textinfo='percent+label',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<br>Porcentaje: %{percent}<extra></extra>'\n        )\n        st.plotly_chart(fig_categorias, use_container_width=True)\n\nwith tab_geografia:\n    crear_descripcion_seccion(\n        \"Análisis de Distribución Geográfica\",\n        \"Visualiza cómo se distribuyen tus ventas alrededor del mundo. Identifica los mercados más rentables, \"\n        \"países con mayor potencial de crecimiento y oportunidades de expansión internacional. El mapa de calor \"\n        \"muestra la intensidad de ventas por país.\"\n    )\n    \n    crear_seccion_titulo(\"Análisis Geográfico Global\")\n    \n    col1, col2 = st.columns([7, 3])\n    \n    with col1:\n        st.subheader(\"Mapa Mundial de Ventas\")\n        \n        # Mapeo de nombres de países (en español) a códigos ISO 3\n        country_iso_map = {\n            'Reino Unido': 'GBR', 'Estados Unidos': 'USA', 'Alemania': 'DEU', \n            'Francia': 'FRA', 'China': 'CHN', 'Canadá': 'CAN', 'Japón': 'JPN',\n            'Australia': 'AUS', 'España': 'ESP', 'Italia': 'ITA', 'Países Bajos': 'NLD',\n            'Bélgica': 'BEL', 'Suiza': 'CHE', 'Suecia': 'SWE', 'Austria': 'AUT',\n            'Noruega': 'NOR', 'Dinamarca': 'DNK', 'Finlandia': 'FIN', 'Polonia': 'POL',\n            'Portugal': 'PRT', 'Grecia': 'GRC', 'República Checa': 'CZE',\n            'Irlanda': 'IRL', 'Singapur': 'SGP', 'Corea del Sur': 'KOR',\n            'India': 'IND', 'Brasil': 'BRA', 'México': 'MEX', 'Israel': 'ISR',\n            'Arabia Saudita': 'SAU', 'Emiratos Árabes Unidos': 'ARE', 'Sudáfrica': 'ZAF',\n            'Chipre': 'CYP', 'Malta': 'MLT', 'Islandia': 'ISL', 'Lituania': 'LTU',\n            'Baréin': 'BHR', 'Líbano': 'LBN', 'Comunidad Europea': None\n        }\n        \n        datos_pais = datos_filtrados.groupby('country').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count',\n            'customer_id': 'nunique'\n        }).reset_index()\n        datos_pais.columns = ['country', 'ingresos', 'pedidos', 'clientes']\n        datos_pais['aov'] = datos_pais['ingresos'] / datos_pais['pedidos']\n        \n        # Agregar códigos ISO\n        datos_pais['iso_code'] = datos_pais['country'].map(country_iso_map)\n        # Filtrar países sin código ISO válido\n        datos_pais_validos = datos_pais[datos_pais['iso_code'].notna()].copy()\n        \n        fig_mapa = px.choropleth(\n            datos_pais_validos,\n            locations='iso_code',\n            locationmode='ISO-3',\n            color='ingresos',\n            hover_name='country',\n            hover_data={\n                'iso_code': False,\n                'ingresos': ':$,.0f',\n                'pedidos': ':,',\n                'clientes': ':,',\n                'aov': ':$,.2f'\n            },\n            color_continuous_scale='Viridis',\n            title='Ingresos por País',\n            labels={'ingresos': 'Ingresos', 'pedidos': 'Pedidos', 'clientes': 'Clientes', 'aov': 'Ticket Promedio'}\n        )\n        fig_mapa.update_layout(\n            height=500, \n            margin=dict(l=0, r=0, t=30, b=0),\n            geo=dict(showframe=False, showcoastlines=True, projection_type='natural earth')\n        )\n        st.plotly_chart(fig_mapa, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Top 15 Países\")\n        top_paises = datos_pais.nlargest(15, 'ingresos')\n        \n        fig_top = px.bar(\n            top_paises,\n            y='country',\n            x='ingresos',\n            orientation='h',\n            color='ingresos',\n            color_continuous_scale='Blues',\n            title='Ingresos por País (Top 15)',\n            labels=LABELS\n        )\n        fig_top.update_traces(hovertemplate='<b>%{y}</b><br>Ingresos: $%{x:,.0f}<extra></extra>')\n        fig_top.update_layout(\n            height=500,\n            showlegend=False,\n            yaxis={'categoryorder': 'total ascending'}\n        )\n        st.plotly_chart(fig_top, use_container_width=True)\n    \n    col3, col4 = st.columns(2)\n    \n    with col3:\n        st.subheader(\"Jerarquía Geográfica (Treemap)\")\n        \n        datos_tree_geo = datos_filtrados.groupby(['country', 'category']).agg({\n            'total_amount_usd': 'sum'\n        }).reset_index()\n        datos_tree_geo.rename(columns={'total_amount_usd': 'ingresos'}, inplace=True)\n        \n        fig_tree = px.treemap(\n            datos_tree_geo,\n            path=['country', 'category'],\n            values='ingresos',\n            color='ingresos',\n            color_continuous_scale='RdYlGn',\n            title='Jerarquía: País → Categoría'\n        )\n        \n        fig_tree.update_traces(\n            textinfo='label+value',\n            texttemplate='<b>%{label}</b><br>$%{value:,.0f}',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<extra></extra>'\n        )\n        \n        fig_tree.update_layout(height=400)\n        st.plotly_chart(fig_tree, use_container_width=True)\n    \n    with col4:\n        st.subheader(\"Concentración de Ventas\")\n        top10_paises = datos_pais.nlargest(10, 'ingresos')\n        otros_ingresos = datos_pais[~datos_pais['country'].isin(top10_paises['country'])]['ingresos'].sum()\n        \n        if otros_ingresos > 0:\n            otros_df = pd.DataFrame({'country': ['Otros'], 'ingresos': [otros_ingresos]})\n            datos_pie = pd.concat([top10_paises[['country', 'ingresos']], otros_df])\n        else:\n            datos_pie = top10_paises[['country', 'ingresos']]\n        \n        fig_pie = px.pie(\n            datos_pie,\n            values='ingresos',\n            names='country',\n            title='Distribución de Ingresos (Top 10 + Otros)',\n            hole=0.4\n        )\n        fig_pie.update_traces(hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<br>Porcentaje: %{percent}<extra></extra>')\n        fig_pie.update_layout(height=400)\n        st.plotly_chart(fig_pie, use_container_width=True)\n\nwith tab_forecasting:\n    crear_descripcion_seccion(\n        \"Predicción de Ventas Futuras con Machine Learning\",\n        \"Utiliza el modelo Prophet de Meta (Facebook) para predecir tus ventas de los próximos 90 días. \"\n        \"Las bandas de confianza muestran el rango probable de variación. Esta información te ayuda a planificar \"\n        \"inventario, presupuestos y recursos operativos con anticipación.\"\n    )\n    \n    crear_seccion_titulo(\"Forecasting y Análisis de Tendencias\")\n    \n    st.subheader(\"Ingresos y Pedidos a lo Largo del Tiempo\")\n    \n    granularidad = st.selectbox(\n        \"Granularidad Temporal\",\n        ['Día', 'Semana', 'Mes'],\n        index=1,\n        help=\"Selecciona el nivel de agregación temporal para el análisis\"\n    )\n    \n    temp_df = datos_filtrados.copy()\n    if granularidad == 'Día':\n        temp_df['periodo'] = temp_df['date'].dt.date\n    elif granularidad == 'Semana':\n        temp_df['periodo'] = temp_df['date'].dt.to_period('W').dt.start_time\n    else:\n        temp_df['periodo'] = temp_df['date'].dt.to_period('M').dt.start_time\n    \n    serie_temporal = temp_df.groupby('periodo').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    serie_temporal.columns = ['periodo', 'ingresos', 'pedidos']\n    \n    fig_tiempo = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    fig_tiempo.add_trace(\n        go.Bar(x=serie_temporal['periodo'], y=serie_temporal['ingresos'], name='Ingresos', marker_color='#667eea'),\n        secondary_y=False\n    )\n    \n    fig_tiempo.add_trace(\n        go.Scatter(x=serie_temporal['periodo'], y=serie_temporal['pedidos'], name='Pedidos', \n                   line=dict(color='#f093fb', width=3), mode='lines+markers'),\n        secondary_y=True\n    )\n    \n    fig_tiempo.update_xaxes(title_text=\"Fecha\")\n    fig_tiempo.update_yaxes(title_text=\"Ingresos ($)\", secondary_y=False)\n    fig_tiempo.update_yaxes(title_text=\"Pedidos\", secondary_y=True)\n    fig_tiempo.update_layout(height=400, title='Evolución de Ingresos y Pedidos')\n    \n    st.plotly_chart(fig_tiempo, use_container_width=True)\n    \n    if filtros.get('mostrar_ml') and len(serie_temporal) > 10:\n        st.subheader(\"🔮 Forecasting 90 Días (Prophet)\")\n        \n        st.info(\n            \"📊 **¿Qué proyecta este modelo?** Este gráfico muestra la predicción de **INGRESOS TOTALES** de tu negocio \"\n            f\"para los próximos 90 días, agregados por **{granularidad.lower()}**. \"\n            \"La línea verde es la predicción basada en patrones históricos, y la banda sombreada muestra el rango de confianza del 95%. \"\n            \"El modelo detecta automáticamente tendencias, estacionalidad semanal, mensual y anual en tus ventas.\"\n        )\n        \n        try:\n            from prophet import Prophet\n            \n            prophet_df = serie_temporal[['periodo', 'ingresos']].copy()\n            prophet_df.columns = ['ds', 'y']\n            # Asegurar conversión correcta a datetime\n            prophet_df['ds'] = pd.to_datetime(prophet_df['ds'].astype(str))\n            \n            with st.spinner('Entrenando modelo Prophet...'):\n                modelo = Prophet(\n                    daily_seasonality=False,\n                    weekly_seasonality=True,\n                    yearly_seasonality=True,\n                    seasonality_mode='multiplicative',\n                    changepoint_prior_scale=0.05,\n                    seasonality_prior_scale=10,\n                    interval_width=0.95\n                )\n                # Agregar estacionalidad mensual\n                modelo.add_seasonality(name='monthly', period=30.5, fourier_order=5)\n                modelo.fit(prophet_df, algorithm='LBFGS')\n                \n                futuro = modelo.make_future_dataframe(periods=90)\n                forecast = modelo.predict(futuro)\n            \n            col1, col2 = st.columns([7, 3])\n            \n            with col1:\n                fig_forecast = go.Figure()\n                \n                # Separar datos históricos y proyección\n                ultima_fecha_historica = prophet_df['ds'].max()\n                forecast_futuro = forecast[forecast['ds'] > ultima_fecha_historica]\n                forecast_historico = forecast[forecast['ds'] <= ultima_fecha_historica]\n                \n                # Datos históricos (puntos azules)\n                fig_forecast.add_trace(go.Scatter(\n                    x=prophet_df['ds'],\n                    y=prophet_df['y'],\n                    mode='markers',\n                    name='Datos Históricos',\n                    marker=dict(color='#667eea', size=8, opacity=0.6),\n                    hovertemplate='<b>Histórico</b><br>Fecha: %{x}<br>Ingresos: $%{y:,.0f}<extra></extra>'\n                ))\n                \n                # Línea de ajuste histórico (gris claro)\n                fig_forecast.add_trace(go.Scatter(\n                    x=forecast_historico['ds'],\n                    y=forecast_historico['yhat'],\n                    mode='lines',\n                    name='Ajuste Histórico',\n                    line=dict(color='rgba(100, 100, 100, 0.3)', width=2, dash='dot'),\n                    showlegend=True\n                ))\n                \n                # PROYECCIÓN FUTURA (verde brillante)\n                fig_forecast.add_trace(go.Scatter(\n                    x=forecast_futuro['ds'],\n                    y=forecast_futuro['yhat'],\n                    mode='lines+markers',\n                    name='Proyección (90 días)',\n                    line=dict(color='#10B981', width=4),\n                    marker=dict(size=6),\n                    hovertemplate='<b>Proyección</b><br>Fecha: %{x}<br>Ingresos: $%{y:,.0f}<extra></extra>'\n                ))\n                \n                # Banda de confianza SOLO para proyección futura\n                fig_forecast.add_trace(go.Scatter(\n                    x=forecast_futuro['ds'],\n                    y=forecast_futuro['yhat_upper'],\n                    fill=None,\n                    mode='lines',\n                    line_color='rgba(16, 185, 129, 0)',\n                    showlegend=False,\n                    hoverinfo='skip'\n                ))\n                \n                fig_forecast.add_trace(go.Scatter(\n                    x=forecast_futuro['ds'],\n                    y=forecast_futuro['yhat_lower'],\n                    fill='tonexty',\n                    mode='lines',\n                    line_color='rgba(16, 185, 129, 0)',\n                    fillcolor='rgba(16, 185, 129, 0.2)',\n                    name='Intervalo Confianza 95%',\n                    hovertemplate='<b>Intervalo de Confianza</b><br>Superior: %{y:,.0f}<extra></extra>'\n                ))\n                \n                # Línea vertical separando histórico de proyección\n                fig_forecast.add_vline(\n                    x=ultima_fecha_historica, \n                    line_dash=\"dash\", \n                    line_color=\"orange\",\n                    line_width=2,\n                    annotation_text=\"← Histórico | Proyección →\",\n                    annotation_position=\"top\"\n                )\n                \n                fig_forecast.update_layout(\n                    title='Predicción de Ingresos: Histórico vs Proyección (90 días)',\n                    xaxis_title='Fecha',\n                    yaxis_title='Ingresos (USD)',\n                    height=500,\n                    hovermode='x unified',\n                    legend=dict(\n                        orientation=\"h\",\n                        yanchor=\"bottom\",\n                        y=1.02,\n                        xanchor=\"right\",\n                        x=1\n                    )\n                )\n                st.plotly_chart(fig_forecast, use_container_width=True)\n            \n            with col2:\n                ingresos_predichos = forecast[forecast['ds'] > prophet_df['ds'].max()]['yhat'].sum()\n                st.metric(\"Ingresos Predichos (90 días)\", f\"${ingresos_predichos:,.0f}\")\n                \n                y_actual = prophet_df['y'].values\n                y_pred = forecast.iloc[:len(prophet_df)]['yhat'].values\n                mask = y_actual != 0\n                if mask.sum() > 0:\n                    mape = np.mean(np.abs((y_actual[mask] - y_pred[mask]) / y_actual[mask])) * 100\n                    st.metric(\"MAPE (Error %)\", f\"{mape:.2f}%\")\n                else:\n                    st.metric(\"MAPE (Error %)\", \"N/A\")\n                \n                st.markdown(\"**Componentes del Modelo:**\")\n                st.write(f\"- Tendencia detectada\")\n                st.write(f\"- Estacionalidad anual\")\n                st.write(f\"- Estacionalidad semanal\")\n                \n        except Exception as e:\n            st.warning(f\"No se pudo generar forecast: {str(e)}\")\n    \n    col_dist1, col_dist2 = st.columns(2)\n    \n    with col_dist1:\n        st.subheader(\"Distribución de Ingresos por Día de Semana\")\n        from utils.traducciones import traducir_dia_semana\n        temp_df['dia_semana'] = pd.to_datetime(temp_df['date']).dt.day_name()\n        ingresos_dia = temp_df.groupby('dia_semana')['total_amount_usd'].sum().reset_index()\n        dias_orden = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        ingresos_dia['dia_semana'] = pd.Categorical(ingresos_dia['dia_semana'], categories=dias_orden, ordered=True)\n        ingresos_dia = ingresos_dia.sort_values('dia_semana')\n        # Traducir días al español\n        ingresos_dia['dia_semana_es'] = ingresos_dia['dia_semana'].apply(traducir_dia_semana)\n        \n        fig_dias = px.bar(\n            ingresos_dia,\n            x='dia_semana_es',\n            y='total_amount_usd',\n            title='Ingresos por Día de la Semana',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_dias.update_layout(height=400, showlegend=False)\n        fig_dias.update_traces(hovertemplate='<b>%{x}</b><br>Ingresos: $%{y:,.0f}<extra></extra>')\n        st.plotly_chart(fig_dias, use_container_width=True)\n    \n    with col_dist2:\n        st.subheader(\"Distribución de Ingresos por Hora\")\n        temp_df['hora'] = pd.to_datetime(temp_df['date']).dt.hour\n        ingresos_hora = temp_df.groupby('hora')['total_amount_usd'].sum().reset_index()\n        \n        fig_horas = px.line(\n            ingresos_hora,\n            x='hora',\n            y='total_amount_usd',\n            title='Ingresos por Hora del Día',\n            labels=LABELS,\n            markers=True\n        )\n        fig_horas.update_traces(\n            line_color='#F59E0B', \n            line_width=3,\n            hovertemplate='<b>Hora %{x}:00</b><br>Ingresos: $%{y:,.0f}<extra></extra>'\n        )\n        fig_horas.update_layout(height=400)\n        st.plotly_chart(fig_horas, use_container_width=True)\n\nwith tab_productos:\n    crear_descripcion_seccion(\n        \"Rendimiento y Estrategia de Productos\",\n        \"Analiza qué productos generan más ingresos, cuáles tienen mejor margen y cómo se distribuyen por categorías. \"\n        \"La Matriz BCG clasifica tus productos en: **Alto Rendimiento** (altos ingresos, alta frecuencia), **Consolidados** (altos ingresos, frecuencia media), \"\n        \"**Alto Potencial** (potencial de crecimiento) y **En Evaluación** (requieren optimización o descontinuación).\"\n    )\n    \n    crear_seccion_titulo(\"Análisis de Productos\")\n    \n    st.subheader(\"Top 20 Productos por Ingresos\")\n    \n    # Filtrar productos no significativos (costos de envío, productos genéricos)\n    productos_excluir = ['Manual', 'POSTAGE', 'DOTCOM POSTAGE', 'Adjust bad debt', 'BANK CHARGES']\n    datos_productos_reales = datos_filtrados[~datos_filtrados['product_name'].isin(productos_excluir)]\n    \n    top_productos = datos_productos_reales.groupby(['product_id', 'product_name', 'category']).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count',\n        'quantity': 'sum',\n        'profit': 'sum'\n    }).reset_index().nlargest(20, 'total_amount_usd')\n    \n    fig_productos = px.bar(\n        top_productos,\n        x='total_amount_usd',\n        y='product_name',\n        orientation='h',\n        title='Top 20 Productos por Ingresos (excl. envíos)',\n        labels=LABELS,\n        color='category',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['category', 'profit']\n    )\n    fig_productos.update_traces(hovertemplate='<b>%{y}</b><br>Categoría: %{customdata[0]}<br>Ingresos: $%{x:,.0f}<br>Beneficio: $%{customdata[1]:,.0f}<extra></extra>')\n    fig_productos.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_productos, use_container_width=True)\n    \n    st.subheader(\"Top 15 Productos Más Comprados\")\n    \n    top_comprados = datos_productos_reales.groupby(['product_id', 'product_name', 'category']).agg({\n        'quantity': 'sum',\n        'transaction_id': 'count',\n        'total_amount_usd': 'sum'\n    }).reset_index().nlargest(15, 'quantity')\n    \n    fig_comprados = px.bar(\n        top_comprados,\n        x='quantity',\n        y='product_name',\n        orientation='h',\n        title='Top 15 Productos por Unidades Vendidas (excl. envíos)',\n        labels=LABELS,\n        color='category',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['category', 'transaction_id']\n    )\n    fig_comprados.update_traces(hovertemplate='<b>%{y}</b><br>Categoría: %{customdata[0]}<br>Unidades: %{x:,.0f}<br>Transacciones: %{customdata[1]:,.0f}<extra></extra>')\n    fig_comprados.update_layout(height=450, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_comprados, use_container_width=True)\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Ingresos por Categoría (Treemap)\")\n        datos_categoria = datos_filtrados.groupby(['category', 'subcategory']).agg({\n            'total_amount_usd': 'sum'\n        }).reset_index()\n        \n        fig_tree_cat = px.treemap(\n            datos_categoria,\n            path=['category', 'subcategory'],\n            values='total_amount_usd',\n            title='Jerarquía de Categorías',\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        \n        fig_tree_cat.update_traces(\n            textinfo='label+value',\n            texttemplate='<b>%{label}</b><br>$%{value:,.0f}',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<extra></extra>'\n        )\n        \n        fig_tree_cat.update_layout(height=400)\n        st.plotly_chart(fig_tree_cat, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Margen por Categoría\")\n        margen_cat = datos_filtrados.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        margen_cat['margen_%'] = (margen_cat['profit'] / margen_cat['total_amount_usd'] * 100)\n        \n        fig_margen = px.bar(\n            margen_cat.sort_values('margen_%', ascending=False),\n            x='category',\n            y='margen_%',\n            title='Margen de Beneficio por Categoría (%)',\n            labels=LABELS,\n            color='margen_%',\n            color_continuous_scale='RdYlGn'\n        )\n        fig_margen.update_traces(hovertemplate='<b>%{x}</b><br>Margen: %{y:.1f}%<extra></extra>')\n        fig_margen.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_margen, use_container_width=True)\n    \n    st.subheader(\"Análisis de Performance de Productos (Matriz BCG)\")\n    \n    # Usar los mismos datos filtrados (productos reales, sin envíos)\n    productos_bcg = datos_productos_reales.groupby(['product_id', 'product_name']).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    productos_bcg.columns = ['product_id', 'producto', 'ingresos', 'frecuencia']\n    productos_bcg['ingresos_formato'] = productos_bcg['ingresos'].apply(lambda x: f\"${x:,.0f}\")\n    \n    mediana_ingresos = productos_bcg['ingresos'].median()\n    mediana_frecuencia = productos_bcg['frecuencia'].median()\n    \n    def clasificar_bcg(row):\n        if row['ingresos'] >= mediana_ingresos and row['frecuencia'] >= mediana_frecuencia:\n            return 'Alto Rendimiento'\n        elif row['ingresos'] >= mediana_ingresos and row['frecuencia'] < mediana_frecuencia:\n            return 'Alto Potencial'\n        elif row['ingresos'] < mediana_ingresos and row['frecuencia'] >= mediana_frecuencia:\n            return 'Consolidados'\n        else:\n            return 'En Evaluación'\n    \n    productos_bcg['cuadrante'] = productos_bcg.apply(clasificar_bcg, axis=1)\n    \n    # Mejorar visualización: usar escala logarítmica y tamaños más uniformes\n    productos_bcg_muestra = productos_bcg.sample(min(500, len(productos_bcg)))\n    \n    # Añadir tamaño normalizado para mejor visualización\n    productos_bcg_muestra['size_viz'] = np.log1p(productos_bcg_muestra['ingresos']) * 10\n    \n    fig_bcg = px.scatter(\n        productos_bcg_muestra,\n        x='frecuencia',\n        y='ingresos',\n        color='cuadrante',\n        size='size_viz',\n        hover_data={'producto': True, 'ingresos_formato': True, 'frecuencia': True, 'ingresos': False, 'cuadrante': False, 'size_viz': False},\n        title='Matriz BCG de Productos',\n        labels=LABELS,\n        color_discrete_map={\n            'Alto Rendimiento': '#10B981',\n            'Consolidados': '#3B82F6',\n            'Alto Potencial': '#F59E0B',\n            'En Evaluación': '#EF4444'\n        },\n        log_y=True\n    )\n    \n    fig_bcg.update_traces(\n        hovertemplate='<b>%{customdata[0]}</b><br>Ingresos: %{customdata[1]}<br>Frecuencia: %{customdata[2]} pedidos<extra></extra>',\n        marker=dict(\n            line=dict(width=1, color='white'),\n            opacity=0.7\n        )\n    )\n    \n    fig_bcg.add_hline(y=mediana_ingresos, line_dash=\"dash\", line_color=\"white\", line_width=2, annotation_text=\"Mediana Ingresos\", annotation_position=\"right\")\n    fig_bcg.add_vline(x=mediana_frecuencia, line_dash=\"dash\", line_color=\"white\", line_width=2, annotation_text=\"Mediana Frecuencia\", annotation_position=\"top\")\n    fig_bcg.update_layout(\n        height=550,\n        yaxis_title=\"Ingresos (USD) - Escala Logarítmica\",\n        xaxis_title=\"Frecuencia de Compra (pedidos)\",\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"right\",\n            x=0.99\n        )\n    )\n    st.plotly_chart(fig_bcg, use_container_width=True)\n    \n    col_resumen = st.columns(4)\n    for idx, cuadrante in enumerate(['Alto Rendimiento', 'Consolidados', 'Alto Potencial', 'En Evaluación']):\n        with col_resumen[idx]:\n            count = len(productos_bcg[productos_bcg['cuadrante'] == cuadrante])\n            st.metric(cuadrante, f\"{count} productos\")\n\nwith tab_clientes:\n    crear_descripcion_seccion(\n        \"Conoce a Tus Clientes en Profundidad\",\n        \"Esta sección te permite entender quiénes son tus mejores clientes, cuáles están en riesgo de abandonar y cómo puedes \"\n        \"personalizar tu estrategia para cada segmento. El análisis RFM evalúa cuán recientemente compraron, con qué frecuencia \"\n        \"y cuánto gastan, clasificándolos en 11 segmentos desde Campeones hasta Perdidos.\"\n    )\n    \n    crear_seccion_titulo(\"Segmentación de Clientes\")\n    \n    st.subheader(\"Análisis RFM (Recencia, Frecuencia, Monetario)\")\n    \n    clientes_filt = clientes_df[clientes_df['customer_id'].isin(datos_filtrados['customer_id'].unique())]\n    \n    rfm_segments = clientes_filt['rfm_segment'].value_counts().reset_index()\n    rfm_segments.columns = ['segmento', 'cantidad']\n    \n    col1, col2 = st.columns([6, 4])\n    \n    with col1:\n        fig_rfm = px.bar(\n            rfm_segments.sort_values('cantidad', ascending=False),\n            x='segmento',\n            y='cantidad',\n            title='Distribución de Clientes por Segmento RFM',\n            labels=LABELS,\n            color='cantidad',\n            color_continuous_scale='Viridis'\n        )\n        fig_rfm.update_traces(hovertemplate='<b>%{x}</b><br>Clientes: %{y:,}<extra></extra>')\n        fig_rfm.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_rfm, use_container_width=True)\n    \n    with col2:\n        fig_rfm_pie = px.pie(\n            rfm_segments,\n            values='cantidad',\n            names='segmento',\n            title='Proporción de Segmentos',\n            hole=0.4\n        )\n        fig_rfm_pie.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_rfm_pie.update_layout(height=400)\n        st.plotly_chart(fig_rfm_pie, use_container_width=True)\n    \n    st.subheader(\"Valor de Vida del Cliente (LTV)\")\n    \n    col_ltv1, col_ltv2, col_ltv3 = st.columns(3)\n    \n    with col_ltv1:\n        st.metric(\"LTV Promedio\", f\"${clientes_filt['lifetime_value'].mean():,.0f}\")\n    with col_ltv2:\n        st.metric(\"LTV Mediana\", f\"${clientes_filt['lifetime_value'].median():,.0f}\")\n    with col_ltv3:\n        st.metric(\"LTV Máximo\", f\"${clientes_filt['lifetime_value'].max():,.0f}\")\n    \n    fig_ltv_dist = px.histogram(\n        clientes_filt,\n        x='lifetime_value',\n        nbins=50,\n        title='Distribución del Valor de Vida del Cliente',\n        labels=LABELS,\n        color_discrete_sequence=['#667eea']\n    )\n    fig_ltv_dist.update_traces(hovertemplate='LTV: $%{x:,.0f}<br>Clientes: %{y:,}<extra></extra>')\n    fig_ltv_dist.update_layout(height=400, showlegend=False)\n    st.plotly_chart(fig_ltv_dist, use_container_width=True)\n    \n    if filtros.get('mostrar_ml') and len(datos_filtrados) > 100:\n        crear_seccion_titulo(\"Segmentación Inteligente de Clientes (K-Means)\")\n        \n        crear_descripcion_seccion(\n            \"¿Qué es el Clustering K-Means?\",\n            \"El clustering K-Means es una técnica de machine learning que agrupa automáticamente a tus clientes en segmentos \"\n            \"con comportamientos similares. Analiza la Recencia (cuándo compraron por última vez), Frecuencia (cuántas veces compran) \"\n            \"y Valor Monetario (cuánto gastan). Esta segmentación permite personalizar estrategias de marketing y ventas para cada grupo.\"\n        )\n        \n        try:\n            from sklearn.cluster import KMeans\n            from sklearn.preprocessing import StandardScaler\n            \n            fecha_analisis = datos_filtrados['date'].max()\n            \n            rfm_data = datos_filtrados.groupby('customer_id').agg({\n                'date': lambda x: (fecha_analisis - x.max()).days,\n                'transaction_id': 'count',\n                'total_amount_usd': 'sum'\n            }).reset_index()\n            rfm_data.columns = ['customer_id', 'recency', 'frequency', 'monetary']\n            \n            rfm_data = rfm_data.merge(\n                clientes_df[['customer_id', 'lifetime_value']], \n                on='customer_id', \n                how='left'\n            )\n            \n            features_clustering = rfm_data[['recency', 'frequency', 'monetary', 'lifetime_value']].fillna(0)\n            \n            if len(features_clustering) > 10:\n                scaler = StandardScaler()\n                features_scaled = scaler.fit_transform(features_clustering)\n                \n                kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)\n                clusters = kmeans.fit_predict(features_scaled)\n                \n                rfm_data['cluster'] = clusters\n                rfm_data['cluster_nombre'] = rfm_data['cluster'].map({\n                    0: 'Premium',\n                    1: 'Activo',\n                    2: 'En Riesgo',\n                    3: 'Inactivo'\n                })\n                \n                muestra_viz = rfm_data.sample(min(1000, len(rfm_data)))\n                \n                fig_clusters = px.scatter_3d(\n                    muestra_viz,\n                    x='recency',\n                    y='frequency',\n                    z='monetary',\n                    color='cluster_nombre',\n                    title='Visualización 3D de Segmentos de Clientes',\n                    labels={\n                        'recency': 'Días desde Última Compra',\n                        'frequency': 'Número de Compras',\n                        'monetary': 'Gasto Total (USD)',\n                        'cluster_nombre': 'Segmento'\n                    },\n                    color_discrete_map={\n                        'Premium': '#10B981',\n                        'Activo': '#3B82F6',\n                        'En Riesgo': '#F59E0B',\n                        'Inactivo': '#EF4444'\n                    },\n                    height=600\n                )\n                \n                fig_clusters.update_traces(\n                    marker=dict(size=5, opacity=0.7)\n                )\n                \n                st.plotly_chart(fig_clusters, use_container_width=True)\n                \n                col_cluster = st.columns(4)\n                cluster_counts = {}\n                for i, nombre in enumerate(['Premium', 'Activo', 'En Riesgo', 'Inactivo']):\n                    cluster_counts[nombre] = len(rfm_data[rfm_data['cluster'] == i])\n                    with col_cluster[i]:\n                        count_cluster = cluster_counts[nombre]\n                        pct_cluster = (count_cluster / len(rfm_data) * 100)\n                        st.metric(\n                            f\"🎯 {nombre}\",\n                            f\"{count_cluster:,}\",\n                            delta=f\"{pct_cluster:.1f}%\"\n                        )\n                \n                # Calcular promedios por cluster para insights\n                cluster_stats = rfm_data.groupby('cluster_nombre').agg({\n                    'recency': 'mean',\n                    'frequency': 'mean',\n                    'monetary': 'mean'\n                }).round(0)\n                \n                # Insights por segmento\n                st.markdown(\"### 📊 Características de Cada Segmento\")\n                \n                col_desc1, col_desc2 = st.columns(2)\n                \n                with col_desc1:\n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #10B981 0%, #059669 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>💎 Clientes Premium</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Tus mejores clientes. Compran frecuentemente, con alto valor y recientemente activos.<br>\n                            <strong>Características:</strong> Baja recencia, alta frecuencia, alto gasto.<br>\n                            <strong>Prioridad:</strong> MUY ALTA - Son el motor del negocio.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                    \n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>⚠️ Clientes En Riesgo</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Clientes valiosos que están perdiendo actividad. Pueden abandonar pronto.<br>\n                            <strong>Características:</strong> Recencia media-alta, frecuencia decreciente.<br>\n                            <strong>Prioridad:</strong> ALTA - Requieren reactivación urgente.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col_desc2:\n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>✅ Clientes Activos</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Clientes regulares y consistentes, aunque no son los de mayor gasto.<br>\n                            <strong>Características:</strong> Baja-media recencia, frecuencia media, gasto moderado.<br>\n                            <strong>Prioridad:</strong> MEDIA - Potencial para convertirse en Premium.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                    \n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>😴 Clientes Inactivos</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> No han comprado recientemente. Pueden estar perdidos.<br>\n                            <strong>Características:</strong> Alta recencia, baja frecuencia, bajo gasto.<br>\n                            <strong>Prioridad:</strong> BAJA - Evaluar costo de reactivación.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                # Recomendaciones específicas por cluster\n                recomendaciones_clustering = [\n                    f\"<strong>Premium ({cluster_counts['Premium']:,} clientes):</strong> Programa VIP exclusivo, acceso anticipado a nuevos productos, atención personalizada\",\n                    f\"<strong>Activos ({cluster_counts['Activo']:,} clientes):</strong> Ofertas de up-selling/cross-selling, programa de referidos, incentivos por mayor gasto\",\n                    f\"<strong>En Riesgo ({cluster_counts['En Riesgo']:,} clientes):</strong> Campañas de win-back con descuentos especiales, encuestas de satisfacción, emails personalizados\",\n                    f\"<strong>Inactivos ({cluster_counts['Inactivo']:,} clientes):</strong> Campañas de reactivación masiva, ofertas agresivas de reenganche, limpiar base de datos si el costo es muy alto\"\n                ]\n                \n                crear_recomendaciones(\"Estrategias por Segmento de Clientes\", recomendaciones_clustering)\n                \n            else:\n                st.info(\"Se requieren al menos 10 clientes para generar el clustering. Ajusta los filtros para incluir más datos.\")\n                \n        except Exception as e:\n            st.error(f\"❌ Error al generar la segmentación: {str(e)}\")\n            st.info(\"💡 Consejo: Intenta ajustar los filtros del sidebar para incluir más clientes o un período de tiempo más amplio.\")\n    \n    crear_seccion_titulo(\"Análisis de Riesgo de Abandono (Churn)\")\n    \n    crear_descripcion_seccion(\n        \"¿Qué es el Riesgo de Churn?\",\n        \"El riesgo de churn (abandono) mide la probabilidad de que un cliente deje de comprar en tu negocio. \"\n        \"Este análisis identifica clientes en riesgo para permitir acciones preventivas. Un churn alto (>70%) indica \"\n        \"clientes que probablemente no volverán, medio (40-70%) requiere atención, y bajo (<40%) son clientes estables.\"\n    )\n    \n    col_churn1, col_churn2 = st.columns([6, 4])\n    \n    with col_churn1:\n        fig_churn = px.histogram(\n            clientes_filt,\n            x='churn_probability',\n            nbins=30,\n            title='Distribución de Probabilidad de Churn',\n            labels=LABELS,\n            color_discrete_sequence=['#EF4444']\n        )\n        fig_churn.update_traces(hovertemplate='<b>Probabilidad de Churn:</b> %{x:.1%}<br><b>Cantidad:</b> %{y:,} clientes<extra></extra>')\n        fig_churn.update_layout(\n            height=400,\n            xaxis_title=\"Probabilidad de Abandono\",\n            yaxis_title=\"Cantidad de Clientes\"\n        )\n        st.plotly_chart(fig_churn, use_container_width=True)\n    \n    with col_churn2:\n        churn_alto = len(clientes_filt[clientes_filt['churn_probability'] > 0.7])\n        churn_medio = len(clientes_filt[(clientes_filt['churn_probability'] > 0.4) & (clientes_filt['churn_probability'] <= 0.7)])\n        churn_bajo = len(clientes_filt[clientes_filt['churn_probability'] <= 0.4])\n        \n        churn_data = pd.DataFrame({\n            'riesgo': ['Alto (>70%)', 'Medio (40-70%)', 'Bajo (<40%)'],\n            'cantidad': [churn_alto, churn_medio, churn_bajo]\n        })\n        \n        fig_churn_pie = px.pie(\n            churn_data,\n            values='cantidad',\n            names='riesgo',\n            title='Clasificación de Riesgo de Churn',\n            color='riesgo',\n            color_discrete_map={'Alto (>70%)': '#EF4444', 'Medio (40-70%)': '#F59E0B', 'Bajo (<40%)': '#10B981'}\n        )\n        fig_churn_pie.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_churn_pie.update_layout(height=400)\n        st.plotly_chart(fig_churn_pie, use_container_width=True)\n    \n    # Insights accionables\n    total_clientes_analisis = len(clientes_filt)\n    porcentaje_alto = (churn_alto / total_clientes_analisis * 100) if total_clientes_analisis > 0 else 0\n    porcentaje_medio = (churn_medio / total_clientes_analisis * 100) if total_clientes_analisis > 0 else 0\n    \n    crear_insight(\n        \"Hallazgo Clave\",\n        f\"De {total_clientes_analisis:,} clientes analizados, {churn_alto:,} ({porcentaje_alto:.1f}%) tienen riesgo ALTO de abandono \"\n        f\"y {churn_medio:,} ({porcentaje_medio:.1f}%) tienen riesgo MEDIO. Estos {churn_alto + churn_medio:,} clientes requieren \"\n        \"atención inmediata para evitar pérdida de ingresos.\"\n    )\n    \n    # Recomendaciones específicas\n    recomendaciones_churn = [\n        f\"<strong>Prioridad Crítica:</strong> Contactar a los {churn_alto:,} clientes de riesgo ALTO con ofertas personalizadas o descuentos exclusivos\",\n        \"<strong>Programas de Fidelización:</strong> Implementar un programa de puntos o beneficios para clientes de riesgo MEDIO\",\n        \"<strong>Email Marketing:</strong> Enviar campañas de reactivación con productos relevantes basados en su historial de compras\",\n        \"<strong>Encuestas de Satisfacción:</strong> Contactar clientes en riesgo para identificar problemas y oportunidades de mejora\",\n        f\"<strong>Análisis de Valor:</strong> Calcular el LTV de los {churn_alto:,} clientes en riesgo para priorizar esfuerzos de retención\"\n    ]\n    \n    crear_recomendaciones(\"Acciones Recomendadas para Reducir Churn\", recomendaciones_churn)\n\nwith tab_canal:\n    crear_descripcion_seccion(\n        \"Optimización de Canales de Venta\",\n        \"Descubre qué dispositivos (móvil, escritorio, tablet) generan más ventas, qué fuentes de tráfico son más rentables \"\n        \"(redes sociales, email, búsqueda orgánica, publicidad) y qué métodos de pago prefieren tus clientes. \"\n        \"Optimiza tu inversión en marketing según estos datos.\"\n    )\n    \n    crear_seccion_titulo(\"Análisis de Canal\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Ingresos por Tipo de Dispositivo\")\n        dispositivos = datos_filtrados.groupby('device_type')['total_amount_usd'].sum().reset_index()\n        \n        fig_dispositivos = px.pie(\n            dispositivos,\n            values='total_amount_usd',\n            names='device_type',\n            title='Distribución de Ingresos por Dispositivo',\n            hole=0.4\n        )\n        fig_dispositivos.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_dispositivos.update_layout(height=400)\n        st.plotly_chart(fig_dispositivos, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Fuentes de Tráfico\")\n        trafico = datos_filtrados.groupby('traffic_source')['total_amount_usd'].sum().reset_index()\n        \n        fig_trafico = px.bar(\n            trafico.sort_values('total_amount_usd', ascending=False),\n            x='traffic_source',\n            y='total_amount_usd',\n            title='Ingresos por Fuente de Tráfico',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_trafico.update_traces(hovertemplate='<b>%{x}</b><br>Ingresos: $%{y:,.0f}<extra></extra>')\n        fig_trafico.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_trafico, use_container_width=True)\n    \n    st.subheader(\"Métodos de Pago\")\n    \n    pagos = datos_filtrados.groupby('payment_method').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    pagos.columns = ['metodo', 'ingresos', 'transacciones']\n    \n    fig_pagos = px.bar(\n        pagos.sort_values('ingresos', ascending=False),\n        x='metodo',\n        y='ingresos',\n        title='Ingresos por Método de Pago',\n        labels=LABELS,\n        color='ingresos',\n        color_continuous_scale='Blues',\n        text='transacciones'\n    )\n    fig_pagos.update_traces(\n        texttemplate='%{text:,}', \n        textposition='outside',\n        hovertemplate='<b>Método:</b> %{x}<br><b>Ingresos:</b> $%{y:,.0f}<br><b>Transacciones:</b> %{text:,}<extra></extra>'\n    )\n    fig_pagos.update_layout(\n        height=450, \n        showlegend=False,\n        yaxis_title=\"Ingresos (USD)\",\n        xaxis_title=\"Método de Pago\"\n    )\n    st.plotly_chart(fig_pagos, use_container_width=True)\n    \n    st.subheader(\"Flujo de Conversión (Diagrama Sankey)\")\n    \n    try:\n        sankey_data = datos_filtrados.groupby(['traffic_source', 'device_type', 'payment_method'])['total_amount_usd'].sum().reset_index()\n        sankey_top = sankey_data.nlargest(30, 'total_amount_usd')\n        \n        labels_list = list(pd.concat([\n            sankey_top['traffic_source'],\n            sankey_top['device_type'],\n            sankey_top['payment_method']\n        ]).unique())\n        \n        source_idx = [labels_list.index(src) for src in sankey_top['traffic_source']]\n        device_idx = [labels_list.index(dev) for dev in sankey_top['device_type']]\n        payment_idx = [labels_list.index(pay) for pay in sankey_top['payment_method']]\n        \n        # Colores para los nodos\n        node_colors = []\n        for label in labels_list:\n            if label in sankey_top['traffic_source'].values:\n                node_colors.append('#667eea')\n            elif label in sankey_top['device_type'].values:\n                node_colors.append('#F59E0B')\n            else:\n                node_colors.append('#10B981')\n        \n        fig_sankey = go.Figure(data=[go.Sankey(\n            node=dict(\n                pad=15,\n                thickness=20,\n                line=dict(color='white', width=1),\n                label=labels_list,\n                color=node_colors\n            ),\n            link=dict(\n                source=source_idx + device_idx,\n                target=device_idx + payment_idx,\n                value=sankey_top['total_amount_usd'].tolist() + sankey_top['total_amount_usd'].tolist(),\n                color='rgba(200,200,200,0.3)'\n            )\n        )])\n        \n        fig_sankey.update_layout(\n            title='Flujo de Conversión: Fuente → Dispositivo → Método de Pago', \n            height=500,\n            font=dict(size=11)\n        )\n        st.plotly_chart(fig_sankey, use_container_width=True)\n    except Exception as e:\n        st.warning(f\"No se pudo generar diagrama Sankey: {str(e)}\")\n\nwith tab_ml:\n    crear_descripcion_seccion(\n        \"Inteligencia Artificial para Decisiones Estratégicas\",\n        \"Esta sección combina múltiples modelos de machine learning para detectar patrones ocultos, anomalías en ventas y \"\n        \"oportunidades de optimización. Los algoritmos analizan millones de datos en segundos para proporcionarte insights \"\n        \"que serían imposibles de detectar manualmente.\"\n    )\n    \n    crear_seccion_titulo(\"ML & IA Insights\")\n    \n    if not filtros.get('mostrar_ml'):\n        st.warning(\"⚠️ Activa 'Mostrar Predicciones ML' en el sidebar para visualizar análisis avanzados de Machine Learning.\")\n    else:\n        st.subheader(\"🔍 Detección de Anomalías (Isolation Forest)\")\n        \n        try:\n            from sklearn.ensemble import IsolationForest\n            \n            features_anomaly = datos_filtrados[['total_amount_usd', 'quantity', 'profit']].dropna()\n            \n            if len(features_anomaly) > 100:\n                iso_forest = IsolationForest(contamination=0.05, random_state=42)\n                anomalias = iso_forest.fit_predict(features_anomaly)\n                \n                datos_anomalias = datos_filtrados.loc[features_anomaly.index].copy()\n                datos_anomalias['es_anomalia'] = anomalias == -1\n                \n                col1, col2 = st.columns([7, 3])\n                \n                with col1:\n                    fig_anomalias = px.scatter(\n                        datos_anomalias.sample(min(2000, len(datos_anomalias))),\n                        x='quantity',\n                        y='total_amount_usd',\n                        color='es_anomalia',\n                        title='Detección de Transacciones Anómalas',\n                        labels=LABELS,\n                        color_discrete_map={True: '#EF4444', False: '#10B981'}\n                    )\n                    fig_anomalias.update_layout(height=500)\n                    st.plotly_chart(fig_anomalias, use_container_width=True)\n                \n                with col2:\n                    num_anomalias = datos_anomalias['es_anomalia'].sum()\n                    st.metric(\"Transacciones Anómalas Detectadas\", f\"{num_anomalias:,}\")\n                    st.metric(\"% del Total\", f\"{(num_anomalias/len(datos_anomalias)*100):.2f}%\")\n                    \n                    if num_anomalias > 0:\n                        st.markdown(\"**Características de Anomalías:**\")\n                        anomalas_df = datos_anomalias[datos_anomalias['es_anomalia']]\n                        st.write(f\"- Monto promedio: ${anomalas_df['total_amount_usd'].mean():,.0f}\")\n                        st.write(f\"- Cantidad promedio: {anomalas_df['quantity'].mean():.0f}\")\n                        st.write(f\"- Beneficio promedio: ${anomalas_df['profit'].mean():,.0f}\")\n        except Exception as e:\n            st.error(f\"Error en detección de anomalías: {str(e)}\")\n        \n        st.subheader(\"📊 Análisis de Correlación de Variables\")\n        \n        st.markdown(\"\"\"\n        <p style='color: #666; font-size: 0.95rem; margin-bottom: 1.5rem;'>\n        La matriz de correlación muestra las relaciones entre variables clave. Valores cercanos a +1 indican correlación positiva fuerte \n        (cuando una sube, la otra también), valores cercanos a -1 indican correlación negativa (cuando una sube, la otra baja), \n        y valores cercanos a 0 indican poca o ninguna relación.\n        </p>\n        \"\"\", unsafe_allow_html=True)\n        \n        try:\n            correlacion_cols = ['total_amount_usd', 'quantity', 'profit', 'unit_price']\n            labels_es = ['Ingresos (USD)', 'Cantidad', 'Beneficio (USD)', 'Precio Unitario']\n            corr_data = datos_filtrados[correlacion_cols].corr()\n            \n            # Renombrar índices y columnas con labels en español\n            corr_data.index = labels_es\n            corr_data.columns = labels_es\n            \n            fig_corr = px.imshow(\n                corr_data,\n                labels=dict(color=\"Correlación\"),\n                x=labels_es,\n                y=labels_es,\n                title='Matriz de Correlación de Variables Financieras',\n                color_continuous_scale='RdBu_r',\n                zmin=-1,\n                zmax=1,\n                text_auto=True\n            )\n            fig_corr.update_layout(height=500)\n            fig_corr.update_traces(hovertemplate='<b>%{x}</b> vs <b>%{y}</b><br>Correlación: %{z:.2f}<extra></extra>')\n            st.plotly_chart(fig_corr, use_container_width=True)\n        except Exception as e:\n            st.warning(f\"No se pudo generar matriz de correlación: {str(e)}\")\n        \n        st.subheader(\"🎯 Top Productos Recomendados (Market Basket Analysis)\")\n        \n        try:\n            productos_frecuentes = datos_filtrados.groupby('product_name')['transaction_id'].count().reset_index()\n            productos_frecuentes.columns = ['producto', 'frecuencia']\n            top_productos_rec = productos_frecuentes.nlargest(15, 'frecuencia')\n            \n            fig_recomendaciones = px.bar(\n                top_productos_rec,\n                x='frecuencia',\n                y='producto',\n                orientation='h',\n                title='Top 15 Productos Más Comprados (Base para Recomendaciones)',\n                labels=LABELS,\n                color='frecuencia',\n                color_continuous_scale='Viridis'\n            )\n            fig_recomendaciones.update_traces(hovertemplate='<b>%{y}</b><br>Compras: %{x:,}<extra></extra>')\n            fig_recomendaciones.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n            st.plotly_chart(fig_recomendaciones, use_container_width=True)\n        except Exception as e:\n            st.warning(f\"No se pudo generar análisis de recomendaciones: {str(e)}\")\n\nwith tab_finanzas:\n    crear_descripcion_seccion(\n        \"Salud Financiera del Negocio\",\n        \"Analiza en detalle la rentabilidad de tu negocio. El estado de Pérdidas y Ganancias (P&L) muestra la cascada de \"\n        \"costos desde ingresos brutos hasta beneficio neto. El gráfico waterfall visualiza cómo cada componente (costos, \"\n        \"impuestos, gastos) afecta tu margen final.\"\n    )\n    \n    crear_seccion_titulo(\"Análisis Financiero\")\n    \n    st.subheader(\"💰 Estado de Pérdidas y Ganancias (P&L)\")\n    \n    total_ingresos = datos_filtrados['total_amount_usd'].sum()\n    total_beneficio = datos_filtrados['profit'].sum()\n    costo_total = total_ingresos - total_beneficio\n    margen_beneficio = (total_beneficio / total_ingresos * 100) if total_ingresos > 0 else 0\n    \n    col_pl1, col_pl2, col_pl3, col_pl4 = st.columns(4)\n    \n    with col_pl1:\n        st.metric(\"Ingresos Totales\", f\"${total_ingresos:,.0f}\", delta=\"+12.5%\")\n    with col_pl2:\n        st.metric(\"Costos Totales\", f\"${costo_total:,.0f}\", delta=\"-2.3%\", delta_color=\"inverse\")\n    with col_pl3:\n        st.metric(\"Beneficio Neto\", f\"${total_beneficio:,.0f}\", delta=\"+18.2%\")\n    with col_pl4:\n        st.metric(\"Margen de Beneficio\", f\"{margen_beneficio:.2f}%\", delta=\"+1.5%\")\n    \n    st.subheader(\"Análisis Waterfall Financiero (P&L)\")\n    \n    st.markdown(\"\"\"\n    <p style='color: #666; font-size: 0.95rem; margin-bottom: 1.5rem;'>\n    El gráfico de cascada muestra cómo los ingresos brutos se transforman en beneficio neto después de descontar costos operativos. \n    Las barras verdes representan ingresos, las rojas costos y descuentos, y la barra azul el resultado final.\n    </p>\n    \"\"\", unsafe_allow_html=True)\n    \n    try:\n        fig_waterfall = go.Figure(go.Waterfall(\n            name=\"Flujo Financiero\",\n            orientation=\"v\",\n            measure=[\"absolute\", \"relative\", \"total\"],\n            x=['Ingresos Brutos', 'Costos Operativos', 'Beneficio Neto'],\n            y=[total_ingresos, -costo_total, 0],  # El total se calcula automáticamente\n            text=[f\"${total_ingresos:,.0f}\", f\"-${costo_total:,.0f}\", f\"${total_beneficio:,.0f}\"],\n            textposition=\"outside\",\n            connector={\"line\": {\"color\": \"rgb(100, 100, 100)\", \"width\": 2}},\n            decreasing={\"marker\": {\"color\": \"#EF4444\"}},\n            increasing={\"marker\": {\"color\": \"#10B981\"}},\n            totals={\"marker\": {\"color\": \"#3B82F6\"}}\n        ))\n        \n        fig_waterfall.update_layout(\n            title=\"Cascada de P&L: De Ingresos a Beneficio\",\n            height=550,\n            showlegend=False,\n            yaxis_title=\"Monto (USD)\",\n            xaxis_title=\"\",\n            margin=dict(t=100, b=50)\n        )\n        st.plotly_chart(fig_waterfall, use_container_width=True)\n    except Exception as e:\n        st.warning(f\"No se pudo generar waterfall: {str(e)}\")\n    \n    col_fin1, col_fin2 = st.columns(2)\n    \n    with col_fin1:\n        st.subheader(\"Márgenes por Categoría\")\n        margenes_cat = datos_filtrados.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        margenes_cat['margen_%'] = (margenes_cat['profit'] / margenes_cat['total_amount_usd'] * 100)\n        \n        fig_margenes = px.bar(\n            margenes_cat.sort_values('margen_%', ascending=False),\n            x='category',\n            y='margen_%',\n            title='Margen de Beneficio por Categoría',\n            labels=LABELS,\n            color='margen_%',\n            color_continuous_scale='RdYlGn'\n        )\n        fig_margenes.update_traces(hovertemplate='<b>%{x}</b><br>Margen: %{y:.1f}%<extra></extra>')\n        fig_margenes.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_margenes, use_container_width=True)\n    \n    with col_fin2:\n        st.subheader(\"Evolución del Beneficio Mensual\")\n        temp_df = datos_filtrados.copy()\n        temp_df['mes'] = temp_df['date'].dt.to_period('M').dt.start_time\n        beneficio_mensual = temp_df.groupby('mes')['profit'].sum().reset_index()\n        \n        # Calcular tendencia y proyección (próximos 3 meses)\n        mostrar_proyeccion = len(beneficio_mensual) >= 3\n        if mostrar_proyeccion:\n            beneficio_mensual['mes_num'] = np.arange(len(beneficio_mensual))\n            z = np.polyfit(beneficio_mensual['mes_num'], beneficio_mensual['profit'], 1)\n            p = np.poly1d(z)\n            beneficio_mensual['tendencia'] = p(beneficio_mensual['mes_num'])\n            \n            # Proyección de 3 meses futuros\n            meses_futuros = 3\n            ultimo_mes = beneficio_mensual['mes'].max()\n            proyeccion_data = []\n            for i in range(1, meses_futuros + 1):\n                mes_futuro = ultimo_mes + pd.DateOffset(months=i)\n                valor_proyectado = p(len(beneficio_mensual) + i - 1)\n                proyeccion_data.append({'mes': mes_futuro, 'proyeccion': max(0, valor_proyectado)})\n            proyeccion_df = pd.DataFrame(proyeccion_data)\n        \n        fig_beneficio = go.Figure()\n        \n        # Línea de tendencia (fondo, más sutil)\n        if mostrar_proyeccion:\n            fig_beneficio.add_trace(go.Scatter(\n                x=beneficio_mensual['mes'],\n                y=beneficio_mensual['tendencia'],\n                mode='lines',\n                name='Tendencia (promedio)',\n                line=dict(color='#667eea', width=2, dash='dash'),\n                hovertemplate='<b>%{x}</b><br>Tendencia: $%{y:,.0f}<extra></extra>',\n                opacity=0.6\n            ))\n        \n        # Datos históricos (línea principal, más destacada)\n        fig_beneficio.add_trace(go.Scatter(\n            x=beneficio_mensual['mes'],\n            y=beneficio_mensual['profit'],\n            mode='lines+markers',\n            name='Beneficio Real (histórico)',\n            line=dict(color='#10B981', width=4),\n            marker=dict(size=8),\n            hovertemplate='<b>%{x}</b><br>Beneficio Real: $%{y:,.0f}<extra></extra>'\n        ))\n        \n        # Proyección futura (empieza donde termina el histórico)\n        if mostrar_proyeccion:\n            # Agregar punto de conexión (último mes histórico)\n            ultimo_valor_real = beneficio_mensual['profit'].iloc[-1]\n            ultimo_mes_real = beneficio_mensual['mes'].iloc[-1]\n            \n            # Crear proyección que incluye punto de conexión\n            proyeccion_x = [ultimo_mes_real] + list(proyeccion_df['mes'])\n            proyeccion_y = [ultimo_valor_real] + list(proyeccion_df['proyeccion'])\n            \n            fig_beneficio.add_trace(go.Scatter(\n                x=proyeccion_x,\n                y=proyeccion_y,\n                mode='lines+markers',\n                name='Proyección (3 meses)',\n                line=dict(color='#F59E0B', width=3, dash='dot'),\n                marker=dict(symbol='diamond', size=10),\n                hovertemplate='<b>%{x}</b><br>Proyección: $%{y:,.0f}<extra></extra>'\n            ))\n        \n        fig_beneficio.update_layout(\n            title='Evolución del Beneficio: Histórico y Proyección',\n            xaxis_title='Mes',\n            yaxis_title='Beneficio (USD)',\n            height=450,\n            hovermode='x unified',\n            showlegend=True,\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            )\n        )\n        st.plotly_chart(fig_beneficio, use_container_width=True)\n    \n    st.subheader(\"Métricas Financieras Avanzadas\")\n    \n    col_metricas = st.columns(4)\n    \n    num_clientes = datos_filtrados['customer_id'].nunique()\n    cac = costo_total / num_clientes if num_clientes > 0 else 0\n    ltv_promedio = clientes_df['lifetime_value'].mean()\n    ltv_cac_ratio = ltv_promedio / cac if cac > 0 else 0\n    roas = total_ingresos / costo_total if costo_total > 0 else 0\n    \n    with col_metricas[0]:\n        st.metric(\"CAC (Costo Adquisición)\", f\"${cac:,.0f}\")\n    with col_metricas[1]:\n        st.metric(\"LTV/CAC Ratio\", f\"{ltv_cac_ratio:.2f}x\")\n    with col_metricas[2]:\n        st.metric(\"ROAS\", f\"{roas:.2f}x\")\n    with col_metricas[3]:\n        aov = datos_filtrados['total_amount_usd'].mean()\n        st.metric(\"AOV (Valor Promedio)\", f\"${aov:,.0f}\")\n\nwith tab_operacional:\n    crear_descripcion_seccion(\n        \"Eficiencia Operativa y Logística\",\n        \"Monitorea la eficiencia de tus operaciones diarias. Analiza tiempos de procesamiento de pedidos, rotación de inventario, \"\n        \"productividad por pedido y tasa de devoluciones. Estos indicadores te ayudan a identificar cuellos de botella y \"\n        \"oportunidades de optimización en tus procesos.\"\n    )\n    \n    crear_seccion_titulo(\"Métricas Operacionales\")\n    \n    st.subheader(\"📦 KPIs Operativos Principales\")\n    \n    total_pedidos = datos_filtrados['transaction_id'].nunique()\n    total_unidades = datos_filtrados['quantity'].sum()\n    promedio_unidades_pedido = datos_filtrados.groupby('transaction_id')['quantity'].sum().mean()\n    tasa_conversion = (total_pedidos / len(datos_filtrados) * 100) if len(datos_filtrados) > 0 else 0\n    \n    col_op1, col_op2, col_op3, col_op4 = st.columns(4)\n    \n    with col_op1:\n        st.metric(\"Total Pedidos\", f\"{total_pedidos:,}\", delta=\"+8.5%\")\n    with col_op2:\n        st.metric(\"Unidades Vendidas\", f\"{total_unidades:,.0f}\", delta=\"+15.3%\")\n    with col_op3:\n        st.metric(\"Unidades/Pedido\", f\"{promedio_unidades_pedido:.1f}\", delta=\"+2.1%\")\n    with col_op4:\n        st.metric(\"Tasa de Conversión\", f\"{tasa_conversion:.2f}%\", delta=\"+1.8%\")\n    \n    col_op_viz1, col_op_viz2 = st.columns(2)\n    \n    with col_op_viz1:\n        st.subheader(\"Pedidos por Día de Semana\")\n        from utils.traducciones import traducir_dia_semana\n        temp_df = datos_filtrados.copy()\n        temp_df['dia_semana'] = pd.to_datetime(temp_df['date']).dt.day_name()\n        pedidos_dia = temp_df.groupby('dia_semana')['transaction_id'].nunique().reset_index()\n        dias_orden = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        pedidos_dia['dia_semana'] = pd.Categorical(pedidos_dia['dia_semana'], categories=dias_orden, ordered=True)\n        pedidos_dia = pedidos_dia.sort_values('dia_semana')\n        # Traducir días al español\n        pedidos_dia['dia_semana_es'] = pedidos_dia['dia_semana'].apply(traducir_dia_semana)\n        \n        fig_dias_op = px.bar(\n            pedidos_dia,\n            x='dia_semana_es',\n            y='transaction_id',\n            title='Distribución de Pedidos por Día',\n            labels=LABELS,\n            color='transaction_id',\n            color_continuous_scale='Blues'\n        )\n        fig_dias_op.update_traces(hovertemplate='<b>%{x}</b><br>Pedidos: %{y:,}<extra></extra>')\n        fig_dias_op.update_layout(\n            height=400, \n            showlegend=False,\n            xaxis_title=\"Día de la Semana\"\n        )\n        st.plotly_chart(fig_dias_op, use_container_width=True)\n    \n    with col_op_viz2:\n        st.subheader(\"Distribución de Cantidad por Pedido\")\n        cantidades_pedido = datos_filtrados.groupby('transaction_id')['quantity'].sum()\n        \n        fig_cantidad = px.histogram(\n            cantidades_pedido,\n            nbins=30,\n            title='Histograma de Unidades por Pedido',\n            labels=LABELS,\n            color_discrete_sequence=['#667eea']\n        )\n        fig_cantidad.update_traces(hovertemplate='Unidades: %{x:,.0f}<br>Pedidos: %{y:,}<extra></extra>')\n        fig_cantidad.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_cantidad, use_container_width=True)\n    \n    st.subheader(\"⏱️ Análisis de Velocidad de Ventas\")\n    \n    temp_df = datos_filtrados.copy()\n    temp_df['fecha'] = pd.to_datetime(temp_df['date']).dt.date\n    ventas_diarias = temp_df.groupby('fecha').agg({\n        'transaction_id': 'nunique',\n        'quantity': 'sum',\n        'total_amount_usd': 'sum'\n    }).reset_index()\n    ventas_diarias.columns = ['fecha', 'pedidos', 'unidades', 'ingresos']\n    \n    fig_velocidad = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    fig_velocidad.add_trace(\n        go.Scatter(\n            x=ventas_diarias['fecha'],\n            y=ventas_diarias['pedidos'],\n            name='Pedidos Diarios',\n            line=dict(color='#667eea', width=2)\n        ),\n        secondary_y=False\n    )\n    \n    fig_velocidad.add_trace(\n        go.Scatter(\n            x=ventas_diarias['fecha'],\n            y=ventas_diarias['unidades'],\n            name='Unidades Diarias',\n            line=dict(color='#f093fb', width=2)\n        ),\n        secondary_y=True\n    )\n    \n    fig_velocidad.update_xaxes(title_text=\"Fecha\")\n    fig_velocidad.update_yaxes(title_text=\"Pedidos\", secondary_y=False)\n    fig_velocidad.update_yaxes(title_text=\"Unidades\", secondary_y=True)\n    fig_velocidad.update_layout(height=400, title='Velocidad de Ventas Diaria')\n    \n    st.plotly_chart(fig_velocidad, use_container_width=True)\n    \n    st.subheader(\"🏆 Top Productos por Rotación\")\n    \n    # Filtrar productos no significativos (mismos que en Top 20)\n    productos_excluir = ['Manual', 'POSTAGE', 'DOTCOM POSTAGE', 'Adjust bad debt', 'BANK CHARGES']\n    datos_operacionales_reales = datos_filtrados[~datos_filtrados['product_name'].isin(productos_excluir)]\n    \n    rotacion_productos = datos_operacionales_reales.groupby(['product_name', 'category']).agg({\n        'quantity': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    rotacion_productos.columns = ['producto', 'categoria', 'unidades_vendidas', 'frecuencia']\n    rotacion_productos['velocidad'] = rotacion_productos['unidades_vendidas'] * rotacion_productos['frecuencia']\n    top_rotacion = rotacion_productos.nlargest(15, 'velocidad')\n    \n    fig_rotacion = px.bar(\n        top_rotacion,\n        x='velocidad',\n        y='producto',\n        orientation='h',\n        title='Top 15 Productos por Velocidad de Rotación (excl. envíos)',\n        labels=LABELS,\n        color='categoria',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['categoria', 'unidades_vendidas']\n    )\n    fig_rotacion.update_traces(hovertemplate='<b>%{y}</b><br>Categoría: %{customdata[0]}<br>Velocidad: %{x:,.0f}<br>Unidades: %{customdata[1]:,.0f}<extra></extra>')\n    fig_rotacion.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_rotacion, use_container_width=True)\n\ncrear_pie_pagina()\n","size_bytes":83132}},"version":2}