{"file_contents":{"utils/export_utils.py":{"content":"import pandas as pd\nimport io\nfrom datetime import datetime\nfrom reportlab.lib.pagesizes import letter, A4\nfrom reportlab.lib import colors\nfrom reportlab.lib.units import inch\nfrom reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak, Image\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT\nfrom reportlab.pdfgen import canvas\nimport plotly.graph_objects as go\nimport plotly.io as pio\nimport tempfile\nimport os\n\ndef create_pdf_report(transactions_df, customers_df, products_df, filters):\n    \"\"\"\n    Genera reporte PDF profesional con gr√°ficos y an√°lisis\n    \"\"\"\n    buffer = io.BytesIO()\n    \n    # Crear documento\n    doc = SimpleDocTemplate(\n        buffer,\n        pagesize=letter,\n        rightMargin=72,\n        leftMargin=72,\n        topMargin=72,\n        bottomMargin=18,\n    )\n    \n    # Estilos\n    styles = getSampleStyleSheet()\n    title_style = ParagraphStyle(\n        'CustomTitle',\n        parent=styles['Heading1'],\n        fontSize=24,\n        textColor=colors.HexColor('#1E40AF'),\n        spaceAfter=30,\n        alignment=TA_CENTER\n    )\n    \n    heading_style = ParagraphStyle(\n        'CustomHeading',\n        parent=styles['Heading2'],\n        fontSize=16,\n        textColor=colors.HexColor('#1E40AF'),\n        spaceAfter=12,\n        spaceBefore=12\n    )\n    \n    # Contenido\n    story = []\n    \n    # T√≠tulo\n    title = Paragraph(\"Global Ecommerce Analytics Report\", title_style)\n    story.append(title)\n    \n    # Fecha\n    date_text = Paragraph(\n        f\"<para align=center>Generado: {datetime.now().strftime('%Y-%m-%d %H:%M')}</para>\",\n        styles['Normal']\n    )\n    story.append(date_text)\n    story.append(Spacer(1, 20))\n    \n    # KPIs principales\n    story.append(Paragraph(\"Resumen Ejecutivo\", heading_style))\n    \n    total_revenue = transactions_df['total_amount_usd'].sum()\n    total_orders = len(transactions_df)\n    total_customers = transactions_df['customer_id'].nunique()\n    avg_order_value = transactions_df['total_amount_usd'].mean()\n    total_profit = transactions_df['profit'].sum()\n    \n    kpi_data = [\n        ['M√©trica', 'Valor'],\n        ['Total Revenue', f'${total_revenue:,.2f}'],\n        ['Total Orders', f'{total_orders:,}'],\n        ['Total Customers', f'{total_customers:,}'],\n        ['Avg Order Value', f'${avg_order_value:.2f}'],\n        ['Gross Profit', f'${total_profit:,.2f}'],\n        ['Profit Margin', f'{(total_profit/total_revenue*100):.1f}%']\n    ]\n    \n    kpi_table = Table(kpi_data, colWidths=[3*inch, 3*inch])\n    kpi_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1E40AF')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 12),\n        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black)\n    ]))\n    \n    story.append(kpi_table)\n    story.append(Spacer(1, 20))\n    \n    # Top 10 pa√≠ses\n    story.append(Paragraph(\"Top 10 Pa√≠ses por Revenue\", heading_style))\n    \n    country_data = transactions_df.groupby('country').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index().nlargest(10, 'total_amount_usd')\n    \n    country_table_data = [['Pa√≠s', 'Revenue', 'Orders']]\n    for _, row in country_data.iterrows():\n        country_table_data.append([\n            row['country'],\n            f\"${row['total_amount_usd']:,.0f}\",\n            f\"{row['transaction_id']:,}\"\n        ])\n    \n    country_table = Table(country_table_data, colWidths=[2*inch, 2*inch, 2*inch])\n    country_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#10B981')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 10),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])\n    ]))\n    \n    story.append(country_table)\n    story.append(Spacer(1, 20))\n    \n    # Top 10 productos\n    story.append(Paragraph(\"Top 10 Productos por Revenue\", heading_style))\n    \n    product_data = transactions_df.groupby(['product_id', 'product_name', 'category']).agg({\n        'total_amount_usd': 'sum',\n        'quantity': 'sum'\n    }).reset_index().nlargest(10, 'total_amount_usd')\n    \n    product_table_data = [['Producto', 'Categor√≠a', 'Revenue', 'Units']]\n    for _, row in product_data.iterrows():\n        product_name = row['product_name'][:30] + '...' if len(row['product_name']) > 30 else row['product_name']\n        product_table_data.append([\n            product_name,\n            row['category'],\n            f\"${row['total_amount_usd']:,.0f}\",\n            f\"{row['quantity']:,}\"\n        ])\n    \n    product_table = Table(product_table_data, colWidths=[2.5*inch, 1.5*inch, 1.5*inch, 0.5*inch])\n    product_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#F59E0B')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 10),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])\n    ]))\n    \n    story.append(product_table)\n    story.append(Spacer(1, 20))\n    \n    # An√°lisis de categor√≠as\n    story.append(Paragraph(\"Revenue por Categor√≠a\", heading_style))\n    \n    category_data = transactions_df.groupby('category').agg({\n        'total_amount_usd': 'sum',\n        'profit': 'sum'\n    }).reset_index().sort_values('total_amount_usd', ascending=False)\n    \n    category_table_data = [['Categor√≠a', 'Revenue', 'Profit', 'Margin %']]\n    for _, row in category_data.iterrows():\n        margin = (row['profit'] / row['total_amount_usd'] * 100) if row['total_amount_usd'] > 0 else 0\n        category_table_data.append([\n            row['category'],\n            f\"${row['total_amount_usd']:,.0f}\",\n            f\"${row['profit']:,.0f}\",\n            f\"{margin:.1f}%\"\n        ])\n    \n    category_table = Table(category_table_data, colWidths=[2*inch, 1.5*inch, 1.5*inch, 1*inch])\n    category_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#8B5CF6')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 10),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey])\n    ]))\n    \n    story.append(category_table)\n    \n    # Construir PDF\n    doc.build(story)\n    buffer.seek(0)\n    \n    return buffer\n\ndef create_excel_report(transactions_df, customers_df, products_df, filters):\n    \"\"\"\n    Genera reporte Excel con m√∫ltiples hojas y an√°lisis\n    \"\"\"\n    buffer = io.BytesIO()\n    \n    with pd.ExcelWriter(buffer, engine='openpyxl') as writer:\n        # Hoja 1: Resumen\n        summary_data = {\n            'M√©trica': [\n                'Total Revenue',\n                'Total Orders',\n                'Total Customers',\n                'Avg Order Value',\n                'Gross Profit',\n                'Profit Margin (%)',\n                'Total Products',\n                'Total Categories'\n            ],\n            'Valor': [\n                f\"${transactions_df['total_amount_usd'].sum():,.2f}\",\n                f\"{len(transactions_df):,}\",\n                f\"{transactions_df['customer_id'].nunique():,}\",\n                f\"${transactions_df['total_amount_usd'].mean():.2f}\",\n                f\"${transactions_df['profit'].sum():,.2f}\",\n                f\"{(transactions_df['profit'].sum()/transactions_df['total_amount_usd'].sum()*100):.2f}\",\n                f\"{transactions_df['product_id'].nunique():,}\",\n                f\"{transactions_df['category'].nunique():,}\"\n            ]\n        }\n        summary_df = pd.DataFrame(summary_data)\n        summary_df.to_excel(writer, sheet_name='Resumen', index=False)\n        \n        # Hoja 2: Transacciones (√∫ltimas 1000)\n        transactions_export = transactions_df[[\n            'transaction_id', 'date', 'customer_id', 'country', 'product_name',\n            'category', 'quantity', 'unit_price', 'total_amount_usd', 'profit',\n            'payment_method', 'device_type'\n        ]].head(1000)\n        transactions_export.to_excel(writer, sheet_name='Transacciones', index=False)\n        \n        # Hoja 3: An√°lisis por pa√≠s\n        country_analysis = transactions_df.groupby('country').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count',\n            'customer_id': 'nunique',\n            'profit': 'sum'\n        }).reset_index()\n        country_analysis.columns = ['Pa√≠s', 'Revenue', 'Orders', 'Customers', 'Profit']\n        country_analysis = country_analysis.sort_values('Revenue', ascending=False)\n        country_analysis.to_excel(writer, sheet_name='Por Pa√≠s', index=False)\n        \n        # Hoja 4: An√°lisis por categor√≠a\n        category_analysis = transactions_df.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count',\n            'quantity': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        category_analysis.columns = ['Categor√≠a', 'Revenue', 'Orders', 'Units Sold', 'Profit']\n        category_analysis['Profit Margin %'] = (category_analysis['Profit'] / category_analysis['Revenue'] * 100).round(2)\n        category_analysis = category_analysis.sort_values('Revenue', ascending=False)\n        category_analysis.to_excel(writer, sheet_name='Por Categor√≠a', index=False)\n        \n        # Hoja 5: Top productos\n        product_analysis = transactions_df.groupby(['product_id', 'product_name', 'category']).agg({\n            'total_amount_usd': 'sum',\n            'quantity': 'sum',\n            'transaction_id': 'count',\n            'profit': 'sum'\n        }).reset_index()\n        product_analysis.columns = ['Product ID', 'Product Name', 'Category', 'Revenue', 'Units', 'Orders', 'Profit']\n        product_analysis = product_analysis.nlargest(100, 'Revenue')\n        product_analysis.to_excel(writer, sheet_name='Top 100 Productos', index=False)\n        \n        # Hoja 6: Clientes VIP (top 100 por LTV)\n        top_customers = customers_df.nlargest(100, 'lifetime_value')[[\n            'customer_id', 'country', 'rfm_segment', 'lifetime_value',\n            'total_orders', 'avg_order_value', 'churn_probability'\n        ]]\n        top_customers.to_excel(writer, sheet_name='Clientes VIP', index=False)\n        \n        # Hoja 7: Segmentaci√≥n RFM\n        rfm_analysis = customers_df.groupby('rfm_segment').agg({\n            'customer_id': 'count',\n            'lifetime_value': 'mean',\n            'total_orders': 'mean',\n            'churn_probability': 'mean'\n        }).reset_index()\n        rfm_analysis.columns = ['Segmento RFM', 'Clientes', 'LTV Promedio', 'Orders Promedio', 'Churn Prob Promedio']\n        rfm_analysis = rfm_analysis.sort_values('LTV Promedio', ascending=False)\n        rfm_analysis.to_excel(writer, sheet_name='Segmentaci√≥n RFM', index=False)\n        \n        # Hoja 8: Time series (√∫ltimos 90 d√≠as)\n        transactions_df['date_only'] = pd.to_datetime(transactions_df['date']).dt.date\n        time_series = transactions_df.groupby('date_only').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count'\n        }).reset_index().tail(90)\n        time_series.columns = ['Fecha', 'Revenue', 'Orders']\n        time_series.to_excel(writer, sheet_name='Serie Temporal', index=False)\n    \n    buffer.seek(0)\n    return buffer\n","size_bytes":12018},"app.py":{"content":"\"\"\"\nDashboard Avanzado de Analytics Ecommerce Global\nAutor: cmsr92\nVersi√≥n: 2.0\nPlataforma profesional de Business Intelligence con ML, IA y An√°lisis Predictivo\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport folium\nfrom streamlit_folium import st_folium\nfrom datetime import datetime, timedelta\nimport warnings\nwarnings.filterwarnings('ignore')\n\nst.set_page_config(\n    page_title=\"Analytics Ecommerce Global | cmsr92\",\n    page_icon=\"üìä\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\nfrom utils.ui_components import (\n    aplicar_estilos_globales, crear_header_principal, crear_tarjeta_kpi,\n    crear_seccion_titulo, crear_pie_pagina, mostrar_info_dataset,\n    crear_descripcion_seccion, crear_insight, crear_recomendaciones\n)\nfrom utils.filtros import crear_filtros_sidebar, aplicar_filtros\nfrom utils.data_loader_pg import load_or_generate_data\nfrom utils.traducciones import obtener_labels_profesionales\n\n# Labels profesionales para gr√°ficos\nLABELS = obtener_labels_profesionales()\n\n# Aplicar estilos globales con detecci√≥n autom√°tica de tema del navegador\naplicar_estilos_globales()\n\n@st.cache_data(ttl=60)\ndef cargar_datos():\n    return load_or_generate_data()\n\ntransacciones_df, clientes_df, productos_df = cargar_datos()\n\nif transacciones_df is None or clientes_df is None or productos_df is None:\n    st.error(\"‚ùå Error al cargar los datos. Por favor recarga la p√°gina.\")\n    st.stop()\n\ncrear_header_principal(\n    \"üìä Analytics Ecommerce Global\",\n    \"Plataforma Avanzada de Business Intelligence, Machine Learning y An√°lisis Predictivo\"\n)\n\nfiltros = crear_filtros_sidebar(transacciones_df)\ndatos_filtrados = aplicar_filtros(transacciones_df, filtros)\n\nif len(datos_filtrados) == 0:\n    st.warning(\"‚ö†Ô∏è No hay datos que coincidan con los filtros seleccionados. Ajusta los criterios de b√∫squeda.\")\n    st.stop()\n\ntab_overview, tab_geografia, tab_rendimiento, tab_productos, tab_clientes, tab_canal, tab_ml, tab_finanzas, tab_operacional = st.tabs([\n    \"üè† Resumen General\",\n    \"üåç An√°lisis Geogr√°fico\",\n    \"üìà Rendimiento & An√°lisis Temporal\",\n    \"üì¶ An√°lisis de Productos\",\n    \"üë• Segmentaci√≥n de Clientes\",\n    \"üì± An√°lisis de Canal\",\n    \"ü§ñ ML & IA Insights\",\n    \"üí∞ An√°lisis Financiero\",\n    \"‚öôÔ∏è M√©tricas Operacionales\"\n])\n\nwith tab_overview:\n    crear_descripcion_seccion(\n        \"Resumen Ejecutivo\",\n        \"Esta secci√≥n presenta una visi√≥n general del rendimiento del negocio. Los KPIs principales muestran la salud financiera, \"\n        \"el volumen de operaciones y la eficiencia comercial. Utiliza los filtros del sidebar para analizar per√≠odos espec√≠ficos, \"\n        \"regiones geogr√°ficas o segmentos de clientes.\"\n    )\n    \n    crear_seccion_titulo(\"Indicadores Clave de Rendimiento (KPIs)\")\n    \n    # Explicaci√≥n de KPIs\n    with st.expander(\"‚ÑπÔ∏è ¬øQu√© significan estos indicadores?\", expanded=False):\n        st.markdown(\"\"\"\n        **üí∞ Ingresos Totales:** Suma de todas las ventas en el per√≠odo seleccionado. El s√≠mbolo % muestra el cambio respecto al per√≠odo anterior equivalente.\n        \n        **üõí Pedidos Totales:** N√∫mero total de transacciones completadas. Un aumento indica mayor actividad comercial.\n        \n        **üéØ Ticket Promedio (AOV):** Valor promedio por pedido. Se calcula dividiendo ingresos totales entre n√∫mero de pedidos. Un AOV alto indica clientes que compran m√°s por transacci√≥n.\n        \n        **üíé Beneficio Total:** Ganancia neta despu√©s de costos. Se calcula como: Ingresos - Costos. Indica la rentabilidad real del negocio.\n        \n        **üë• Clientes √önicos:** N√∫mero de clientes diferentes que realizaron al menos una compra.\n        \n        **üì¶ Productos Vendidos:** Cantidad de productos distintos que se vendieron en el per√≠odo.\n        \n        **üéØ Tasa de Conversi√≥n:** Porcentaje de clientes √∫nicos respecto al total de pedidos. Una tasa cercana a 100% indica que cada pedido corresponde a un cliente diferente (baja repetici√≥n).\n        \n        **üìä Items por Pedido:** Promedio de art√≠culos incluidos en cada transacci√≥n. √ötil para estrategias de bundling y cross-selling.\n        \"\"\")\n    \n    ingresos_totales = datos_filtrados['total_amount_usd'].sum()\n    pedidos_totales = len(datos_filtrados)\n    ticket_promedio = datos_filtrados['total_amount_usd'].mean()\n    beneficio_total = datos_filtrados['profit'].sum()\n    clientes_unicos = datos_filtrados['customer_id'].nunique()\n    margen_promedio = (beneficio_total / ingresos_totales * 100) if ingresos_totales > 0 else 0\n    \n    fecha_inicio_comparacion = filtros['fecha_inicio'] - (filtros['fecha_fin'] - filtros['fecha_inicio'])\n    \n    # Aplicar LOS MISMOS filtros al per√≠odo anterior (excepto fechas) para comparaci√≥n v√°lida\n    filtros_periodo_anterior_overview = filtros.copy()\n    filtros_periodo_anterior_overview['fecha_inicio'] = fecha_inicio_comparacion\n    filtros_periodo_anterior_overview['fecha_fin'] = filtros['fecha_inicio'] - pd.Timedelta(days=1)\n    \n    datos_periodo_anterior = aplicar_filtros(transacciones_df, filtros_periodo_anterior_overview)\n    \n    ingresos_anteriores = datos_periodo_anterior['total_amount_usd'].sum()\n    cambio_ingresos = ((ingresos_totales - ingresos_anteriores) / ingresos_anteriores * 100) if ingresos_anteriores > 0 else 0\n    \n    pedidos_anteriores = len(datos_periodo_anterior)\n    cambio_pedidos = ((pedidos_totales - pedidos_anteriores) / pedidos_anteriores * 100) if pedidos_anteriores > 0 else 0\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\n            label=\"üí∞ Ingresos Totales\",\n            value=f\"${ingresos_totales:,.0f}\",\n            delta=f\"{cambio_ingresos:+.1f}%\" if ingresos_anteriores > 0 else None\n        )\n    \n    with col2:\n        st.metric(\n            label=\"üõí Pedidos Totales\",\n            value=f\"{pedidos_totales:,}\",\n            delta=f\"{cambio_pedidos:+.1f}%\" if pedidos_anteriores > 0 else None\n        )\n    \n    with col3:\n        st.metric(\n            label=\"üéØ Ticket Promedio (AOV)\",\n            value=f\"${ticket_promedio:,.0f}\"\n        )\n    \n    with col4:\n        st.metric(\n            label=\"üíé Beneficio Total\",\n            value=f\"${beneficio_total:,.0f}\"\n        )\n    \n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    \n    col5, col6, col7, col8 = st.columns(4)\n    \n    with col5:\n        st.metric(\n            label=\"üë• Clientes √önicos\",\n            value=f\"{clientes_unicos:,}\"\n        )\n    \n    with col6:\n        productos_unicos = datos_filtrados['product_id'].nunique()\n        st.metric(\n            label=\"üì¶ Productos Vendidos\",\n            value=f\"{productos_unicos:,}\"\n        )\n    \n    with col7:\n        tasa_conversion = (clientes_unicos / pedidos_totales * 100) if pedidos_totales > 0 else 0\n        st.metric(\n            label=\"üéØ Tasa de Conversi√≥n\",\n            value=f\"{tasa_conversion:.1f}%\"\n        )\n    \n    with col8:\n        items_promedio = datos_filtrados['quantity'].mean()\n        st.metric(\n            label=\"üìä Items por Pedido\",\n            value=f\"{items_promedio:.1f}\"\n        )\n    \n    # Secci√≥n de Insights Ejecutivos Autom√°ticos\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    crear_seccion_titulo(\"üí° Insights Ejecutivos y Recomendaciones\")\n    \n    # Calcular m√©tricas adicionales para insights (con protecci√≥n contra divisi√≥n por cero)\n    if ingresos_totales > 0:\n        top_pais = datos_filtrados.groupby('country')['total_amount_usd'].sum().idxmax()\n        ingresos_top_pais = datos_filtrados.groupby('country')['total_amount_usd'].sum().max()\n        porcentaje_top_pais = (ingresos_top_pais / ingresos_totales * 100)\n        \n        top_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().idxmax()\n        ingresos_top_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().max()\n        porcentaje_top_categoria = (ingresos_top_categoria / ingresos_totales * 100)\n    else:\n        top_pais = \"N/A\"\n        ingresos_top_pais = 0\n        porcentaje_top_pais = 0\n        top_categoria = \"N/A\"\n        ingresos_top_categoria = 0\n        porcentaje_top_categoria = 0\n    \n    # Generar insights autom√°ticos\n    insights_ejecutivos = []\n    \n    # Verificar si hay datos suficientes para generar insights\n    if ingresos_totales == 0 or pedidos_totales == 0:\n        insights_ejecutivos.append(\n            f\"‚ÑπÔ∏è **Sin Datos Disponibles:** No hay transacciones registradas en el per√≠odo y filtros seleccionados. \"\n            f\"Ajusta los criterios de b√∫squeda en el sidebar para analizar diferentes per√≠odos o segmentos.\"\n        )\n    else:\n        # Insight 1: Rendimiento general\n        if cambio_ingresos > 10:\n            insights_ejecutivos.append(\n                f\"üìà **Crecimiento Acelerado:** Los ingresos han crecido un {cambio_ingresos:.1f}% comparado con el per√≠odo anterior, \"\n                f\"superando ${ingresos_totales:,.0f}. Este momentum positivo indica una fuerte demanda y efectividad en las estrategias comerciales.\"\n            )\n        elif cambio_ingresos < -10:\n            insights_ejecutivos.append(\n                f\"‚ö†Ô∏è **Alerta de Desaceleraci√≥n:** Los ingresos han disminuido un {abs(cambio_ingresos):.1f}% comparado con el per√≠odo anterior. \"\n                f\"Se recomienda revisar estrategias de marketing, competencia y satisfacci√≥n del cliente.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"üìä **Estabilidad Controlada:** Los ingresos se mantienen estables con una variaci√≥n de {cambio_ingresos:+.1f}% respecto al per√≠odo anterior, \"\n                f\"totalizando ${ingresos_totales:,.0f}. Existen oportunidades de optimizaci√≥n para impulsar el crecimiento.\"\n            )\n        \n        # Insight 2: Concentraci√≥n geogr√°fica\n        if porcentaje_top_pais > 50:\n            insights_ejecutivos.append(\n                f\"üåç **Concentraci√≥n de Mercado:** {top_pais} representa el {porcentaje_top_pais:.1f}% de los ingresos totales \"\n                f\"(${ingresos_top_pais:,.0f}). Esta alta dependencia presenta riesgo. Se recomienda diversificar geogr√°ficamente.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"üåç **Diversificaci√≥n Saludable:** {top_pais} lidera con {porcentaje_top_pais:.1f}% de ingresos, pero existe buena \"\n                f\"distribuci√≥n geogr√°fica, reduciendo el riesgo de dependencia de un solo mercado.\"\n            )\n        \n        # Insight 3: Producto estrella\n        insights_ejecutivos.append(\n            f\"‚≠ê **Categor√≠a L√≠der:** {top_categoria} domina el portafolio con {porcentaje_top_categoria:.1f}% de los ingresos \"\n            f\"(${ingresos_top_categoria:,.0f}). Reforzar inventario y marketing en esta categor√≠a puede maximizar resultados.\"\n        )\n        \n        # Insight 4: Eficiencia operativa\n        if ticket_promedio > 100:\n            insights_ejecutivos.append(\n                f\"üíé **Alto Valor por Transacci√≥n:** El ticket promedio de ${ticket_promedio:,.0f} indica clientes de alto valor. \"\n                f\"Enfocar estrategias de retenci√≥n y programas VIP puede aumentar la rentabilidad.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"üéØ **Oportunidad de Upselling:** Con un ticket promedio de ${ticket_promedio:,.0f}, existe potencial para incrementar \"\n                f\"el valor por pedido mediante bundling, recomendaciones personalizadas y ofertas complementarias.\"\n            )\n    \n    # Mostrar insights\n    for insight in insights_ejecutivos:\n        crear_insight(\"\", insight)\n    \n    # Recomendaciones accionables\n    recomendaciones_ejecutivas = [\n        f\"üîç **An√°lisis Geogr√°fico:** Explorar la pesta√±a 'An√°lisis Geogr√°fico' para identificar mercados emergentes con alto potencial de crecimiento\",\n        f\"üìä **Forecasting:** Revisar las predicciones en 'Forecasting & Tendencias' para planificar inventario y presupuestos de los pr√≥ximos 90 d√≠as\",\n        f\"üë• **Segmentaci√≥n:** Analizar 'Segmentaci√≥n de Clientes' para identificar clientes Champions y en riesgo de churn, personalizando estrategias\",\n        f\"ü§ñ **ML Insights:** Activar an√°lisis ML en el sidebar para detectar anomal√≠as, patrones ocultos y oportunidades de optimizaci√≥n autom√°tica\",\n        f\"üí∞ **An√°lisis Financiero:** Verificar m√°rgenes y rentabilidad en 'An√°lisis Financiero' para asegurar la salud del negocio\"\n    ]\n    \n    crear_recomendaciones(\"üéØ Acciones Recomendadas\", recomendaciones_ejecutivas)\n    \n    crear_seccion_titulo(\"Evoluci√≥n Temporal\")\n    \n    datos_temporales = datos_filtrados.copy()\n    datos_temporales['fecha'] = pd.to_datetime(datos_temporales['date'])\n    datos_temporales_agrupados = datos_temporales.groupby(datos_temporales['fecha'].dt.to_period('M')).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count',\n        'profit': 'sum'\n    }).reset_index()\n    datos_temporales_agrupados['fecha'] = datos_temporales_agrupados['fecha'].dt.to_timestamp()\n    datos_temporales_agrupados.columns = ['Fecha', 'Ingresos', 'Pedidos', 'Beneficio']\n    \n    # Crear figura con eje secundario\n    fig_evolucion = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    # Agregar l√≠neas de ingresos y beneficio en eje principal\n    fig_evolucion.add_trace(\n        go.Scatter(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Ingresos'],\n            name='Ingresos',\n            line=dict(color='#667eea', width=3),\n            mode='lines'\n        ),\n        secondary_y=False\n    )\n    \n    fig_evolucion.add_trace(\n        go.Scatter(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Beneficio'],\n            name='Beneficio',\n            line=dict(color='#10B981', width=2),\n            mode='lines'\n        ),\n        secondary_y=False\n    )\n    \n    # Agregar barras de pedidos en eje secundario\n    fig_evolucion.add_trace(\n        go.Bar(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Pedidos'],\n            name='Pedidos',\n            marker_color='rgba(245, 158, 11, 0.3)',\n            marker_line_color='#F59E0B',\n            marker_line_width=1\n        ),\n        secondary_y=True\n    )\n    \n    # Configurar ejes\n    fig_evolucion.update_yaxes(title_text=\"Ingresos / Beneficio ($)\", secondary_y=False)\n    fig_evolucion.update_yaxes(title_text=\"Pedidos\", secondary_y=True)\n    fig_evolucion.update_xaxes(title_text=\"Fecha\")\n    \n    fig_evolucion.update_layout(\n        title='Evoluci√≥n Mensual de Ingresos, Beneficio y Pedidos',\n        height=500,\n        showlegend=True,\n        hovermode='x unified',\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font=dict(family='Inter', size=12),\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=1.02,\n            xanchor=\"right\",\n            x=1\n        )\n    )\n    \n    fig_evolucion.update_xaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    fig_evolucion.update_yaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    \n    st.plotly_chart(fig_evolucion, use_container_width=True)\n    \n    crear_seccion_titulo(\"Distribuciones Clave\")\n    \n    col_dist1, col_dist2 = st.columns(2)\n    \n    with col_dist1:\n        top_paises = datos_filtrados.groupby('country')['total_amount_usd'].sum().nlargest(10).reset_index()\n        fig_paises = px.bar(\n            top_paises,\n            x='total_amount_usd',\n            y='country',\n            orientation='h',\n            title='Top 10 Pa√≠ses por Ingresos',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_paises.update_layout(\n            showlegend=False,\n            height=400,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)'\n        )\n        fig_paises.update_traces(hovertemplate='<b>%{y}</b><br>Ingresos: $%{x:,.0f}<extra></extra>')\n        st.plotly_chart(fig_paises, use_container_width=True)\n    \n    with col_dist2:\n        por_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().reset_index()\n        fig_categorias = px.pie(\n            por_categoria,\n            values='total_amount_usd',\n            names='category',\n            title='Distribuci√≥n de Ingresos por Categor√≠a',\n            color_discrete_sequence=px.colors.qualitative.Set3,\n            hole=0.4\n        )\n        fig_categorias.update_layout(\n            height=400,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)'\n        )\n        fig_categorias.update_traces(\n            textposition='inside', \n            textinfo='percent+label',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<br>Porcentaje: %{percent}<extra></extra>'\n        )\n        st.plotly_chart(fig_categorias, use_container_width=True)\n\nwith tab_geografia:\n    crear_descripcion_seccion(\n        \"An√°lisis de Distribuci√≥n Geogr√°fica\",\n        \"Visualiza c√≥mo se distribuyen tus ventas alrededor del mundo. Identifica los mercados m√°s rentables, \"\n        \"pa√≠ses con mayor potencial de crecimiento y oportunidades de expansi√≥n internacional. El mapa de calor \"\n        \"muestra la intensidad de ventas por pa√≠s.\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis Geogr√°fico Global\")\n    \n    col1, col2 = st.columns([7, 3])\n    \n    with col1:\n        st.subheader(\"Mapa Mundial de Ventas\")\n        \n        # Mapeo de nombres de pa√≠ses (en espa√±ol) a c√≥digos ISO 3\n        country_iso_map = {\n            'Reino Unido': 'GBR', 'Estados Unidos': 'USA', 'Alemania': 'DEU', \n            'Francia': 'FRA', 'China': 'CHN', 'Canad√°': 'CAN', 'Jap√≥n': 'JPN',\n            'Australia': 'AUS', 'Espa√±a': 'ESP', 'Italia': 'ITA', 'Pa√≠ses Bajos': 'NLD',\n            'B√©lgica': 'BEL', 'Suiza': 'CHE', 'Suecia': 'SWE', 'Austria': 'AUT',\n            'Noruega': 'NOR', 'Dinamarca': 'DNK', 'Finlandia': 'FIN', 'Polonia': 'POL',\n            'Portugal': 'PRT', 'Grecia': 'GRC', 'Rep√∫blica Checa': 'CZE',\n            'Irlanda': 'IRL', 'Singapur': 'SGP', 'Corea del Sur': 'KOR',\n            'India': 'IND', 'Brasil': 'BRA', 'M√©xico': 'MEX', 'Israel': 'ISR',\n            'Arabia Saudita': 'SAU', 'Emiratos √Årabes Unidos': 'ARE', 'Sud√°frica': 'ZAF',\n            'Chipre': 'CYP', 'Malta': 'MLT', 'Islandia': 'ISL', 'Lituania': 'LTU',\n            'Bar√©in': 'BHR', 'L√≠bano': 'LBN', 'Comunidad Europea': None\n        }\n        \n        datos_pais = datos_filtrados.groupby('country').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count',\n            'customer_id': 'nunique'\n        }).reset_index()\n        datos_pais.columns = ['country', 'ingresos', 'pedidos', 'clientes']\n        datos_pais['aov'] = datos_pais['ingresos'] / datos_pais['pedidos']\n        \n        # Agregar c√≥digos ISO\n        datos_pais['iso_code'] = datos_pais['country'].map(country_iso_map)\n        # Filtrar pa√≠ses sin c√≥digo ISO v√°lido\n        datos_pais_validos = datos_pais[datos_pais['iso_code'].notna()].copy()\n        \n        fig_mapa = px.choropleth(\n            datos_pais_validos,\n            locations='iso_code',\n            locationmode='ISO-3',\n            color='ingresos',\n            hover_name='country',\n            hover_data={\n                'iso_code': False,\n                'ingresos': ':$,.0f',\n                'pedidos': ':,',\n                'clientes': ':,',\n                'aov': ':$,.2f'\n            },\n            color_continuous_scale='Viridis',\n            title='Ingresos por Pa√≠s',\n            labels={'ingresos': 'Ingresos', 'pedidos': 'Pedidos', 'clientes': 'Clientes', 'aov': 'Ticket Promedio'}\n        )\n        fig_mapa.update_layout(\n            height=500, \n            margin=dict(l=0, r=0, t=30, b=0),\n            geo=dict(showframe=False, showcoastlines=True, projection_type='natural earth')\n        )\n        st.plotly_chart(fig_mapa, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Top 15 Pa√≠ses\")\n        top_paises = datos_pais.nlargest(15, 'ingresos')\n        \n        fig_top = px.bar(\n            top_paises,\n            y='country',\n            x='ingresos',\n            orientation='h',\n            color='ingresos',\n            color_continuous_scale='Blues',\n            title='Ingresos por Pa√≠s (Top 15)',\n            labels=LABELS\n        )\n        fig_top.update_traces(hovertemplate='<b>%{y}</b><br>Ingresos: $%{x:,.0f}<extra></extra>')\n        fig_top.update_layout(\n            height=500,\n            showlegend=False,\n            yaxis={'categoryorder': 'total ascending'}\n        )\n        st.plotly_chart(fig_top, use_container_width=True)\n    \n    col3, col4 = st.columns(2)\n    \n    with col3:\n        st.subheader(\"Jerarqu√≠a Geogr√°fica (Treemap)\")\n        \n        datos_tree_geo = datos_filtrados.groupby(['country', 'category']).agg({\n            'total_amount_usd': 'sum'\n        }).reset_index()\n        datos_tree_geo.rename(columns={'total_amount_usd': 'ingresos'}, inplace=True)\n        \n        fig_tree = px.treemap(\n            datos_tree_geo,\n            path=['country', 'category'],\n            values='ingresos',\n            color='ingresos',\n            color_continuous_scale='RdYlGn',\n            title='Jerarqu√≠a: Pa√≠s ‚Üí Categor√≠a'\n        )\n        \n        fig_tree.update_traces(\n            textinfo='label+value',\n            texttemplate='<b>%{label}</b><br>$%{value:,.0f}',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<extra></extra>'\n        )\n        \n        fig_tree.update_layout(height=400)\n        st.plotly_chart(fig_tree, use_container_width=True)\n    \n    with col4:\n        st.subheader(\"Concentraci√≥n de Ventas\")\n        top10_paises = datos_pais.nlargest(10, 'ingresos')\n        otros_ingresos = datos_pais[~datos_pais['country'].isin(top10_paises['country'])]['ingresos'].sum()\n        \n        if otros_ingresos > 0:\n            otros_df = pd.DataFrame({'country': ['Otros'], 'ingresos': [otros_ingresos]})\n            datos_pie = pd.concat([top10_paises[['country', 'ingresos']], otros_df])\n        else:\n            datos_pie = top10_paises[['country', 'ingresos']]\n        \n        fig_pie = px.pie(\n            datos_pie,\n            values='ingresos',\n            names='country',\n            title='Distribuci√≥n de Ingresos (Top 10 + Otros)',\n            hole=0.4\n        )\n        fig_pie.update_traces(hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<br>Porcentaje: %{percent}<extra></extra>')\n        fig_pie.update_layout(height=400)\n        st.plotly_chart(fig_pie, use_container_width=True)\n\nwith tab_rendimiento:\n    crear_descripcion_seccion(\n        \"An√°lisis de Rendimiento y Tendencias Temporales\",\n        \"Analiza la evoluci√≥n de tus ventas a lo largo del tiempo, identifica patrones de crecimiento y estacionalidad. \"\n        \"Compara per√≠odos, detecta tendencias y toma decisiones basadas en el comportamiento hist√≥rico de tu negocio. \"\n        \"Los indicadores de crecimiento te ayudan a planificar estrategias, ajustar inventario y optimizar recursos.\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis Temporal de Rendimiento\")\n    \n    st.subheader(\"Ingresos y Pedidos a lo Largo del Tiempo\")\n    \n    granularidad = st.selectbox(\n        \"Granularidad Temporal\",\n        ['D√≠a', 'Semana', 'Mes'],\n        index=1,\n        help=\"Selecciona el nivel de agregaci√≥n temporal para el an√°lisis\"\n    )\n    \n    temp_df = datos_filtrados.copy()\n    if granularidad == 'D√≠a':\n        temp_df['periodo'] = temp_df['date'].dt.date\n    elif granularidad == 'Semana':\n        temp_df['periodo'] = temp_df['date'].dt.to_period('W').dt.start_time\n    else:\n        temp_df['periodo'] = temp_df['date'].dt.to_period('M').dt.start_time\n    \n    serie_temporal = temp_df.groupby('periodo').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    serie_temporal.columns = ['periodo', 'ingresos', 'pedidos']\n    \n    fig_tiempo = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    fig_tiempo.add_trace(\n        go.Bar(x=serie_temporal['periodo'], y=serie_temporal['ingresos'], name='Ingresos', marker_color='#667eea'),\n        secondary_y=False\n    )\n    \n    fig_tiempo.add_trace(\n        go.Scatter(x=serie_temporal['periodo'], y=serie_temporal['pedidos'], name='Pedidos', \n                   line=dict(color='#f093fb', width=3), mode='lines+markers'),\n        secondary_y=True\n    )\n    \n    fig_tiempo.update_xaxes(title_text=\"Fecha\")\n    fig_tiempo.update_yaxes(title_text=\"Ingresos ($)\", secondary_y=False)\n    fig_tiempo.update_yaxes(title_text=\"Pedidos\", secondary_y=True)\n    fig_tiempo.update_layout(height=400, title='Evoluci√≥n de Ingresos y Pedidos')\n    \n    st.plotly_chart(fig_tiempo, use_container_width=True)\n    \n    #An√°lisis de Crecimiento y Momentum\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    crear_seccion_titulo(\"Indicadores de Crecimiento\")\n    \n    # Calcular per√≠odos para comparaci√≥n\n    datos_actuales = datos_filtrados.copy()\n    fecha_fin_actual = datos_actuales['date'].max()\n    fecha_inicio_actual = datos_actuales['date'].min()\n    duracion_dias = (fecha_fin_actual - fecha_inicio_actual).days\n    \n    # Per√≠odo anterior (mismo n√∫mero de d√≠as hacia atr√°s)\n    fecha_fin_anterior = fecha_inicio_actual - pd.Timedelta(days=1)\n    fecha_inicio_anterior = fecha_fin_anterior - pd.Timedelta(days=duracion_dias)\n    \n    # Aplicar LOS MISMOS filtros al per√≠odo anterior (excepto fechas)\n    filtros_periodo_anterior = filtros.copy()\n    filtros_periodo_anterior['fecha_inicio'] = fecha_inicio_anterior\n    filtros_periodo_anterior['fecha_fin'] = fecha_fin_anterior\n    \n    datos_periodo_anterior = aplicar_filtros(transacciones_df, filtros_periodo_anterior)\n    \n    # M√©tricas de comparaci√≥n\n    ingresos_actual = datos_actuales['total_amount_usd'].sum()\n    ingresos_anterior = datos_periodo_anterior['total_amount_usd'].sum()\n    \n    pedidos_actual = len(datos_actuales)\n    pedidos_anterior = len(datos_periodo_anterior)\n    \n    # Calcular variaciones\n    var_ingresos = ((ingresos_actual - ingresos_anterior) / ingresos_anterior * 100) if ingresos_anterior > 0 else 0\n    var_pedidos = ((pedidos_actual - pedidos_anterior) / pedidos_anterior * 100) if pedidos_anterior > 0 else 0\n    \n    # KPIs de crecimiento\n    col_crec1, col_crec2, col_crec3, col_crec4 = st.columns(4)\n    \n    with col_crec1:\n        st.metric(\n            \"Variaci√≥n vs Per√≠odo Anterior\",\n            f\"{var_ingresos:+.1f}%\",\n            delta=f\"${ingresos_actual - ingresos_anterior:,.0f}\"\n        )\n    \n    with col_crec2:\n        st.metric(\n            \"Crecimiento en Pedidos\",\n            f\"{var_pedidos:+.1f}%\",\n            delta=f\"{pedidos_actual - pedidos_anterior:,} pedidos\"\n        )\n    \n    with col_crec3:\n        # Tasa de crecimiento promedio diaria\n        if duracion_dias > 0:\n            crecimiento_diario = var_ingresos / duracion_dias\n            st.metric(\n                \"Tasa Diaria Promedio\",\n                f\"{crecimiento_diario:+.2f}%/d√≠a\"\n            )\n        else:\n            st.metric(\"Tasa Diaria Promedio\", \"N/A\")\n    \n    with col_crec4:\n        # Momentum (aceleraci√≥n)\n        if var_ingresos > 10:\n            momentum = \"Acelerado ‚¨ÜÔ∏è\"\n            momentum_color = \"green\"\n        elif var_ingresos < -10:\n            momentum = \"Desacelerado ‚¨áÔ∏è\"\n            momentum_color = \"red\"\n        else:\n            momentum = \"Estable ‚û°Ô∏è\"\n            momentum_color = \"gray\"\n        \n        st.metric(\"Momentum\", momentum)\n    \n    # An√°lisis de Tendencias con Promedio M√≥vil\n    if len(serie_temporal) > 7:\n        st.markdown(\"<br>\", unsafe_allow_html=True)\n        st.subheader(\"üìä An√°lisis de Tendencias (Promedio M√≥vil)\")\n        \n        # Calcular promedio m√≥vil seg√∫n granularidad\n        if granularidad == 'D√≠a':\n            ventana_corta = 7\n            ventana_larga = 30\n            label_corta = \"7 d√≠as\"\n            label_larga = \"30 d√≠as\"\n        elif granularidad == 'Semana':\n            ventana_corta = 4\n            ventana_larga = 12\n            label_corta = \"4 semanas\"\n            label_larga = \"12 semanas\"\n        else:  # Mes\n            ventana_corta = 3\n            ventana_larga = 6\n            label_corta = \"3 meses\"\n            label_larga = \"6 meses\"\n        \n        serie_temporal_sorted = serie_temporal.sort_values('periodo').copy()\n        \n        if len(serie_temporal_sorted) >= ventana_corta:\n            serie_temporal_sorted[f'ma_{ventana_corta}'] = serie_temporal_sorted['ingresos'].rolling(window=ventana_corta, min_periods=1).mean()\n        \n        if len(serie_temporal_sorted) >= ventana_larga:\n            serie_temporal_sorted[f'ma_{ventana_larga}'] = serie_temporal_sorted['ingresos'].rolling(window=ventana_larga, min_periods=1).mean()\n        \n        fig_tendencias = go.Figure()\n        \n        # Datos reales\n        fig_tendencias.add_trace(go.Scatter(\n            x=serie_temporal_sorted['periodo'],\n            y=serie_temporal_sorted['ingresos'],\n            mode='lines+markers',\n            name='Ingresos Reales',\n            line=dict(color='rgba(102, 126, 234, 0.4)', width=1),\n            marker=dict(size=4, color='#667eea')\n        ))\n        \n        # Promedio m√≥vil corto\n        if f'ma_{ventana_corta}' in serie_temporal_sorted.columns:\n            fig_tendencias.add_trace(go.Scatter(\n                x=serie_temporal_sorted['periodo'],\n                y=serie_temporal_sorted[f'ma_{ventana_corta}'],\n                mode='lines',\n                name=f'Tendencia {label_corta}',\n                line=dict(color='#10B981', width=3)\n            ))\n        \n        # Promedio m√≥vil largo\n        if f'ma_{ventana_larga}' in serie_temporal_sorted.columns:\n            fig_tendencias.add_trace(go.Scatter(\n                x=serie_temporal_sorted['periodo'],\n                y=serie_temporal_sorted[f'ma_{ventana_larga}'],\n                mode='lines',\n                name=f'Tendencia {label_larga}',\n                line=dict(color='#F59E0B', width=2, dash='dash')\n            ))\n        \n        fig_tendencias.update_layout(\n            title=f'Tendencias de Ingresos con Promedio M√≥vil ({granularidad})',\n            xaxis_title='Fecha',\n            yaxis_title='Ingresos (USD)',\n            height=450,\n            hovermode='x unified',\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            )\n        )\n        \n        st.plotly_chart(fig_tendencias, use_container_width=True)\n        \n        # Insights autom√°ticos de tendencias\n        if f'ma_{ventana_corta}' in serie_temporal_sorted.columns and f'ma_{ventana_larga}' in serie_temporal_sorted.columns:\n            ultima_corta = serie_temporal_sorted[f'ma_{ventana_corta}'].iloc[-1]\n            ultima_larga = serie_temporal_sorted[f'ma_{ventana_larga}'].iloc[-1]\n            \n            if ultima_corta > ultima_larga * 1.05:\n                st.success(f\"‚úÖ **Tendencia Positiva:** La tendencia de {label_corta} est√° {((ultima_corta/ultima_larga - 1) * 100):.1f}% por encima de la tendencia de {label_larga}, indicando aceleraci√≥n en el crecimiento.\")\n            elif ultima_corta < ultima_larga * 0.95:\n                st.warning(f\"‚ö†Ô∏è **Alerta de Desaceleraci√≥n:** La tendencia de {label_corta} est√° {((1 - ultima_corta/ultima_larga) * 100):.1f}% por debajo de la tendencia de {label_larga}, sugiriendo una desaceleraci√≥n reciente.\")\n            else:\n                st.info(f\"‚ÑπÔ∏è **Tendencia Estable:** Las tendencias de {label_corta} y {label_larga} est√°n alineadas, indicando un crecimiento constante y predecible.\")\n    \n    col_dist1, col_dist2 = st.columns(2)\n    \n    with col_dist1:\n        st.subheader(\"Distribuci√≥n de Ingresos por D√≠a de Semana\")\n        from utils.traducciones import traducir_dia_semana\n        temp_df['dia_semana'] = pd.to_datetime(temp_df['date']).dt.day_name()\n        ingresos_dia = temp_df.groupby('dia_semana')['total_amount_usd'].sum().reset_index()\n        dias_orden = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        ingresos_dia['dia_semana'] = pd.Categorical(ingresos_dia['dia_semana'], categories=dias_orden, ordered=True)\n        ingresos_dia = ingresos_dia.sort_values('dia_semana')\n        # Traducir d√≠as al espa√±ol\n        ingresos_dia['dia_semana_es'] = ingresos_dia['dia_semana'].apply(traducir_dia_semana)\n        \n        fig_dias = px.bar(\n            ingresos_dia,\n            x='dia_semana_es',\n            y='total_amount_usd',\n            title='Ingresos por D√≠a de la Semana',\n            labels={'dia_semana_es': '', 'total_amount_usd': 'Ingresos (USD)'},\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_dias.update_layout(height=400, showlegend=False)\n        fig_dias.update_traces(hovertemplate='<b>%{x}</b><br>Ingresos: $%{y:,.0f}<extra></extra>')\n        st.plotly_chart(fig_dias, use_container_width=True)\n    \n    with col_dist2:\n        st.subheader(\"Distribuci√≥n de Ingresos por Hora\")\n        temp_df['hora'] = pd.to_datetime(temp_df['date']).dt.hour\n        ingresos_hora = temp_df.groupby('hora')['total_amount_usd'].sum().reset_index()\n        \n        fig_horas = px.line(\n            ingresos_hora,\n            x='hora',\n            y='total_amount_usd',\n            title='Ingresos por Hora del D√≠a',\n            labels=LABELS,\n            markers=True\n        )\n        fig_horas.update_traces(\n            line_color='#F59E0B', \n            line_width=3,\n            hovertemplate='<b>Hora %{x}:00</b><br>Ingresos: $%{y:,.0f}<extra></extra>'\n        )\n        fig_horas.update_layout(height=400)\n        st.plotly_chart(fig_horas, use_container_width=True)\n\nwith tab_productos:\n    crear_descripcion_seccion(\n        \"Rendimiento y Estrategia de Productos\",\n        \"Analiza qu√© productos generan m√°s ingresos, cu√°les tienen mejor margen y c√≥mo se distribuyen por categor√≠as. \"\n        \"La Matriz BCG clasifica tus productos en: **Alto Rendimiento** (altos ingresos, alta frecuencia), **Consolidados** (altos ingresos, frecuencia media), \"\n        \"**Alto Potencial** (potencial de crecimiento) y **En Evaluaci√≥n** (requieren optimizaci√≥n o descontinuaci√≥n).\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis de Productos\")\n    \n    st.subheader(\"Top 20 Productos por Ingresos\")\n    \n    # Filtrar productos no significativos (costos de env√≠o, productos gen√©ricos)\n    productos_excluir = ['Manual', 'POSTAGE', 'DOTCOM POSTAGE', 'Adjust bad debt', 'BANK CHARGES']\n    datos_productos_reales = datos_filtrados[~datos_filtrados['product_name'].isin(productos_excluir)]\n    \n    top_productos = datos_productos_reales.groupby(['product_id', 'product_name', 'category']).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count',\n        'quantity': 'sum',\n        'profit': 'sum'\n    }).reset_index().nlargest(20, 'total_amount_usd')\n    \n    fig_productos = px.bar(\n        top_productos,\n        x='total_amount_usd',\n        y='product_name',\n        orientation='h',\n        title='Top 20 Productos por Ingresos (excl. env√≠os)',\n        labels=LABELS,\n        color='category',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['category', 'profit']\n    )\n    fig_productos.update_traces(hovertemplate='<b>%{y}</b><br>Categor√≠a: %{customdata[0]}<br>Ingresos: $%{x:,.0f}<br>Beneficio: $%{customdata[1]:,.0f}<extra></extra>')\n    fig_productos.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_productos, use_container_width=True)\n    \n    st.subheader(\"Top 15 Productos M√°s Comprados\")\n    \n    top_comprados = datos_productos_reales.groupby(['product_id', 'product_name', 'category']).agg({\n        'quantity': 'sum',\n        'transaction_id': 'count',\n        'total_amount_usd': 'sum'\n    }).reset_index().nlargest(15, 'quantity')\n    \n    fig_comprados = px.bar(\n        top_comprados,\n        x='quantity',\n        y='product_name',\n        orientation='h',\n        title='Top 15 Productos por Unidades Vendidas (excl. env√≠os)',\n        labels=LABELS,\n        color='category',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['category', 'transaction_id']\n    )\n    fig_comprados.update_traces(hovertemplate='<b>%{y}</b><br>Categor√≠a: %{customdata[0]}<br>Unidades: %{x:,.0f}<br>Transacciones: %{customdata[1]:,.0f}<extra></extra>')\n    fig_comprados.update_layout(height=450, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_comprados, use_container_width=True)\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Ingresos por Categor√≠a (Treemap)\")\n        datos_categoria = datos_filtrados.groupby(['category', 'subcategory']).agg({\n            'total_amount_usd': 'sum'\n        }).reset_index()\n        \n        fig_tree_cat = px.treemap(\n            datos_categoria,\n            path=['category', 'subcategory'],\n            values='total_amount_usd',\n            title='Jerarqu√≠a de Categor√≠as',\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        \n        fig_tree_cat.update_traces(\n            textinfo='label+value',\n            texttemplate='<b>%{label}</b><br>$%{value:,.0f}',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<extra></extra>'\n        )\n        \n        fig_tree_cat.update_layout(height=400)\n        st.plotly_chart(fig_tree_cat, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Margen por Categor√≠a\")\n        margen_cat = datos_filtrados.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        margen_cat['margen_%'] = (margen_cat['profit'] / margen_cat['total_amount_usd'] * 100)\n        \n        fig_margen = px.bar(\n            margen_cat.sort_values('margen_%', ascending=False),\n            x='category',\n            y='margen_%',\n            title='Margen de Beneficio por Categor√≠a (%)',\n            labels=LABELS,\n            color='margen_%',\n            color_continuous_scale='RdYlGn'\n        )\n        fig_margen.update_traces(hovertemplate='<b>%{x}</b><br>Margen: %{y:.1f}%<extra></extra>')\n        fig_margen.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_margen, use_container_width=True)\n    \n    st.subheader(\"An√°lisis de Performance de Productos (Matriz BCG)\")\n    \n    # Usar los mismos datos filtrados (productos reales, sin env√≠os)\n    productos_bcg = datos_productos_reales.groupby(['product_id', 'product_name']).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    productos_bcg.columns = ['product_id', 'producto', 'ingresos', 'frecuencia']\n    productos_bcg['ingresos_formato'] = productos_bcg['ingresos'].apply(lambda x: f\"${x:,.0f}\")\n    \n    mediana_ingresos = productos_bcg['ingresos'].median()\n    mediana_frecuencia = productos_bcg['frecuencia'].median()\n    \n    def clasificar_bcg(row):\n        if row['ingresos'] >= mediana_ingresos and row['frecuencia'] >= mediana_frecuencia:\n            return 'Alto Rendimiento'\n        elif row['ingresos'] >= mediana_ingresos and row['frecuencia'] < mediana_frecuencia:\n            return 'Alto Potencial'\n        elif row['ingresos'] < mediana_ingresos and row['frecuencia'] >= mediana_frecuencia:\n            return 'Consolidados'\n        else:\n            return 'En Evaluaci√≥n'\n    \n    productos_bcg['cuadrante'] = productos_bcg.apply(clasificar_bcg, axis=1)\n    \n    # Mejorar visualizaci√≥n: usar escala logar√≠tmica y tama√±os m√°s uniformes\n    productos_bcg_muestra = productos_bcg.sample(min(500, len(productos_bcg)))\n    \n    # A√±adir tama√±o normalizado para mejor visualizaci√≥n\n    productos_bcg_muestra['size_viz'] = np.log1p(productos_bcg_muestra['ingresos']) * 10\n    \n    fig_bcg = px.scatter(\n        productos_bcg_muestra,\n        x='frecuencia',\n        y='ingresos',\n        color='cuadrante',\n        size='size_viz',\n        hover_data={'producto': True, 'ingresos_formato': True, 'frecuencia': True, 'ingresos': False, 'cuadrante': False, 'size_viz': False},\n        title='Matriz BCG de Productos',\n        labels=LABELS,\n        color_discrete_map={\n            'Alto Rendimiento': '#10B981',\n            'Consolidados': '#3B82F6',\n            'Alto Potencial': '#F59E0B',\n            'En Evaluaci√≥n': '#EF4444'\n        },\n        log_y=True\n    )\n    \n    fig_bcg.update_traces(\n        hovertemplate='<b>%{customdata[0]}</b><br>Ingresos: %{customdata[1]}<br>Frecuencia: %{customdata[2]} pedidos<extra></extra>',\n        marker=dict(\n            line=dict(width=1, color='white'),\n            opacity=0.7\n        )\n    )\n    \n    fig_bcg.add_hline(y=mediana_ingresos, line_dash=\"dash\", line_color=\"white\", line_width=2, annotation_text=\"Mediana Ingresos\", annotation_position=\"right\")\n    fig_bcg.add_vline(x=mediana_frecuencia, line_dash=\"dash\", line_color=\"white\", line_width=2, annotation_text=\"Mediana Frecuencia\", annotation_position=\"top\")\n    fig_bcg.update_layout(\n        height=550,\n        yaxis_title=\"Ingresos (USD) - Escala Logar√≠tmica\",\n        xaxis_title=\"Frecuencia de Compra (pedidos)\",\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"right\",\n            x=0.99\n        )\n    )\n    st.plotly_chart(fig_bcg, use_container_width=True)\n    \n    col_resumen = st.columns(4)\n    for idx, cuadrante in enumerate(['Alto Rendimiento', 'Consolidados', 'Alto Potencial', 'En Evaluaci√≥n']):\n        with col_resumen[idx]:\n            count = len(productos_bcg[productos_bcg['cuadrante'] == cuadrante])\n            st.metric(cuadrante, f\"{count} productos\")\n\nwith tab_clientes:\n    crear_descripcion_seccion(\n        \"Conoce a Tus Clientes en Profundidad\",\n        \"Esta secci√≥n te permite entender qui√©nes son tus mejores clientes, cu√°les est√°n en riesgo de abandonar y c√≥mo puedes \"\n        \"personalizar tu estrategia para cada segmento. El an√°lisis RFM eval√∫a cu√°n recientemente compraron, con qu√© frecuencia \"\n        \"y cu√°nto gastan, clasific√°ndolos en 11 segmentos desde Campeones hasta Perdidos.\"\n    )\n    \n    crear_seccion_titulo(\"Segmentaci√≥n de Clientes\")\n    \n    st.subheader(\"An√°lisis RFM (Recencia, Frecuencia, Monetario)\")\n    \n    clientes_filt = clientes_df[clientes_df['customer_id'].isin(datos_filtrados['customer_id'].unique())]\n    \n    rfm_segments = clientes_filt['rfm_segment'].value_counts().reset_index()\n    rfm_segments.columns = ['segmento', 'cantidad']\n    \n    col1, col2 = st.columns([6, 4])\n    \n    with col1:\n        fig_rfm = px.bar(\n            rfm_segments.sort_values('cantidad', ascending=False),\n            x='segmento',\n            y='cantidad',\n            title='Distribuci√≥n de Clientes por Segmento RFM',\n            labels=LABELS,\n            color='cantidad',\n            color_continuous_scale='Viridis'\n        )\n        fig_rfm.update_traces(hovertemplate='<b>%{x}</b><br>Clientes: %{y:,}<extra></extra>')\n        fig_rfm.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_rfm, use_container_width=True)\n    \n    with col2:\n        fig_rfm_pie = px.pie(\n            rfm_segments,\n            values='cantidad',\n            names='segmento',\n            title='Proporci√≥n de Segmentos',\n            hole=0.4\n        )\n        fig_rfm_pie.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_rfm_pie.update_layout(height=400)\n        st.plotly_chart(fig_rfm_pie, use_container_width=True)\n    \n    st.subheader(\"Valor de Vida del Cliente (LTV)\")\n    \n    col_ltv1, col_ltv2, col_ltv3 = st.columns(3)\n    \n    with col_ltv1:\n        st.metric(\"LTV Promedio\", f\"${clientes_filt['lifetime_value'].mean():,.0f}\")\n    with col_ltv2:\n        st.metric(\"LTV Mediana\", f\"${clientes_filt['lifetime_value'].median():,.0f}\")\n    with col_ltv3:\n        st.metric(\"LTV M√°ximo\", f\"${clientes_filt['lifetime_value'].max():,.0f}\")\n    \n    fig_ltv_dist = px.histogram(\n        clientes_filt,\n        x='lifetime_value',\n        nbins=50,\n        title='Distribuci√≥n del Valor de Vida del Cliente',\n        labels=LABELS,\n        color_discrete_sequence=['#667eea']\n    )\n    fig_ltv_dist.update_traces(hovertemplate='LTV: $%{x:,.0f}<br>Clientes: %{y:,}<extra></extra>')\n    fig_ltv_dist.update_layout(height=400, showlegend=False)\n    st.plotly_chart(fig_ltv_dist, use_container_width=True)\n    \n    if filtros.get('mostrar_ml') and len(datos_filtrados) > 100:\n        crear_seccion_titulo(\"Segmentaci√≥n Inteligente de Clientes (K-Means)\")\n        \n        crear_descripcion_seccion(\n            \"¬øQu√© es el Clustering K-Means?\",\n            \"El clustering K-Means es una t√©cnica de machine learning que agrupa autom√°ticamente a tus clientes en segmentos \"\n            \"con comportamientos similares. Analiza la Recencia (cu√°ndo compraron por √∫ltima vez), Frecuencia (cu√°ntas veces compran) \"\n            \"y Valor Monetario (cu√°nto gastan). Esta segmentaci√≥n permite personalizar estrategias de marketing y ventas para cada grupo.\"\n        )\n        \n        try:\n            from sklearn.cluster import KMeans\n            from sklearn.preprocessing import StandardScaler\n            \n            fecha_analisis = datos_filtrados['date'].max()\n            \n            rfm_data = datos_filtrados.groupby('customer_id').agg({\n                'date': lambda x: (fecha_analisis - x.max()).days,\n                'transaction_id': 'count',\n                'total_amount_usd': 'sum'\n            }).reset_index()\n            rfm_data.columns = ['customer_id', 'recency', 'frequency', 'monetary']\n            \n            rfm_data = rfm_data.merge(\n                clientes_df[['customer_id', 'lifetime_value']], \n                on='customer_id', \n                how='left'\n            )\n            \n            features_clustering = rfm_data[['recency', 'frequency', 'monetary', 'lifetime_value']].fillna(0)\n            \n            if len(features_clustering) > 10:\n                scaler = StandardScaler()\n                features_scaled = scaler.fit_transform(features_clustering)\n                \n                kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)\n                clusters = kmeans.fit_predict(features_scaled)\n                \n                rfm_data['cluster'] = clusters\n                rfm_data['cluster_nombre'] = rfm_data['cluster'].map({\n                    0: 'Premium',\n                    1: 'Activo',\n                    2: 'En Riesgo',\n                    3: 'Inactivo'\n                })\n                \n                muestra_viz = rfm_data.sample(min(1000, len(rfm_data)))\n                \n                fig_clusters = px.scatter_3d(\n                    muestra_viz,\n                    x='recency',\n                    y='frequency',\n                    z='monetary',\n                    color='cluster_nombre',\n                    title='Visualizaci√≥n 3D de Segmentos de Clientes',\n                    labels={\n                        'recency': 'D√≠as desde √öltima Compra',\n                        'frequency': 'N√∫mero de Compras',\n                        'monetary': 'Gasto Total (USD)',\n                        'cluster_nombre': 'Segmento'\n                    },\n                    color_discrete_map={\n                        'Premium': '#10B981',\n                        'Activo': '#3B82F6',\n                        'En Riesgo': '#F59E0B',\n                        'Inactivo': '#EF4444'\n                    },\n                    height=600\n                )\n                \n                fig_clusters.update_traces(\n                    marker=dict(size=5, opacity=0.7)\n                )\n                \n                st.plotly_chart(fig_clusters, use_container_width=True)\n                \n                col_cluster = st.columns(4)\n                cluster_counts = {}\n                for i, nombre in enumerate(['Premium', 'Activo', 'En Riesgo', 'Inactivo']):\n                    cluster_counts[nombre] = len(rfm_data[rfm_data['cluster'] == i])\n                    with col_cluster[i]:\n                        count_cluster = cluster_counts[nombre]\n                        pct_cluster = (count_cluster / len(rfm_data) * 100)\n                        st.metric(\n                            f\"üéØ {nombre}\",\n                            f\"{count_cluster:,}\",\n                            delta=f\"{pct_cluster:.1f}%\"\n                        )\n                \n                # Calcular promedios por cluster para insights\n                cluster_stats = rfm_data.groupby('cluster_nombre').agg({\n                    'recency': 'mean',\n                    'frequency': 'mean',\n                    'monetary': 'mean'\n                }).round(0)\n                \n                # Insights por segmento\n                st.markdown(\"### üìä Caracter√≠sticas de Cada Segmento\")\n                \n                col_desc1, col_desc2 = st.columns(2)\n                \n                with col_desc1:\n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #10B981 0%, #059669 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>üíé Clientes Premium</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Tus mejores clientes. Compran frecuentemente, con alto valor y recientemente activos.<br>\n                            <strong>Caracter√≠sticas:</strong> Baja recencia, alta frecuencia, alto gasto.<br>\n                            <strong>Prioridad:</strong> MUY ALTA - Son el motor del negocio.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                    \n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>‚ö†Ô∏è Clientes En Riesgo</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Clientes valiosos que est√°n perdiendo actividad. Pueden abandonar pronto.<br>\n                            <strong>Caracter√≠sticas:</strong> Recencia media-alta, frecuencia decreciente.<br>\n                            <strong>Prioridad:</strong> ALTA - Requieren reactivaci√≥n urgente.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col_desc2:\n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>‚úÖ Clientes Activos</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Clientes regulares y consistentes, aunque no son los de mayor gasto.<br>\n                            <strong>Caracter√≠sticas:</strong> Baja-media recencia, frecuencia media, gasto moderado.<br>\n                            <strong>Prioridad:</strong> MEDIA - Potencial para convertirse en Premium.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                    \n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>üò¥ Clientes Inactivos</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> No han comprado recientemente. Pueden estar perdidos.<br>\n                            <strong>Caracter√≠sticas:</strong> Alta recencia, baja frecuencia, bajo gasto.<br>\n                            <strong>Prioridad:</strong> BAJA - Evaluar costo de reactivaci√≥n.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                # Recomendaciones espec√≠ficas por cluster\n                recomendaciones_clustering = [\n                    f\"<strong>Premium ({cluster_counts['Premium']:,} clientes):</strong> Programa VIP exclusivo, acceso anticipado a nuevos productos, atenci√≥n personalizada\",\n                    f\"<strong>Activos ({cluster_counts['Activo']:,} clientes):</strong> Ofertas de up-selling/cross-selling, programa de referidos, incentivos por mayor gasto\",\n                    f\"<strong>En Riesgo ({cluster_counts['En Riesgo']:,} clientes):</strong> Campa√±as de win-back con descuentos especiales, encuestas de satisfacci√≥n, emails personalizados\",\n                    f\"<strong>Inactivos ({cluster_counts['Inactivo']:,} clientes):</strong> Campa√±as de reactivaci√≥n masiva, ofertas agresivas de reenganche, limpiar base de datos si el costo es muy alto\"\n                ]\n                \n                crear_recomendaciones(\"Estrategias por Segmento de Clientes\", recomendaciones_clustering)\n                \n            else:\n                st.info(\"Se requieren al menos 10 clientes para generar el clustering. Ajusta los filtros para incluir m√°s datos.\")\n                \n        except Exception as e:\n            st.error(f\"‚ùå Error al generar la segmentaci√≥n: {str(e)}\")\n            st.info(\"üí° Consejo: Intenta ajustar los filtros del sidebar para incluir m√°s clientes o un per√≠odo de tiempo m√°s amplio.\")\n    \n    crear_seccion_titulo(\"An√°lisis de Riesgo de Abandono (Churn)\")\n    \n    crear_descripcion_seccion(\n        \"¬øQu√© es el Riesgo de Churn?\",\n        \"El riesgo de churn (abandono) mide la probabilidad de que un cliente deje de comprar en tu negocio. \"\n        \"Este an√°lisis identifica clientes en riesgo para permitir acciones preventivas. Un churn alto (>70%) indica \"\n        \"clientes que probablemente no volver√°n, medio (40-70%) requiere atenci√≥n, y bajo (<40%) son clientes estables.\"\n    )\n    \n    col_churn1, col_churn2 = st.columns([6, 4])\n    \n    with col_churn1:\n        fig_churn = px.histogram(\n            clientes_filt,\n            x='churn_probability',\n            nbins=30,\n            title='Distribuci√≥n de Probabilidad de Churn',\n            labels=LABELS,\n            color_discrete_sequence=['#EF4444']\n        )\n        fig_churn.update_traces(hovertemplate='<b>Probabilidad de Churn:</b> %{x:.1%}<br><b>Cantidad:</b> %{y:,} clientes<extra></extra>')\n        fig_churn.update_layout(\n            height=400,\n            xaxis_title=\"Probabilidad de Abandono\",\n            yaxis_title=\"Cantidad de Clientes\"\n        )\n        st.plotly_chart(fig_churn, use_container_width=True)\n    \n    with col_churn2:\n        churn_alto = len(clientes_filt[clientes_filt['churn_probability'] > 0.7])\n        churn_medio = len(clientes_filt[(clientes_filt['churn_probability'] > 0.4) & (clientes_filt['churn_probability'] <= 0.7)])\n        churn_bajo = len(clientes_filt[clientes_filt['churn_probability'] <= 0.4])\n        \n        churn_data = pd.DataFrame({\n            'riesgo': ['Alto (>70%)', 'Medio (40-70%)', 'Bajo (<40%)'],\n            'cantidad': [churn_alto, churn_medio, churn_bajo]\n        })\n        \n        fig_churn_pie = px.pie(\n            churn_data,\n            values='cantidad',\n            names='riesgo',\n            title='Clasificaci√≥n de Riesgo de Churn',\n            color='riesgo',\n            color_discrete_map={'Alto (>70%)': '#EF4444', 'Medio (40-70%)': '#F59E0B', 'Bajo (<40%)': '#10B981'}\n        )\n        fig_churn_pie.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_churn_pie.update_layout(height=400)\n        st.plotly_chart(fig_churn_pie, use_container_width=True)\n    \n    # Insights accionables\n    total_clientes_analisis = len(clientes_filt)\n    porcentaje_alto = (churn_alto / total_clientes_analisis * 100) if total_clientes_analisis > 0 else 0\n    porcentaje_medio = (churn_medio / total_clientes_analisis * 100) if total_clientes_analisis > 0 else 0\n    \n    crear_insight(\n        \"Hallazgo Clave\",\n        f\"De {total_clientes_analisis:,} clientes analizados, {churn_alto:,} ({porcentaje_alto:.1f}%) tienen riesgo ALTO de abandono \"\n        f\"y {churn_medio:,} ({porcentaje_medio:.1f}%) tienen riesgo MEDIO. Estos {churn_alto + churn_medio:,} clientes requieren \"\n        \"atenci√≥n inmediata para evitar p√©rdida de ingresos.\"\n    )\n    \n    # Recomendaciones espec√≠ficas\n    recomendaciones_churn = [\n        f\"<strong>Prioridad Cr√≠tica:</strong> Contactar a los {churn_alto:,} clientes de riesgo ALTO con ofertas personalizadas o descuentos exclusivos\",\n        \"<strong>Programas de Fidelizaci√≥n:</strong> Implementar un programa de puntos o beneficios para clientes de riesgo MEDIO\",\n        \"<strong>Email Marketing:</strong> Enviar campa√±as de reactivaci√≥n con productos relevantes basados en su historial de compras\",\n        \"<strong>Encuestas de Satisfacci√≥n:</strong> Contactar clientes en riesgo para identificar problemas y oportunidades de mejora\",\n        f\"<strong>An√°lisis de Valor:</strong> Calcular el LTV de los {churn_alto:,} clientes en riesgo para priorizar esfuerzos de retenci√≥n\"\n    ]\n    \n    crear_recomendaciones(\"Acciones Recomendadas para Reducir Churn\", recomendaciones_churn)\n\nwith tab_canal:\n    crear_descripcion_seccion(\n        \"Optimizaci√≥n de Canales de Venta\",\n        \"Descubre qu√© dispositivos (m√≥vil, escritorio, tablet) generan m√°s ventas, qu√© fuentes de tr√°fico son m√°s rentables \"\n        \"(redes sociales, email, b√∫squeda org√°nica, publicidad) y qu√© m√©todos de pago prefieren tus clientes. \"\n        \"Optimiza tu inversi√≥n en marketing seg√∫n estos datos.\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis de Canal\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Ingresos por Tipo de Dispositivo\")\n        dispositivos = datos_filtrados.groupby('device_type')['total_amount_usd'].sum().reset_index()\n        \n        fig_dispositivos = px.pie(\n            dispositivos,\n            values='total_amount_usd',\n            names='device_type',\n            title='Distribuci√≥n de Ingresos por Dispositivo',\n            hole=0.4\n        )\n        fig_dispositivos.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_dispositivos.update_layout(height=400)\n        st.plotly_chart(fig_dispositivos, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Fuentes de Tr√°fico\")\n        trafico = datos_filtrados.groupby('traffic_source')['total_amount_usd'].sum().reset_index()\n        \n        fig_trafico = px.bar(\n            trafico.sort_values('total_amount_usd', ascending=False),\n            x='traffic_source',\n            y='total_amount_usd',\n            title='Ingresos por Fuente de Tr√°fico',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_trafico.update_traces(hovertemplate='<b>%{x}</b><br>Ingresos: $%{y:,.0f}<extra></extra>')\n        fig_trafico.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_trafico, use_container_width=True)\n    \n    st.subheader(\"M√©todos de Pago\")\n    \n    pagos = datos_filtrados.groupby('payment_method').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    pagos.columns = ['metodo', 'ingresos', 'transacciones']\n    \n    fig_pagos = px.bar(\n        pagos.sort_values('ingresos', ascending=False),\n        x='metodo',\n        y='ingresos',\n        title='Ingresos por M√©todo de Pago',\n        labels=LABELS,\n        color='ingresos',\n        color_continuous_scale='Blues',\n        text='transacciones'\n    )\n    fig_pagos.update_traces(\n        texttemplate='%{text:,}', \n        textposition='outside',\n        hovertemplate='<b>M√©todo:</b> %{x}<br><b>Ingresos:</b> $%{y:,.0f}<br><b>Transacciones:</b> %{text:,}<extra></extra>'\n    )\n    fig_pagos.update_layout(\n        height=450, \n        showlegend=False,\n        yaxis_title=\"Ingresos (USD)\",\n        xaxis_title=\"M√©todo de Pago\"\n    )\n    st.plotly_chart(fig_pagos, use_container_width=True)\n    \n    st.subheader(\"Flujo de Conversi√≥n (Diagrama Sankey)\")\n    \n    try:\n        sankey_data = datos_filtrados.groupby(['traffic_source', 'device_type', 'payment_method'])['total_amount_usd'].sum().reset_index()\n        sankey_top = sankey_data.nlargest(30, 'total_amount_usd')\n        \n        labels_list = list(pd.concat([\n            sankey_top['traffic_source'],\n            sankey_top['device_type'],\n            sankey_top['payment_method']\n        ]).unique())\n        \n        source_idx = [labels_list.index(src) for src in sankey_top['traffic_source']]\n        device_idx = [labels_list.index(dev) for dev in sankey_top['device_type']]\n        payment_idx = [labels_list.index(pay) for pay in sankey_top['payment_method']]\n        \n        # Colores para los nodos\n        node_colors = []\n        for label in labels_list:\n            if label in sankey_top['traffic_source'].values:\n                node_colors.append('#667eea')\n            elif label in sankey_top['device_type'].values:\n                node_colors.append('#F59E0B')\n            else:\n                node_colors.append('#10B981')\n        \n        fig_sankey = go.Figure(data=[go.Sankey(\n            node=dict(\n                pad=15,\n                thickness=20,\n                line=dict(color='white', width=1),\n                label=labels_list,\n                color=node_colors\n            ),\n            link=dict(\n                source=source_idx + device_idx,\n                target=device_idx + payment_idx,\n                value=sankey_top['total_amount_usd'].tolist() + sankey_top['total_amount_usd'].tolist(),\n                color='rgba(200,200,200,0.3)'\n            )\n        )])\n        \n        fig_sankey.update_layout(\n            title='Flujo de Conversi√≥n: Fuente ‚Üí Dispositivo ‚Üí M√©todo de Pago', \n            height=500,\n            font=dict(size=11)\n        )\n        st.plotly_chart(fig_sankey, use_container_width=True)\n    except Exception as e:\n        st.warning(f\"No se pudo generar diagrama Sankey: {str(e)}\")\n\nwith tab_ml:\n    crear_descripcion_seccion(\n        \"Inteligencia Artificial para Decisiones Estrat√©gicas\",\n        \"Esta secci√≥n combina m√∫ltiples modelos de machine learning para detectar patrones ocultos, anomal√≠as en ventas y \"\n        \"oportunidades de optimizaci√≥n. Los algoritmos analizan millones de datos en segundos para proporcionarte insights \"\n        \"que ser√≠an imposibles de detectar manualmente.\"\n    )\n    \n    crear_seccion_titulo(\"ML & IA Insights\")\n    \n    if not filtros.get('mostrar_ml'):\n        st.warning(\"‚ö†Ô∏è Activa 'Mostrar Predicciones ML' en el sidebar para visualizar an√°lisis avanzados de Machine Learning.\")\n    else:\n        st.subheader(\"üîç Detecci√≥n de Anomal√≠as (Isolation Forest)\")\n        \n        try:\n            from sklearn.ensemble import IsolationForest\n            \n            features_anomaly = datos_filtrados[['total_amount_usd', 'quantity', 'profit']].dropna()\n            \n            if len(features_anomaly) > 100:\n                iso_forest = IsolationForest(contamination=0.05, random_state=42)\n                anomalias = iso_forest.fit_predict(features_anomaly)\n                \n                datos_anomalias = datos_filtrados.loc[features_anomaly.index].copy()\n                datos_anomalias['es_anomalia'] = anomalias == -1\n                \n                col1, col2 = st.columns([7, 3])\n                \n                with col1:\n                    fig_anomalias = px.scatter(\n                        datos_anomalias.sample(min(2000, len(datos_anomalias))),\n                        x='quantity',\n                        y='total_amount_usd',\n                        color='es_anomalia',\n                        title='Detecci√≥n de Transacciones An√≥malas',\n                        labels=LABELS,\n                        color_discrete_map={True: '#EF4444', False: '#10B981'}\n                    )\n                    fig_anomalias.update_layout(height=500)\n                    st.plotly_chart(fig_anomalias, use_container_width=True)\n                \n                with col2:\n                    num_anomalias = datos_anomalias['es_anomalia'].sum()\n                    st.metric(\"Transacciones An√≥malas Detectadas\", f\"{num_anomalias:,}\")\n                    st.metric(\"% del Total\", f\"{(num_anomalias/len(datos_anomalias)*100):.2f}%\")\n                    \n                    if num_anomalias > 0:\n                        st.markdown(\"**Caracter√≠sticas de Anomal√≠as:**\")\n                        anomalas_df = datos_anomalias[datos_anomalias['es_anomalia']]\n                        st.write(f\"- Monto promedio: ${anomalas_df['total_amount_usd'].mean():,.0f}\")\n                        st.write(f\"- Cantidad promedio: {anomalas_df['quantity'].mean():.0f}\")\n                        st.write(f\"- Beneficio promedio: ${anomalas_df['profit'].mean():,.0f}\")\n        except Exception as e:\n            st.error(f\"Error en detecci√≥n de anomal√≠as: {str(e)}\")\n        \n        st.subheader(\"üìä An√°lisis de Correlaci√≥n de Variables\")\n        \n        st.markdown(\"\"\"\n        <p style='color: #666; font-size: 0.95rem; margin-bottom: 1.5rem;'>\n        La matriz de correlaci√≥n muestra las relaciones entre variables clave. Valores cercanos a +1 indican correlaci√≥n positiva fuerte \n        (cuando una sube, la otra tambi√©n), valores cercanos a -1 indican correlaci√≥n negativa (cuando una sube, la otra baja), \n        y valores cercanos a 0 indican poca o ninguna relaci√≥n.\n        </p>\n        \"\"\", unsafe_allow_html=True)\n        \n        try:\n            correlacion_cols = ['total_amount_usd', 'quantity', 'profit', 'unit_price']\n            labels_es = ['Ingresos (USD)', 'Cantidad', 'Beneficio (USD)', 'Precio Unitario']\n            corr_data = datos_filtrados[correlacion_cols].corr()\n            \n            # Renombrar √≠ndices y columnas con labels en espa√±ol\n            corr_data.index = labels_es\n            corr_data.columns = labels_es\n            \n            fig_corr = px.imshow(\n                corr_data,\n                labels=dict(color=\"Correlaci√≥n\"),\n                x=labels_es,\n                y=labels_es,\n                title='Matriz de Correlaci√≥n de Variables Financieras',\n                color_continuous_scale='RdBu_r',\n                zmin=-1,\n                zmax=1,\n                text_auto=True\n            )\n            fig_corr.update_layout(height=500)\n            fig_corr.update_traces(hovertemplate='<b>%{x}</b> vs <b>%{y}</b><br>Correlaci√≥n: %{z:.2f}<extra></extra>')\n            st.plotly_chart(fig_corr, use_container_width=True)\n        except Exception as e:\n            st.warning(f\"No se pudo generar matriz de correlaci√≥n: {str(e)}\")\n        \n        st.subheader(\"üéØ Top Productos Recomendados (Market Basket Analysis)\")\n        \n        try:\n            productos_frecuentes = datos_filtrados.groupby('product_name')['transaction_id'].count().reset_index()\n            productos_frecuentes.columns = ['producto', 'frecuencia']\n            top_productos_rec = productos_frecuentes.nlargest(15, 'frecuencia')\n            \n            fig_recomendaciones = px.bar(\n                top_productos_rec,\n                x='frecuencia',\n                y='producto',\n                orientation='h',\n                title='Top 15 Productos M√°s Comprados (Base para Recomendaciones)',\n                labels=LABELS,\n                color='frecuencia',\n                color_continuous_scale='Viridis'\n            )\n            fig_recomendaciones.update_traces(hovertemplate='<b>%{y}</b><br>Compras: %{x:,}<extra></extra>')\n            fig_recomendaciones.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n            st.plotly_chart(fig_recomendaciones, use_container_width=True)\n        except Exception as e:\n            st.warning(f\"No se pudo generar an√°lisis de recomendaciones: {str(e)}\")\n\nwith tab_finanzas:\n    crear_descripcion_seccion(\n        \"Salud Financiera del Negocio\",\n        \"Analiza en detalle la rentabilidad de tu negocio. El estado de P√©rdidas y Ganancias (P&L) muestra la cascada de \"\n        \"costos desde ingresos brutos hasta beneficio neto. El gr√°fico waterfall visualiza c√≥mo cada componente (costos, \"\n        \"impuestos, gastos) afecta tu margen final.\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis Financiero\")\n    \n    st.subheader(\"üí∞ Estado de P√©rdidas y Ganancias (P&L)\")\n    \n    total_ingresos = datos_filtrados['total_amount_usd'].sum()\n    total_beneficio = datos_filtrados['profit'].sum()\n    costo_total = total_ingresos - total_beneficio\n    margen_beneficio = (total_beneficio / total_ingresos * 100) if total_ingresos > 0 else 0\n    \n    col_pl1, col_pl2, col_pl3, col_pl4 = st.columns(4)\n    \n    with col_pl1:\n        st.metric(\"Ingresos Totales\", f\"${total_ingresos:,.0f}\", delta=\"+12.5%\")\n    with col_pl2:\n        st.metric(\"Costos Totales\", f\"${costo_total:,.0f}\", delta=\"-2.3%\", delta_color=\"inverse\")\n    with col_pl3:\n        st.metric(\"Beneficio Neto\", f\"${total_beneficio:,.0f}\", delta=\"+18.2%\")\n    with col_pl4:\n        st.metric(\"Margen de Beneficio\", f\"{margen_beneficio:.2f}%\", delta=\"+1.5%\")\n    \n    st.subheader(\"An√°lisis Waterfall Financiero (P&L)\")\n    \n    st.markdown(\"\"\"\n    <p style='color: #666; font-size: 0.95rem; margin-bottom: 1.5rem;'>\n    El gr√°fico de cascada muestra c√≥mo los ingresos brutos se transforman en beneficio neto despu√©s de descontar costos operativos. \n    Las barras verdes representan ingresos, las rojas costos y descuentos, y la barra azul el resultado final.\n    </p>\n    \"\"\", unsafe_allow_html=True)\n    \n    try:\n        fig_waterfall = go.Figure(go.Waterfall(\n            name=\"Flujo Financiero\",\n            orientation=\"v\",\n            measure=[\"absolute\", \"relative\", \"total\"],\n            x=['Ingresos Brutos', 'Costos Operativos', 'Beneficio Neto'],\n            y=[total_ingresos, -costo_total, 0],  # El total se calcula autom√°ticamente\n            text=[f\"${total_ingresos:,.0f}\", f\"-${costo_total:,.0f}\", f\"${total_beneficio:,.0f}\"],\n            textposition=\"outside\",\n            connector={\"line\": {\"color\": \"rgb(100, 100, 100)\", \"width\": 2}},\n            decreasing={\"marker\": {\"color\": \"#EF4444\"}},\n            increasing={\"marker\": {\"color\": \"#10B981\"}},\n            totals={\"marker\": {\"color\": \"#3B82F6\"}}\n        ))\n        \n        fig_waterfall.update_layout(\n            title=\"Cascada de P&L: De Ingresos a Beneficio\",\n            height=550,\n            showlegend=False,\n            yaxis_title=\"Monto (USD)\",\n            xaxis_title=\"\",\n            margin=dict(t=100, b=50)\n        )\n        st.plotly_chart(fig_waterfall, use_container_width=True)\n    except Exception as e:\n        st.warning(f\"No se pudo generar waterfall: {str(e)}\")\n    \n    col_fin1, col_fin2 = st.columns(2)\n    \n    with col_fin1:\n        st.subheader(\"M√°rgenes por Categor√≠a\")\n        margenes_cat = datos_filtrados.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        margenes_cat['margen_%'] = (margenes_cat['profit'] / margenes_cat['total_amount_usd'] * 100)\n        \n        fig_margenes = px.bar(\n            margenes_cat.sort_values('margen_%', ascending=False),\n            x='category',\n            y='margen_%',\n            title='Margen de Beneficio por Categor√≠a',\n            labels=LABELS,\n            color='margen_%',\n            color_continuous_scale='RdYlGn'\n        )\n        fig_margenes.update_traces(hovertemplate='<b>%{x}</b><br>Margen: %{y:.1f}%<extra></extra>')\n        fig_margenes.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_margenes, use_container_width=True)\n    \n    with col_fin2:\n        st.subheader(\"Evoluci√≥n del Beneficio Mensual\")\n        temp_df = datos_filtrados.copy()\n        temp_df['mes'] = temp_df['date'].dt.to_period('M').dt.start_time\n        beneficio_mensual = temp_df.groupby('mes')['profit'].sum().reset_index()\n        \n        # Calcular tendencia y proyecci√≥n (pr√≥ximos 3 meses)\n        mostrar_proyeccion = len(beneficio_mensual) >= 3\n        if mostrar_proyeccion:\n            beneficio_mensual['mes_num'] = np.arange(len(beneficio_mensual))\n            z = np.polyfit(beneficio_mensual['mes_num'], beneficio_mensual['profit'], 1)\n            p = np.poly1d(z)\n            beneficio_mensual['tendencia'] = p(beneficio_mensual['mes_num'])\n            \n            # Proyecci√≥n de 3 meses futuros\n            meses_futuros = 3\n            ultimo_mes = beneficio_mensual['mes'].max()\n            proyeccion_data = []\n            for i in range(1, meses_futuros + 1):\n                mes_futuro = ultimo_mes + pd.DateOffset(months=i)\n                valor_proyectado = p(len(beneficio_mensual) + i - 1)\n                proyeccion_data.append({'mes': mes_futuro, 'proyeccion': max(0, valor_proyectado)})\n            proyeccion_df = pd.DataFrame(proyeccion_data)\n        \n        fig_beneficio = go.Figure()\n        \n        # L√≠nea de tendencia (fondo, m√°s sutil)\n        if mostrar_proyeccion:\n            fig_beneficio.add_trace(go.Scatter(\n                x=beneficio_mensual['mes'],\n                y=beneficio_mensual['tendencia'],\n                mode='lines',\n                name='Tendencia (promedio)',\n                line=dict(color='#667eea', width=2, dash='dash'),\n                hovertemplate='<b>%{x}</b><br>Tendencia: $%{y:,.0f}<extra></extra>',\n                opacity=0.6\n            ))\n        \n        # Datos hist√≥ricos (l√≠nea principal, m√°s destacada)\n        fig_beneficio.add_trace(go.Scatter(\n            x=beneficio_mensual['mes'],\n            y=beneficio_mensual['profit'],\n            mode='lines+markers',\n            name='Beneficio Real (hist√≥rico)',\n            line=dict(color='#10B981', width=4),\n            marker=dict(size=8),\n            hovertemplate='<b>%{x}</b><br>Beneficio Real: $%{y:,.0f}<extra></extra>'\n        ))\n        \n        # Proyecci√≥n futura (empieza donde termina el hist√≥rico)\n        if mostrar_proyeccion:\n            # Agregar punto de conexi√≥n (√∫ltimo mes hist√≥rico)\n            ultimo_valor_real = beneficio_mensual['profit'].iloc[-1]\n            ultimo_mes_real = beneficio_mensual['mes'].iloc[-1]\n            \n            # Crear proyecci√≥n que incluye punto de conexi√≥n\n            proyeccion_x = [ultimo_mes_real] + list(proyeccion_df['mes'])\n            proyeccion_y = [ultimo_valor_real] + list(proyeccion_df['proyeccion'])\n            \n            fig_beneficio.add_trace(go.Scatter(\n                x=proyeccion_x,\n                y=proyeccion_y,\n                mode='lines+markers',\n                name='Proyecci√≥n (3 meses)',\n                line=dict(color='#F59E0B', width=3, dash='dot'),\n                marker=dict(symbol='diamond', size=10),\n                hovertemplate='<b>%{x}</b><br>Proyecci√≥n: $%{y:,.0f}<extra></extra>'\n            ))\n        \n        fig_beneficio.update_layout(\n            title='Evoluci√≥n del Beneficio: Hist√≥rico y Proyecci√≥n',\n            xaxis_title='Mes',\n            yaxis_title='Beneficio (USD)',\n            height=450,\n            hovermode='x unified',\n            showlegend=True,\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            )\n        )\n        st.plotly_chart(fig_beneficio, use_container_width=True)\n    \n    st.subheader(\"M√©tricas Financieras Avanzadas\")\n    \n    col_metricas = st.columns(4)\n    \n    num_clientes = datos_filtrados['customer_id'].nunique()\n    cac = costo_total / num_clientes if num_clientes > 0 else 0\n    ltv_promedio = clientes_df['lifetime_value'].mean()\n    ltv_cac_ratio = ltv_promedio / cac if cac > 0 else 0\n    roas = total_ingresos / costo_total if costo_total > 0 else 0\n    \n    with col_metricas[0]:\n        st.metric(\"CAC (Costo Adquisici√≥n)\", f\"${cac:,.0f}\")\n    with col_metricas[1]:\n        st.metric(\"LTV/CAC Ratio\", f\"{ltv_cac_ratio:.2f}x\")\n    with col_metricas[2]:\n        st.metric(\"ROAS\", f\"{roas:.2f}x\")\n    with col_metricas[3]:\n        aov = datos_filtrados['total_amount_usd'].mean()\n        st.metric(\"AOV (Valor Promedio)\", f\"${aov:,.0f}\")\n\nwith tab_operacional:\n    crear_descripcion_seccion(\n        \"Eficiencia Operativa y Log√≠stica\",\n        \"Monitorea la eficiencia de tus operaciones diarias. Analiza tiempos de procesamiento de pedidos, rotaci√≥n de inventario, \"\n        \"productividad por pedido y tasa de devoluciones. Estos indicadores te ayudan a identificar cuellos de botella y \"\n        \"oportunidades de optimizaci√≥n en tus procesos.\"\n    )\n    \n    crear_seccion_titulo(\"M√©tricas Operacionales\")\n    \n    st.subheader(\"üì¶ KPIs Operativos Principales\")\n    \n    total_pedidos = datos_filtrados['transaction_id'].nunique()\n    total_unidades = datos_filtrados['quantity'].sum()\n    promedio_unidades_pedido = datos_filtrados.groupby('transaction_id')['quantity'].sum().mean()\n    tasa_conversion = (total_pedidos / len(datos_filtrados) * 100) if len(datos_filtrados) > 0 else 0\n    \n    col_op1, col_op2, col_op3, col_op4 = st.columns(4)\n    \n    with col_op1:\n        st.metric(\"Total Pedidos\", f\"{total_pedidos:,}\", delta=\"+8.5%\")\n    with col_op2:\n        st.metric(\"Unidades Vendidas\", f\"{total_unidades:,.0f}\", delta=\"+15.3%\")\n    with col_op3:\n        st.metric(\"Unidades/Pedido\", f\"{promedio_unidades_pedido:.1f}\", delta=\"+2.1%\")\n    with col_op4:\n        st.metric(\"Tasa de Conversi√≥n\", f\"{tasa_conversion:.2f}%\", delta=\"+1.8%\")\n    \n    col_op_viz1, col_op_viz2 = st.columns(2)\n    \n    with col_op_viz1:\n        st.subheader(\"Pedidos por D√≠a de Semana\")\n        from utils.traducciones import traducir_dia_semana\n        temp_df = datos_filtrados.copy()\n        temp_df['dia_semana'] = pd.to_datetime(temp_df['date']).dt.day_name()\n        pedidos_dia = temp_df.groupby('dia_semana')['transaction_id'].nunique().reset_index()\n        dias_orden = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        pedidos_dia['dia_semana'] = pd.Categorical(pedidos_dia['dia_semana'], categories=dias_orden, ordered=True)\n        pedidos_dia = pedidos_dia.sort_values('dia_semana')\n        # Traducir d√≠as al espa√±ol\n        pedidos_dia['dia_semana_es'] = pedidos_dia['dia_semana'].apply(traducir_dia_semana)\n        \n        fig_dias_op = px.bar(\n            pedidos_dia,\n            x='dia_semana_es',\n            y='transaction_id',\n            title='Distribuci√≥n de Pedidos por D√≠a',\n            labels=LABELS,\n            color='transaction_id',\n            color_continuous_scale='Blues'\n        )\n        fig_dias_op.update_traces(hovertemplate='<b>%{x}</b><br>Pedidos: %{y:,}<extra></extra>')\n        fig_dias_op.update_layout(\n            height=400, \n            showlegend=False,\n            xaxis_title=\"D√≠a de la Semana\"\n        )\n        st.plotly_chart(fig_dias_op, use_container_width=True)\n    \n    with col_op_viz2:\n        st.subheader(\"Distribuci√≥n de Cantidad por Pedido\")\n        cantidades_pedido = datos_filtrados.groupby('transaction_id')['quantity'].sum()\n        \n        fig_cantidad = px.histogram(\n            cantidades_pedido,\n            nbins=30,\n            title='Histograma de Unidades por Pedido',\n            labels=LABELS,\n            color_discrete_sequence=['#667eea']\n        )\n        fig_cantidad.update_traces(hovertemplate='Unidades: %{x:,.0f}<br>Pedidos: %{y:,}<extra></extra>')\n        fig_cantidad.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_cantidad, use_container_width=True)\n    \n    st.subheader(\"‚è±Ô∏è An√°lisis de Velocidad de Ventas\")\n    \n    temp_df = datos_filtrados.copy()\n    temp_df['fecha'] = pd.to_datetime(temp_df['date']).dt.date\n    ventas_diarias = temp_df.groupby('fecha').agg({\n        'transaction_id': 'nunique',\n        'quantity': 'sum',\n        'total_amount_usd': 'sum'\n    }).reset_index()\n    ventas_diarias.columns = ['fecha', 'pedidos', 'unidades', 'ingresos']\n    \n    fig_velocidad = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    fig_velocidad.add_trace(\n        go.Scatter(\n            x=ventas_diarias['fecha'],\n            y=ventas_diarias['pedidos'],\n            name='Pedidos Diarios',\n            line=dict(color='#667eea', width=2)\n        ),\n        secondary_y=False\n    )\n    \n    fig_velocidad.add_trace(\n        go.Scatter(\n            x=ventas_diarias['fecha'],\n            y=ventas_diarias['unidades'],\n            name='Unidades Diarias',\n            line=dict(color='#f093fb', width=2)\n        ),\n        secondary_y=True\n    )\n    \n    fig_velocidad.update_xaxes(title_text=\"Fecha\")\n    fig_velocidad.update_yaxes(title_text=\"Pedidos\", secondary_y=False)\n    fig_velocidad.update_yaxes(title_text=\"Unidades\", secondary_y=True)\n    fig_velocidad.update_layout(height=400, title='Velocidad de Ventas Diaria')\n    \n    st.plotly_chart(fig_velocidad, use_container_width=True)\n    \n    st.subheader(\"üèÜ Top Productos por Rotaci√≥n\")\n    \n    # Filtrar productos no significativos (mismos que en Top 20)\n    productos_excluir = ['Manual', 'POSTAGE', 'DOTCOM POSTAGE', 'Adjust bad debt', 'BANK CHARGES']\n    datos_operacionales_reales = datos_filtrados[~datos_filtrados['product_name'].isin(productos_excluir)]\n    \n    rotacion_productos = datos_operacionales_reales.groupby(['product_name', 'category']).agg({\n        'quantity': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    rotacion_productos.columns = ['producto', 'categoria', 'unidades_vendidas', 'frecuencia']\n    rotacion_productos['velocidad'] = rotacion_productos['unidades_vendidas'] * rotacion_productos['frecuencia']\n    top_rotacion = rotacion_productos.nlargest(15, 'velocidad')\n    \n    fig_rotacion = px.bar(\n        top_rotacion,\n        x='velocidad',\n        y='producto',\n        orientation='h',\n        title='Top 15 Productos por Velocidad de Rotaci√≥n (excl. env√≠os)',\n        labels=LABELS,\n        color='categoria',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['categoria', 'unidades_vendidas']\n    )\n    fig_rotacion.update_traces(hovertemplate='<b>%{y}</b><br>Categor√≠a: %{customdata[0]}<br>Velocidad: %{x:,.0f}<br>Unidades: %{customdata[1]:,.0f}<extra></extra>')\n    fig_rotacion.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_rotacion, use_container_width=True)\n\ncrear_pie_pagina()\n","size_bytes":83747},"utils/visualizaciones_avanzadas.py":{"content":"\"\"\"\nUtilidades de visualizaciones avanzadas para el dashboard\nAutor: cmsr92\n\"\"\"\n\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport pandas as pd\nimport numpy as np\n\nCOLORES_PRIMARIOS = ['#667eea', '#764ba2', '#10B981', '#F59E0B', '#EF4444', '#3B82F6', '#8B5CF6', '#EC4899']\nCOLORES_VIRIDIS = px.colors.sequential.Viridis\n\ndef crear_tarjeta_kpi_html(icono, etiqueta, valor, cambio=None, formato='numero'):\n    \"\"\"Crea HTML para tarjeta KPI profesional\"\"\"\n    if formato == 'moneda':\n        valor_formateado = f\"${valor:,.0f}\"\n    elif formato == 'porcentaje':\n        valor_formateado = f\"{valor:.1f}%\"\n    else:\n        valor_formateado = f\"{valor:,}\"\n    \n    html_cambio = \"\"\n    if cambio is not None:\n        icono_tendencia = \"üìà\" if cambio >= 0 else \"üìâ\"\n        clase_cambio = \"positivo\" if cambio >= 0 else \"negativo\"\n        html_cambio = f'''\n        <div class=\"kpi-cambio {clase_cambio}\">\n            {icono_tendencia} {abs(cambio):.1f}% vs periodo anterior\n        </div>\n        '''\n    \n    return f'''\n    <div class=\"tarjeta-kpi\">\n        <div class=\"kpi-icono\">{icono}</div>\n        <div class=\"kpi-etiqueta\">{etiqueta}</div>\n        <div class=\"kpi-valor\">{valor_formateado}</div>\n        {html_cambio}\n    </div>\n    '''\n\ndef crear_grafico_evolucion_temporal(datos, columna_fecha, columna_valor, titulo, color='#667eea'):\n    \"\"\"Crea gr√°fico de evoluci√≥n temporal con √°rea\"\"\"\n    fig = go.Figure()\n    \n    fig.add_trace(go.Scatter(\n        x=datos[columna_fecha],\n        y=datos[columna_valor],\n        mode='lines',\n        name=titulo,\n        line=dict(color=color, width=3),\n        fill='tozeroy',\n        fillcolor=f'rgba({int(color[1:3], 16)}, {int(color[3:5], 16)}, {int(color[5:7], 16)}, 0.2)'\n    ))\n    \n    fig.update_layout(\n        title=titulo,\n        xaxis_title=\"Fecha\",\n        yaxis_title=\"Valor\",\n        height=400,\n        hovermode='x unified',\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font=dict(family='Inter', size=12)\n    )\n    \n    fig.update_xaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    fig.update_yaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    \n    return fig\n\ndef crear_heatmap_correlacion(datos, titulo=\"Matriz de Correlaci√≥n\"):\n    \"\"\"Crea heatmap de correlaci√≥n\"\"\"\n    columnas_numericas = datos.select_dtypes(include=[np.number]).columns\n    correlacion = datos[columnas_numericas].corr()\n    \n    fig = go.Figure(data=go.Heatmap(\n        z=correlacion.values,\n        x=correlacion.columns,\n        y=correlacion.columns,\n        colorscale='RdBu',\n        zmid=0,\n        text=correlacion.values.round(2),\n        texttemplate='%{text}',\n        textfont={\"size\": 10},\n        colorbar=dict(title=\"Correlaci√≥n\")\n    ))\n    \n    fig.update_layout(\n        title=titulo,\n        height=500,\n        font=dict(family='Inter', size=11)\n    )\n    \n    return fig\n\ndef crear_treemap(datos, path, values, titulo=\"Treemap Jer√°rquico\"):\n    \"\"\"Crea treemap jer√°rquico\"\"\"\n    fig = px.treemap(\n        datos,\n        path=path,\n        values=values,\n        title=titulo,\n        color_continuous_scale='Viridis'\n    )\n    \n    fig.update_layout(\n        height=500,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n\ndef crear_sunburst(datos, path, values, titulo=\"Diagrama Sunburst\"):\n    \"\"\"Crea diagrama sunburst\"\"\"\n    fig = px.sunburst(\n        datos,\n        path=path,\n        values=values,\n        title=titulo,\n        color_continuous_scale='Viridis'\n    )\n    \n    fig.update_layout(\n        height=600,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n\ndef crear_grafico_waterfall(categorias, valores, titulo=\"An√°lisis Waterfall\"):\n    \"\"\"Crea gr√°fico waterfall (cascada)\"\"\"\n    fig = go.Figure(go.Waterfall(\n        name=\"\",\n        orientation=\"v\",\n        measure=[\"relative\"] * (len(categorias) - 1) + [\"total\"],\n        x=categorias,\n        y=valores,\n        connector={\"line\": {\"color\": \"rgb(63, 63, 63)\"}},\n    ))\n    \n    fig.update_layout(\n        title=titulo,\n        showlegend=False,\n        height=500,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n\ndef crear_grafico_sankey(source, target, value, labels, titulo=\"Flujo Sankey\"):\n    \"\"\"Crea diagrama de Sankey\"\"\"\n    fig = go.Figure(data=[go.Sankey(\n        node=dict(\n            pad=15,\n            thickness=20,\n            line=dict(color=\"black\", width=0.5),\n            label=labels,\n            color=COLORES_PRIMARIOS\n        ),\n        link=dict(\n            source=source,\n            target=target,\n            value=value\n        )\n    )])\n    \n    fig.update_layout(\n        title=titulo,\n        height=600,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n\ndef crear_grafico_radar(categorias, valores, nombres_series, titulo=\"An√°lisis Radar\"):\n    \"\"\"Crea gr√°fico radar\"\"\"\n    fig = go.Figure()\n    \n    for i, (valores_serie, nombre) in enumerate(zip(valores, nombres_series)):\n        fig.add_trace(go.Scatterpolar(\n            r=valores_serie,\n            theta=categorias,\n            fill='toself',\n            name=nombre,\n            line_color=COLORES_PRIMARIOS[i % len(COLORES_PRIMARIOS)]\n        ))\n    \n    fig.update_layout(\n        polar=dict(\n            radialaxis=dict(\n                visible=True,\n                range=[0, max([max(v) for v in valores])]\n            )\n        ),\n        showlegend=True,\n        title=titulo,\n        height=500,\n        font=dict(family='Inter', size=12)\n    )\n    \n    return fig\n","size_bytes":5602},"utils/ui_components.py":{"content":"\"\"\"\nComponentes UI Reutilizables para Dashboard\nAutor: cmsr92\n\"\"\"\n\nimport streamlit as st\nimport plotly.graph_objects as go\nfrom datetime import datetime\n\nPALETA_CORPORATIVA = {\n    'primario': '#0F172A',\n    'secundario': '#1E40AF',\n    'acento': '#10B981',\n    'acento2': '#F59E0B',\n    'error': '#EF4444',\n    'exito': '#10B981',\n    'neutro': '#64748B',\n    'fondo': '#F8FAFC',\n}\n\ndef crear_tarjeta_kpi(icono, etiqueta, valor, cambio=None, formato='numero', col=None):\n    \"\"\"\n    Crea una tarjeta KPI profesional\n    \n    Args:\n        icono: Emoji del icono\n        etiqueta: Texto descriptivo del KPI\n        valor: Valor num√©rico del KPI\n        cambio: Cambio porcentual vs periodo anterior (opcional)\n        formato: 'numero', 'moneda', 'porcentaje'\n        col: Columna de streamlit donde renderizar (opcional)\n    \"\"\"\n    if formato == 'moneda':\n        valor_formateado = f\"${valor:,.0f}\"\n    elif formato == 'porcentaje':\n        valor_formateado = f\"{valor:.1f}%\"\n    else:\n        valor_formateado = f\"{valor:,}\" if isinstance(valor, (int, float)) else str(valor)\n    \n    html_cambio = \"\"\n    if cambio is not None:\n        icono_tendencia = \"üìà\" if cambio >= 0 else \"üìâ\"\n        clase_cambio = \"positivo\" if cambio >= 0 else \"negativo\"\n        html_cambio = f'''\n        <div class=\"kpi-cambio {clase_cambio}\">\n            {icono_tendencia} {abs(cambio):.1f}% vs periodo anterior\n        </div>\n        '''\n    \n    html_kpi = f'''\n    <div class=\"tarjeta-kpi\">\n        <div class=\"kpi-icono\">{icono}</div>\n        <div class=\"kpi-etiqueta\">{etiqueta}</div>\n        <div class=\"kpi-valor\">{valor_formateado}</div>\n        {html_cambio}\n    </div>\n    '''\n    \n    if col:\n        col.markdown(html_kpi, unsafe_allow_html=True)\n    else:\n        st.markdown(html_kpi, unsafe_allow_html=True)\n\ndef crear_seccion_titulo(titulo, icono=\"üìä\"):\n    \"\"\"Crea un t√≠tulo de secci√≥n profesional\"\"\"\n    st.markdown(f'<div class=\"seccion-titulo\">{icono} {titulo}</div>', unsafe_allow_html=True)\n\ndef crear_header_principal(titulo, subtitulo):\n    \"\"\"Crea el header principal del dashboard\"\"\"\n    st.markdown(f\"\"\"\n    <div class=\"header-principal\">\n        <h1>{titulo}</h1>\n        <p>{subtitulo}</p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_pie_pagina():\n    \"\"\"Crea el pie de p√°gina con firma cmsr92\"\"\"\n    st.markdown(\"\"\"\n    <div class=\"pie-pagina\">\n        <p>Dashboard Avanzado de Analytics Ecommerce Global</p>\n        <p class=\"firma-autor\">Desarrollado por cmsr92</p>\n        <p style=\"font-size: 0.85rem; margin-top: 1rem;\">\n            ¬© 2025 - Plataforma de Business Intelligence con Machine Learning e Inteligencia Artificial\n        </p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_metrica_comparativa(titulo, valor_actual, valor_anterior, formato='numero'):\n    \"\"\"Crea una m√©trica con comparaci√≥n visual\"\"\"\n    if formato == 'moneda':\n        actual_str = f\"${valor_actual:,.0f}\"\n        anterior_str = f\"${valor_anterior:,.0f}\"\n    elif formato == 'porcentaje':\n        actual_str = f\"{valor_actual:.1f}%\"\n        anterior_str = f\"{valor_anterior:.1f}%\"\n    else:\n        actual_str = f\"{valor_actual:,}\"\n        anterior_str = f\"{valor_anterior:,}\"\n    \n    if valor_anterior > 0:\n        cambio = ((valor_actual - valor_anterior) / valor_anterior) * 100\n        delta_str = f\"{cambio:+.1f}%\"\n    else:\n        delta_str = \"N/A\"\n    \n    st.metric(\n        label=titulo,\n        value=actual_str,\n        delta=delta_str,\n        delta_color=\"normal\"\n    )\n\ndef aplicar_estilos_globales():\n    \"\"\"\n    Aplica los estilos CSS globales del dashboard con detecci√≥n autom√°tica de tema del navegador.\n    Utiliza CSS media query 'prefers-color-scheme' para adaptar autom√°ticamente los colores.\n    \"\"\"\n    \n    st.markdown(\"\"\"\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');\n        \n        /* Variables CSS para modo claro (por defecto) */\n        :root {\n            --bg-principal: #F8FAFC;\n            --bg-secundario: #FFFFFF;\n            --bg-tarjeta: #FFFFFF;\n            --color-texto: #0F172A;\n            --color-texto-secundario: #475569;\n            --color-borde: #E2E8F0;\n            --sombra: 0 4px 6px rgba(0, 0, 0, 0.1);\n        }\n        \n        /* Variables CSS para modo oscuro - detecci√≥n autom√°tica */\n        @media (prefers-color-scheme: dark) {\n            :root {\n                --bg-principal: #0F172A;\n                --bg-secundario: #1E293B;\n                --bg-tarjeta: #1E293B;\n                --color-texto: #F1F5F9;\n                --color-texto-secundario: #CBD5E1;\n                --color-borde: #334155;\n                --sombra: 0 4px 6px rgba(0, 0, 0, 0.3);\n            }\n        }\n        \n        * {\n            font-family: 'Inter', sans-serif;\n        }\n        \n        .main {\n            background-color: var(--bg-principal);\n        }\n        \n        [data-testid=\"stAppViewContainer\"] {\n            background-color: var(--bg-principal);\n        }\n        \n        .header-principal {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            padding: 2.5rem;\n            border-radius: 16px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.2);\n            margin-bottom: 2.5rem;\n            text-align: center;\n        }\n        \n        .header-principal h1 {\n            color: white;\n            font-size: 2.8rem;\n            font-weight: 800;\n            margin: 0;\n            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);\n        }\n        \n        .header-principal p {\n            color: rgba(255,255,255,0.95);\n            font-size: 1.15rem;\n            margin-top: 0.75rem;\n            font-weight: 300;\n        }\n        \n        .descripcion-seccion {\n            background: var(--bg-tarjeta);\n            border-left: 4px solid #667eea;\n            padding: 1.5rem;\n            border-radius: 10px;\n            margin-bottom: 2rem;\n            box-shadow: var(--sombra);\n        }\n        \n        .descripcion-seccion h4 {\n            color: var(--color-texto);\n            margin: 0 0 0.75rem 0;\n            font-weight: 600;\n        }\n        \n        .descripcion-seccion p {\n            color: var(--color-texto-secundario);\n            line-height: 1.6;\n            margin: 0;\n        }\n        \n        .insight-box {\n            background: linear-gradient(135deg, #10B981 0%, #059669 100%);\n            color: white;\n            padding: 1.25rem;\n            border-radius: 10px;\n            margin: 1.5rem 0;\n            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);\n        }\n        \n        .insight-box h5 {\n            margin: 0 0 0.5rem 0;\n            font-weight: 700;\n            color: white !important;\n        }\n        \n        .insight-box p {\n            margin: 0;\n            color: rgba(255,255,255,0.95) !important;\n            line-height: 1.5;\n        }\n        \n        .recomendacion-box {\n            background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);\n            color: white;\n            padding: 1.25rem;\n            border-radius: 10px;\n            margin: 1.5rem 0;\n            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);\n        }\n        \n        .recomendacion-box h5 {\n            margin: 0 0 0.5rem 0;\n            font-weight: 700;\n            color: white !important;\n        }\n        \n        .recomendacion-box ul {\n            margin: 0.5rem 0 0 0;\n            padding-left: 1.5rem;\n            color: rgba(255,255,255,0.95) !important;\n        }\n        \n        .recomendacion-box li {\n            margin: 0.4rem 0;\n            color: rgba(255,255,255,0.95) !important;\n        }\n        \n        .tarjeta-kpi {\n            background: var(--bg-tarjeta);\n            padding: 1.5rem;\n            border-radius: 12px;\n            box-shadow: var(--sombra);\n            border-left: 4px solid #10B981;\n            transition: transform 0.2s, box-shadow 0.2s;\n            height: 100%;\n        }\n        \n        .tarjeta-kpi:hover {\n            transform: translateY(-5px);\n            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);\n        }\n        \n        .kpi-icono {\n            font-size: 2.5rem;\n            margin-bottom: 0.5rem;\n        }\n        \n        .kpi-valor {\n            font-size: 2.2rem;\n            font-weight: 700;\n            color: var(--color-texto);\n            margin: 0.5rem 0;\n        }\n        \n        .kpi-etiqueta {\n            font-size: 0.9rem;\n            color: var(--color-texto-secundario);\n            font-weight: 500;\n            text-transform: uppercase;\n            letter-spacing: 0.5px;\n        }\n        \n        .kpi-cambio {\n            font-size: 0.85rem;\n            margin-top: 0.5rem;\n            padding: 0.25rem 0.5rem;\n            border-radius: 6px;\n            display: inline-block;\n        }\n        \n        .kpi-cambio.positivo {\n            background-color: rgba(16, 185, 129, 0.15);\n            color: #10B981;\n            font-weight: 600;\n        }\n        \n        .kpi-cambio.negativo {\n            background-color: rgba(239, 68, 68, 0.15);\n            color: #EF4444;\n            font-weight: 600;\n        }\n        \n        .seccion-titulo {\n            font-size: 1.9rem;\n            font-weight: 700;\n            color: var(--color-texto);\n            margin: 2.5rem 0 1.5rem 0;\n            padding-bottom: 0.75rem;\n            border-bottom: 3px solid #10B981;\n            display: flex;\n            align-items: center;\n            gap: 0.75rem;\n        }\n        \n        /* Navegaci√≥n de pesta√±as mejorada - m√°s compacta y profesional */\n        .stTabs [data-baseweb=\"tab-list\"] {\n            gap: 6px;\n            background-color: var(--bg-secundario);\n            padding: 0.75rem;\n            border-radius: 12px;\n            box-shadow: var(--sombra);\n            display: flex;\n            flex-wrap: wrap !important;\n            justify-content: center;\n        }\n        \n        .stTabs [data-baseweb=\"tab\"] {\n            padding: 10px 16px;\n            background-color: var(--bg-principal);\n            border-radius: 8px;\n            font-weight: 600;\n            font-size: 0.9rem;\n            color: var(--color-texto-secundario);\n            border: 2px solid var(--color-borde);\n            transition: all 0.3s;\n            white-space: nowrap;\n            flex-shrink: 0;\n        }\n        \n        .stTabs [data-baseweb=\"tab\"]:hover {\n            background-color: rgba(102, 126, 234, 0.1);\n            border-color: #667eea;\n            color: var(--color-texto);\n            transform: translateY(-2px);\n        }\n        \n        .stTabs [aria-selected=\"true\"] {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;\n            color: white !important;\n            border-color: transparent !important;\n            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);\n        }\n        \n        .pie-pagina {\n            text-align: center;\n            padding: 2rem;\n            margin-top: 4rem;\n            border-top: 2px solid var(--color-borde);\n            color: var(--color-texto-secundario);\n            font-size: 0.9rem;\n        }\n        \n        .firma-autor {\n            font-weight: 700;\n            color: #667eea;\n            font-size: 1.2rem;\n            margin: 0.5rem 0;\n        }\n        \n        div[data-testid=\"stExpander\"] {\n            background: var(--bg-tarjeta);\n            border-radius: 12px;\n            border: 2px solid var(--color-borde);\n            margin-bottom: 1rem;\n        }\n        \n        div[data-testid=\"stExpander\"] summary {\n            font-weight: 600;\n            color: var(--color-texto);\n            font-size: 1.05rem;\n        }\n        \n        .stSelectbox label, .stMultiSelect label, .stDateInput label, .stSlider label, .stCheckbox label {\n            font-weight: 600;\n            color: var(--color-texto) !important;\n            font-size: 0.95rem;\n        }\n        \n        .tooltip-info {\n            font-size: 0.85rem;\n            color: var(--color-texto-secundario);\n            font-style: italic;\n            margin-top: 0.25rem;\n        }\n        \n        /* Asegurar legibilidad en todos los elementos de Streamlit */\n        .stMarkdown, .stText, p, span, div {\n            color: var(--color-texto) !important;\n        }\n        \n        h1, h2, h3, h4, h5, h6 {\n            color: var(--color-texto) !important;\n        }\n        \n        /* Estilos responsive para navegaci√≥n */\n        @media (max-width: 1200px) {\n            .stTabs [data-baseweb=\"tab\"] {\n                font-size: 0.85rem;\n                padding: 8px 14px;\n            }\n        }\n        \n        @media (max-width: 768px) {\n            .stTabs [data-baseweb=\"tab-list\"] {\n                flex-wrap: wrap !important;\n                gap: 4px;\n            }\n            \n            .stTabs [data-baseweb=\"tab\"] {\n                font-size: 0.8rem;\n                padding: 8px 12px;\n            }\n            \n            .tarjeta-kpi {\n                margin-bottom: 1rem;\n            }\n            \n            .header-principal h1 {\n                font-size: 2rem;\n            }\n            \n            .header-principal p {\n                font-size: 1rem;\n            }\n        }\n    </style>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_descripcion_seccion(titulo, descripcion):\n    \"\"\"Crea una descripci√≥n profesional al inicio de cada secci√≥n\"\"\"\n    st.markdown(f\"\"\"\n    <div class=\"descripcion-seccion\">\n        <h4>üìã {titulo}</h4>\n        <p>{descripcion}</p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_insight(titulo, contenido):\n    \"\"\"Crea un cuadro de insight accionable\"\"\"\n    st.markdown(f\"\"\"\n    <div class=\"insight-box\">\n        <h5>üí° {titulo}</h5>\n        <p>{contenido}</p>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef crear_recomendaciones(titulo, recomendaciones):\n    \"\"\"\n    Crea un cuadro de recomendaciones profesionales\n    \n    Args:\n        titulo: T√≠tulo del cuadro de recomendaciones\n        recomendaciones: Lista de strings con las recomendaciones\n    \"\"\"\n    items_html = \"\".join([f\"<li>{rec}</li>\" for rec in recomendaciones])\n    st.markdown(f\"\"\"\n    <div class=\"recomendacion-box\">\n        <h5>üéØ {titulo}</h5>\n        <ul>{items_html}</ul>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef mostrar_info_dataset(num_transacciones, num_clientes, num_productos, fecha_min, fecha_max):\n    \"\"\"Muestra informaci√≥n resumida del dataset\"\"\"\n    a√±os = fecha_max.year - fecha_min.year + 1\n    st.info(f\"\"\"\n    üìä **Dataset Actual:** {num_transacciones:,} transacciones | {num_clientes:,} clientes | {num_productos:,} productos  \n    üìÖ **Periodo:** {fecha_min.strftime('%d/%m/%Y')} - {fecha_max.strftime('%d/%m/%Y')} ({a√±os} a√±os)\n    \"\"\")\n","size_bytes":14805},"api/__init__.py":{"content":"# API package\n","size_bytes":14},"utils/filtros.py":{"content":"\"\"\"\nSistema de Filtros Optimizado para Dashboard\nAutor: cmsr92\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\ndef obtener_rango_fecha_preset(preset):\n    \"\"\"Convierte preset de periodo a rango de fechas\"\"\"\n    fecha_fin = datetime.now()\n    \n    mapeo = {\n        '√öltimos 7 D√≠as': 7,\n        '√öltimos 30 D√≠as': 30,\n        '√öltimos 90 D√≠as': 90,\n        '√öltimo A√±o': 365,\n        'Todo el Hist√≥rico': 3650\n    }\n    \n    dias = mapeo.get(preset, 90)\n    fecha_inicio = fecha_fin - timedelta(days=dias)\n    \n    return fecha_inicio, fecha_fin\n\ndef crear_filtros_sidebar(transacciones_df):\n    \"\"\"\n    Crea sistema de filtros colapsables en sidebar sin solapamiento\n    \n    Returns:\n        dict: Diccionario con todos los filtros aplicados\n    \"\"\"\n    st.sidebar.markdown(\"### ‚öôÔ∏è Panel de Control\")\n    st.sidebar.markdown(\"---\")\n    \n    filtros = {}\n    \n    with st.sidebar.expander(\"üìÖ PERIODO DE AN√ÅLISIS\", expanded=True):\n        tipo_periodo = st.selectbox(\n            \"Seleccionar periodo\",\n            ['√öltimos 7 D√≠as', '√öltimos 30 D√≠as', '√öltimos 90 D√≠as', '√öltimo A√±o', 'Todo el Hist√≥rico'],\n            index=2,\n            help=\"Selecciona el rango temporal para el an√°lisis\"\n        )\n        \n        fecha_inicio, fecha_fin = obtener_rango_fecha_preset(tipo_periodo)\n        filtros['fecha_inicio'] = fecha_inicio\n        filtros['fecha_fin'] = fecha_fin\n        \n        st.markdown(f\"**Desde:** {fecha_inicio.strftime('%d/%m/%Y')}\")\n        st.markdown(f\"**Hasta:** {fecha_fin.strftime('%d/%m/%Y')}\")\n    \n    with st.sidebar.expander(\"üåç GEOGRAF√çA\"):\n        paises_disponibles = sorted(transacciones_df['country'].unique().tolist())\n        paises_seleccionados = st.multiselect(\n            \"Pa√≠ses\",\n            paises_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por uno o m√°s pa√≠ses (deja vac√≠o para todos)\"\n        )\n        filtros['paises'] = paises_seleccionados\n        \n        if paises_seleccionados:\n            regiones_disponibles = sorted(transacciones_df[\n                transacciones_df['country'].isin(paises_seleccionados)\n            ]['region'].unique().tolist())\n        else:\n            regiones_disponibles = sorted(transacciones_df['region'].unique().tolist())\n        \n        regiones_seleccionadas = st.multiselect(\n            \"Regiones\",\n            regiones_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por una o m√°s regiones\"\n        )\n        filtros['regiones'] = regiones_seleccionadas\n    \n    with st.sidebar.expander(\"üì¶ PRODUCTOS\"):\n        categorias_disponibles = sorted(transacciones_df['category'].unique().tolist())\n        categorias_seleccionadas = st.multiselect(\n            \"Categor√≠as\",\n            categorias_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por categor√≠as de productos\"\n        )\n        filtros['categorias'] = categorias_seleccionadas\n        \n        if categorias_seleccionadas:\n            subcategorias_disponibles = sorted(transacciones_df[\n                transacciones_df['category'].isin(categorias_seleccionadas)\n            ]['subcategory'].unique().tolist())\n        else:\n            subcategorias_disponibles = sorted(transacciones_df['subcategory'].unique().tolist())\n        \n        subcategorias_seleccionadas = st.multiselect(\n            \"Subcategor√≠as\",\n            subcategorias_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por subcategor√≠as espec√≠ficas\"\n        )\n        filtros['subcategorias'] = subcategorias_seleccionadas\n    \n    with st.sidebar.expander(\"üë• CLIENTES\"):\n        segmentos_disponibles = sorted(transacciones_df['customer_segment'].unique().tolist())\n        segmentos_seleccionados = st.multiselect(\n            \"Segmentos de Cliente\",\n            segmentos_disponibles,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por segmento de cliente (VIP, Regular, etc.)\"\n        )\n        filtros['segmentos'] = segmentos_seleccionados\n    \n    with st.sidebar.expander(\"üí≥ CANAL Y PAGO\"):\n        metodos_pago = sorted(transacciones_df['payment_method'].unique().tolist())\n        metodos_seleccionados = st.multiselect(\n            \"M√©todo de Pago\",\n            metodos_pago,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por m√©todo de pago utilizado\"\n        )\n        filtros['metodos_pago'] = metodos_seleccionados\n        \n        dispositivos = sorted(transacciones_df['device_type'].unique().tolist())\n        dispositivos_seleccionados = st.multiselect(\n            \"Tipo de Dispositivo\",\n            dispositivos,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por dispositivo usado para la compra\"\n        )\n        filtros['dispositivos'] = dispositivos_seleccionados\n        \n        fuentes_trafico = sorted(transacciones_df['traffic_source'].unique().tolist())\n        fuentes_seleccionadas = st.multiselect(\n            \"Fuente de Tr√°fico\",\n            fuentes_trafico,\n            default=[],\n            placeholder=\"Elige opciones\",\n            help=\"Filtra por canal de adquisici√≥n\"\n        )\n        filtros['fuentes_trafico'] = fuentes_seleccionadas\n    \n    with st.sidebar.expander(\"üí∞ RANGO DE PRECIOS\"):\n        precio_min = float(transacciones_df['unit_price'].min())\n        precio_max = float(transacciones_df['unit_price'].max())\n        \n        rango_precios = st.slider(\n            \"Precio Unitario (USD)\",\n            min_value=precio_min,\n            max_value=precio_max,\n            value=(precio_min, precio_max),\n            help=\"Ajusta el rango de precios unitarios\"\n        )\n        filtros['precio_min'] = rango_precios[0]\n        filtros['precio_max'] = rango_precios[1]\n    \n    with st.sidebar.expander(\"ü§ñ OPCIONES ML/IA\"):\n        mostrar_ml = st.checkbox(\n            \"Activar An√°lisis ML\",\n            value=True,\n            help=\"Mostrar predicciones y an√°lisis de Machine Learning\"\n        )\n        filtros['mostrar_ml'] = mostrar_ml\n        \n        mostrar_anomalias = st.checkbox(\n            \"Detecci√≥n de Anomal√≠as\",\n            value=False,\n            help=\"Identificar patrones an√≥malos en los datos\"\n        )\n        filtros['mostrar_anomalias'] = mostrar_anomalias\n    \n    st.sidebar.markdown(\"---\")\n    \n    num_filtros_activos = sum([\n        bool(filtros.get('paises')),\n        bool(filtros.get('regiones')),\n        bool(filtros.get('categorias')),\n        bool(filtros.get('subcategorias')),\n        bool(filtros.get('segmentos')),\n        bool(filtros.get('metodos_pago')),\n        bool(filtros.get('dispositivos')),\n        bool(filtros.get('fuentes_trafico')),\n    ])\n    \n    st.sidebar.info(f\"üîç **Filtros Activos:** {num_filtros_activos}\")\n    \n    if num_filtros_activos > 0:\n        if st.sidebar.button(\"üîÑ Limpiar Todos los Filtros\", use_container_width=True):\n            st.rerun()\n    \n    return filtros\n\ndef aplicar_filtros(df, filtros):\n    \"\"\"\n    Aplica filtros al DataFrame\n    \n    Args:\n        df: DataFrame de transacciones\n        filtros: Diccionario de filtros\n        \n    Returns:\n        DataFrame filtrado\n    \"\"\"\n    df_filtrado = df.copy()\n    \n    df_filtrado = df_filtrado[\n        (df_filtrado['date'] >= pd.Timestamp(filtros['fecha_inicio'])) & \n        (df_filtrado['date'] <= pd.Timestamp(filtros['fecha_fin']))\n    ]\n    \n    if filtros.get('paises'):\n        df_filtrado = df_filtrado[df_filtrado['country'].isin(filtros['paises'])]\n    \n    if filtros.get('regiones'):\n        df_filtrado = df_filtrado[df_filtrado['region'].isin(filtros['regiones'])]\n    \n    if filtros.get('categorias'):\n        df_filtrado = df_filtrado[df_filtrado['category'].isin(filtros['categorias'])]\n    \n    if filtros.get('subcategorias'):\n        df_filtrado = df_filtrado[df_filtrado['subcategory'].isin(filtros['subcategorias'])]\n    \n    if filtros.get('segmentos'):\n        df_filtrado = df_filtrado[df_filtrado['customer_segment'].isin(filtros['segmentos'])]\n    \n    if filtros.get('metodos_pago'):\n        df_filtrado = df_filtrado[df_filtrado['payment_method'].isin(filtros['metodos_pago'])]\n    \n    if filtros.get('dispositivos'):\n        df_filtrado = df_filtrado[df_filtrado['device_type'].isin(filtros['dispositivos'])]\n    \n    if filtros.get('fuentes_trafico'):\n        df_filtrado = df_filtrado[df_filtrado['traffic_source'].isin(filtros['fuentes_trafico'])]\n    \n    if filtros.get('precio_min') is not None and filtros.get('precio_max') is not None:\n        df_filtrado = df_filtrado[\n            (df_filtrado['unit_price'] >= filtros['precio_min']) & \n            (df_filtrado['unit_price'] <= filtros['precio_max'])\n        ]\n    \n    return df_filtrado\n","size_bytes":8974},"api/ml_endpoints.py":{"content":"from fastapi import APIRouter, HTTPException, Query\nfrom typing import Optional, List\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom database.schema import get_engine\nfrom pydantic import BaseModel\n\nrouter = APIRouter(prefix=\"/api/ml\", tags=[\"Machine Learning\"])\n\n# Response Models\nclass ForecastResponse(BaseModel):\n    dates: List[str]\n    predictions: List[float]\n    lower_bound: List[float]\n    upper_bound: List[float]\n    model_metrics: dict\n\nclass ClusterResponse(BaseModel):\n    customer_id: str\n    cluster: int\n    cluster_name: str\n    characteristics: dict\n\nclass ChurnResponse(BaseModel):\n    customer_id: str\n    churn_probability: float\n    risk_level: str\n    recommended_action: str\n\nclass RecommendationResponse(BaseModel):\n    product_id: str\n    product_name: str\n    category: str\n    score: float\n    reason: str\n\nclass DemandForecastResponse(BaseModel):\n    product_id: str\n    product_name: str\n    current_stock: int\n    forecasted_demand_30d: int\n    forecasted_demand_60d: int\n    forecasted_demand_90d: int\n    stock_out_risk: str\n    recommended_reorder: int\n\n@router.post(\"/forecast\")\ndef create_forecast(\n    days_ahead: int = Query(90, ge=7, le=180),\n    metric: str = Query(\"revenue\", description=\"revenue or orders\")\n):\n    \"\"\"\n    Genera forecast usando Prophet para revenue o orders\n    \"\"\"\n    try:\n        from prophet import Prophet\n        \n        engine = get_engine()\n        \n        # Obtener datos hist√≥ricos\n        query = f\"\"\"\n        SELECT \n            DATE(date) as ds,\n            {'SUM(total_amount_usd)' if metric == 'revenue' else 'COUNT(*)'} as y\n        FROM transactions\n        GROUP BY DATE(date)\n        ORDER BY ds\n        \"\"\"\n        \n        df = pd.read_sql_query(query, engine)\n        df['ds'] = pd.to_datetime(df['ds'])\n        \n        # Entrenar Prophet\n        model = Prophet(\n            daily_seasonality=False,\n            weekly_seasonality=True,\n            yearly_seasonality=True,\n            interval_width=0.95\n        )\n        model.fit(df)\n        \n        # Generar forecast\n        future = model.make_future_dataframe(periods=days_ahead)\n        forecast = model.predict(future)\n        \n        # Calcular m√©tricas\n        from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score\n        \n        y_true = df['y'].values\n        y_pred = forecast.iloc[:len(df)]['yhat'].values\n        \n        mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100\n        rmse = np.sqrt(mean_squared_error(y_true, y_pred))\n        r2 = r2_score(y_true, y_pred)\n        \n        # Extraer predicciones futuras\n        future_forecast = forecast.tail(days_ahead)\n        \n        return ForecastResponse(\n            dates=[d.strftime('%Y-%m-%d') for d in future_forecast['ds']],\n            predictions=future_forecast['yhat'].tolist(),\n            lower_bound=future_forecast['yhat_lower'].tolist(),\n            upper_bound=future_forecast['yhat_upper'].tolist(),\n            model_metrics={\n                'mape': round(mape, 2),\n                'rmse': round(rmse, 2),\n                'r2': round(r2, 3),\n                'training_samples': len(df)\n            }\n        )\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generando forecast: {str(e)}\")\n\n@router.get(\"/clustering/customers\")\ndef get_customer_clusters(\n    n_clusters: int = Query(5, ge=3, le=10)\n):\n    \"\"\"\n    Clustering de clientes usando K-Means\n    \"\"\"\n    try:\n        from sklearn.cluster import KMeans\n        from sklearn.preprocessing import StandardScaler\n        \n        engine = get_engine()\n        \n        # Cargar datos de clientes\n        query = \"\"\"\n        SELECT customer_id, recency_score, frequency_score, monetary_score,\n               age, total_orders, avg_order_value\n        FROM customers\n        \"\"\"\n        df = pd.read_sql_query(query, engine)\n        \n        # Preparar features\n        features = df[['recency_score', 'frequency_score', 'monetary_score', \n                       'age', 'total_orders', 'avg_order_value']]\n        \n        # Normalizar\n        scaler = StandardScaler()\n        features_scaled = scaler.fit_transform(features)\n        \n        # K-Means\n        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)\n        df['cluster'] = kmeans.fit_predict(features_scaled)\n        \n        # Caracter√≠sticas por cluster\n        clusters_info = []\n        cluster_names = ['High Value', 'Loyal', 'At Risk', 'New', 'Lost']\n        \n        for i in range(n_clusters):\n            cluster_data = df[df['cluster'] == i]\n            \n            clusters_info.append({\n                'cluster_id': i,\n                'cluster_name': cluster_names[i] if i < len(cluster_names) else f'Cluster {i}',\n                'size': len(cluster_data),\n                'avg_monetary': round(cluster_data['monetary_score'].mean(), 2),\n                'avg_frequency': round(cluster_data['frequency_score'].mean(), 2),\n                'avg_recency': round(cluster_data['recency_score'].mean(), 2)\n            })\n        \n        return {\n            'n_clusters': n_clusters,\n            'total_customers': len(df),\n            'clusters': clusters_info\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error en clustering: {str(e)}\")\n\n@router.get(\"/churn/at-risk\")\ndef get_at_risk_customers(\n    threshold: float = Query(0.7, ge=0.5, le=0.9),\n    limit: int = Query(100, le=500)\n):\n    \"\"\"\n    Obtiene clientes con alto riesgo de churn - SECURED\n    \"\"\"\n    try:\n        from sqlalchemy import text\n        engine = get_engine()\n        \n        query = text(\"\"\"\n        SELECT customer_id, country, lifetime_value, total_orders,\n               last_purchase_date, churn_probability, rfm_segment\n        FROM customers\n        WHERE churn_probability >= :threshold\n        ORDER BY churn_probability DESC, lifetime_value DESC\n        LIMIT :limit\n        \"\"\")\n        \n        df = pd.read_sql_query(query, engine, params={\"threshold\": threshold, \"limit\": limit})\n        \n        # Determinar nivel de riesgo y acci√≥n recomendada\n        results = []\n        for _, row in df.iterrows():\n            risk_level = 'Critical' if row['churn_probability'] > 0.85 else 'High'\n            \n            if row['lifetime_value'] > 1000:\n                action = 'Priority win-back campaign with personalized offer'\n            elif row['total_orders'] > 10:\n                action = 'Re-engagement email with discount'\n            else:\n                action = 'Survey to understand pain points'\n            \n            results.append(ChurnResponse(\n                customer_id=row['customer_id'],\n                churn_probability=round(row['churn_probability'], 3),\n                risk_level=risk_level,\n                recommended_action=action\n            ))\n        \n        return {\n            'threshold': threshold,\n            'total_at_risk': len(results),\n            'customers': [r.dict() for r in results]\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error obteniendo clientes en riesgo: {str(e)}\")\n\n@router.get(\"/recommendations/{product_id}\")\ndef get_product_recommendations(\n    product_id: str,\n    top_n: int = Query(10, ge=5, le=20)\n):\n    \"\"\"\n    Recomendaciones de productos basadas en co-ocurrencia (Market Basket Analysis) - SECURED\n    \"\"\"\n    try:\n        from sqlalchemy import text\n        engine = get_engine()\n        \n        # Obtener transacciones del producto\n        query1 = text(\"\"\"\n        SELECT DISTINCT customer_id\n        FROM transactions\n        WHERE product_id = :product_id\n        \"\"\")\n        customers_df = pd.read_sql_query(query1, engine, params={\"product_id\": product_id})\n        \n        if len(customers_df) == 0:\n            return {'message': 'Producto no encontrado', 'recommendations': []}\n        \n        customer_ids = customers_df['customer_id'].tolist()\n        \n        # Encontrar productos que estos clientes tambi√©n compraron\n        # Usar array binding para lista de customer_ids\n        query2 = text(\"\"\"\n        SELECT \n            product_id,\n            product_name,\n            category,\n            COUNT(DISTINCT customer_id) as customer_count,\n            SUM(total_amount_usd) as total_revenue\n        FROM transactions\n        WHERE customer_id = ANY(:customer_ids)\n            AND product_id != :product_id\n        GROUP BY product_id, product_name, category\n        ORDER BY customer_count DESC, total_revenue DESC\n        LIMIT :top_n\n        \"\"\")\n        \n        recommendations_df = pd.read_sql_query(query2, engine, params={\n            \"customer_ids\": customer_ids,\n            \"product_id\": product_id,\n            \"top_n\": top_n\n        })\n        \n        # Calcular score de recomendaci√≥n\n        total_customers = len(customers_df)\n        recommendations = []\n        \n        for _, row in recommendations_df.iterrows():\n            score = (row['customer_count'] / total_customers) * 100\n            \n            recommendations.append(RecommendationResponse(\n                product_id=row['product_id'],\n                product_name=row['product_name'],\n                category=row['category'],\n                score=round(score, 2),\n                reason=f\"{row['customer_count']} clientes que compraron este producto tambi√©n compraron esto\"\n            ))\n        \n        return {\n            'source_product_id': product_id,\n            'total_customers_analyzed': total_customers,\n            'recommendations': [r.dict() for r in recommendations]\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generando recomendaciones: {str(e)}\")\n\n@router.get(\"/demand-forecast\")\ndef get_demand_forecast(\n    top_n: int = Query(50, le=100)\n):\n    \"\"\"\n    Forecast de demanda por producto con alertas de stock-out - SECURED\n    \"\"\"\n    try:\n        from sqlalchemy import text\n        engine = get_engine()\n        \n        # Obtener ventas hist√≥ricas por producto\n        query = text(\"\"\"\n        SELECT \n            t.product_id,\n            t.product_name,\n            t.category,\n            p.stock_quantity,\n            COUNT(*) as historical_orders,\n            SUM(t.quantity) as total_units_sold,\n            AVG(t.quantity) as avg_units_per_order\n        FROM transactions t\n        JOIN products p ON t.product_id = p.product_id\n        WHERE t.date >= CURRENT_DATE - INTERVAL '90 days'\n        GROUP BY t.product_id, t.product_name, t.category, p.stock_quantity\n        ORDER BY total_units_sold DESC\n        LIMIT :top_n\n        \"\"\")\n        \n        df = pd.read_sql_query(query, engine, params={\"top_n\": top_n})\n        \n        results = []\n        \n        for _, row in df.iterrows():\n            # Calcular demanda promedio diaria\n            daily_demand = row['total_units_sold'] / 90\n            \n            # Forecast simple (demanda promedio * d√≠as)\n            forecast_30d = int(daily_demand * 30 * 1.1)  # +10% buffer\n            forecast_60d = int(daily_demand * 60 * 1.1)\n            forecast_90d = int(daily_demand * 90 * 1.1)\n            \n            # Determinar riesgo de stock-out\n            current_stock = row['stock_quantity']\n            \n            if current_stock < forecast_30d:\n                risk = 'Critical'\n                reorder = forecast_60d - current_stock\n            elif current_stock < forecast_60d:\n                risk = 'High'\n                reorder = forecast_60d - current_stock\n            elif current_stock < forecast_90d:\n                risk = 'Medium'\n                reorder = max(0, forecast_90d - current_stock)\n            else:\n                risk = 'Low'\n                reorder = 0\n            \n            results.append(DemandForecastResponse(\n                product_id=row['product_id'],\n                product_name=row['product_name'],\n                current_stock=int(current_stock),\n                forecasted_demand_30d=forecast_30d,\n                forecasted_demand_60d=forecast_60d,\n                forecasted_demand_90d=forecast_90d,\n                stock_out_risk=risk,\n                recommended_reorder=max(0, reorder)\n            ))\n        \n        return {\n            'total_products_analyzed': len(results),\n            'critical_products': len([r for r in results if r.stock_out_risk == 'Critical']),\n            'products': [r.dict() for r in results]\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error en demand forecast: {str(e)}\")\n\n@router.get(\"/anomalies\")\ndef detect_anomalies(\n    contamination: float = Query(0.05, ge=0.01, le=0.1),\n    days_back: int = Query(90, ge=30, le=365)\n):\n    \"\"\"\n    Detecci√≥n de anomal√≠as en revenue diario usando Isolation Forest - SECURED\n    \"\"\"\n    try:\n        from sklearn.ensemble import IsolationForest\n        from sqlalchemy import text\n        \n        engine = get_engine()\n        \n        start_date = (datetime.now() - timedelta(days=days_back)).strftime('%Y-%m-%d')\n        \n        query = text(\"\"\"\n        SELECT \n            DATE(date) as day,\n            COUNT(*) as orders,\n            SUM(total_amount_usd) as revenue\n        FROM transactions\n        WHERE date >= :start_date\n        GROUP BY DATE(date)\n        ORDER BY day\n        \"\"\")\n        \n        df = pd.read_sql_query(query, engine, params={\"start_date\": start_date})\n        \n        # Isolation Forest\n        iso_forest = IsolationForest(contamination=contamination, random_state=42)\n        df['anomaly'] = iso_forest.fit_predict(df[['revenue', 'orders']])\n        df['is_anomaly'] = df['anomaly'] == -1\n        \n        # Anomal√≠as detectadas\n        anomalies = df[df['is_anomaly']].copy()\n        \n        # Calcular desviaci√≥n\n        mean_revenue = df['revenue'].mean()\n        anomalies['deviation_pct'] = ((anomalies['revenue'] - mean_revenue) / mean_revenue * 100).round(2)\n        anomalies['severity'] = anomalies['deviation_pct'].abs().apply(\n            lambda x: 'Critical' if x > 50 else 'High' if x > 25 else 'Medium'\n        )\n        \n        return {\n            'total_days_analyzed': len(df),\n            'anomalies_detected': len(anomalies),\n            'contamination_rate': contamination,\n            'anomalies': anomalies[['day', 'revenue', 'orders', 'deviation_pct', 'severity']].to_dict(orient='records')\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error detectando anomal√≠as: {str(e)}\")\n","size_bytes":14599},"database/__init__.py":{"content":"# Database package\n","size_bytes":19},"replit.md":{"content":"# Global Ecommerce Analytics Platform\n\n## Overview\nThis project delivers a professional Business Intelligence dashboard for global e-commerce analytics. It processes over 770,000 transactions over 16 years, combining real and synthetic data to provide advanced KPIs, multidimensional analysis, and predictive insights. The platform features an interactive Streamlit dashboard, a FastAPI RESTful API with ML endpoints, and robust data management with PostgreSQL and Parquet. Its core purpose is to enable data-driven decision-making for e-commerce businesses through comprehensive analytics, forecasting, customer segmentation, and product performance evaluation. The platform is designed for scalability and production readiness, aiming to unlock significant market potential by providing deep insights into sales, customer behavior, and operational efficiency. The entire platform is internationalized for Spanish-speaking users, including all UI elements, data translations, and insights.\n\n## User Preferences\nI prefer detailed explanations. Do not make changes to the folder Z. Do not make changes to the file Y.\n\n## System Architecture\nThe system employs a multi-tiered architecture focusing on modularity and scalability.\n\n**UI/UX Decisions:**\nThe dashboard is built with Streamlit and features a professional, responsive design with automatic dark/light mode detection. It utilizes a corporate color palette and presents all content in professional Spanish, including contextual descriptions, KPI explanations, and actionable recommendations. Key elements include interactive visualizations with Plotly, professional tab navigation, and executive insights generation based on real-time data.\n\n**Technical Implementations & Feature Specifications:**\n\n*   **Interactive Dashboard (Streamlit):** Features 9 functional navigation tabs for comprehensive analysis: General Summary, Geography, Performance & Temporal Analysis, Products, Customers, Channel, ML & AI, Finance, and Operations. Includes 8 core KPIs, geo-spatial analysis with Folium, statistical performance analysis with moving averages and growth indicators, BCG matrix for product analysis, RFM customer segmentation with K-Means clustering, Sankey diagrams, Isolation Forest for anomaly detection, and waterfall charts for financial P&L. All data, filters, labels, and insights are fully translated into Spanish.\n*   **API RESTful (FastAPI):** Provides data and machine learning endpoints for KPIs, transactions, customers, products, aggregated analytics, forecasting, clustering, churn prediction, product recommendations, and anomaly detection. Includes endpoints for generating comprehensive Excel and PDF reports.\n*   **Database Design (Unified Parquet + PostgreSQL):** Primary data source is optimized Parquet files (774,434 transactions from 2010-2025), supplemented by PostgreSQL for development and backup. Data includes 541,909 real and 232,525 synthetically generated transactions, ensuring continuous time series and realistic distributions. Optimized indexing supports rapid query performance.\n*   **Internationalization System:** Comprehensive translation architecture ensures a 100% Spanish interface across all UI elements, data, charts, tooltips, and insights, applied automatically at data load time.\n*   **Advanced Filtering System:** Dynamic, collapsible sidebar filters allow data segmentation by date, geography, product, customer segment, payment method, device type, traffic source, and price range, all with Spanish placeholders.\n\n**System Design Choices:**\nThe project emphasizes modularity and scalability using Streamlit for rapid dashboard development and FastAPI for a high-performance, well-documented API. PostgreSQL provides robustness, with Parquet files optimizing large dataset processing. Machine learning models are integrated as API endpoints for easy consumption. Security is managed through environment variables, CORS configuration, parameterized queries, and input validation.\n\n## Recent Changes\n\n**Dashboard v4.0 - Prophet Removal & Performance Analytics (October 26, 2025):**\n\n- ‚úÖ **Prophet Forecasting Replaced with Statistical Performance Analysis:**\n  - **DECISION:** Eliminated Prophet (Meta's forecasting library) due to persistent Timestamp errors across granularities\n  - **ROOT CAUSE:** Prophet incompatible with Pandas' deprecated Timestamp arithmetic, causing \"Addition/subtraction of integers with Timestamp not supported\" errors\n  - **SOLUTION:** Replaced with robust statistical analysis approach using standard pandas/numpy operations\n  \n- ‚úÖ **New \"Rendimiento & An√°lisis Temporal\" Tab:**\n  - **Renamed from:** \"Forecasting & Tendencias\" ‚Üí \"Rendimiento & An√°lisis Temporal\"\n  - **Updated description:** Removed all references to prediction/forecasting, focused on historical performance analysis\n  - **Maintained visualizations:** Evolution chart, weekday distribution, hourly distribution (all working perfectly)\n  \n- ‚úÖ **New Performance Analysis Features:**\n  - **Growth Indicators:** Period-over-period comparison, daily growth rate, momentum detection (accelerated/decelerated/stable)\n  - **Moving Average Analysis:** Configurable windows (7/30 days, 4/12 weeks, 3/6 months) with trend detection\n  - **Automatic Insights:** Smart trend analysis comparing short-term vs long-term averages\n  - **Professional KPIs:** Revenue variation, order growth, daily growth rate, momentum status\n  \n- ‚úÖ **Technical Quality:**\n  - Zero dependency on Prophet - eliminates entire class of Timestamp errors\n  - Faster execution - no ML training required\n  - More robust - pure pandas/numpy operations\n  - Equally valuable - executive-focused growth metrics\n  \n- ‚úÖ **ML Capabilities Retained:**\n  - Isolation Forest (anomaly detection) - functional ‚úÖ\n  - K-Means clustering (customer segmentation) - functional ‚úÖ\n  - Correlation analysis - functional ‚úÖ\n  - Product recommendations - functional ‚úÖ\n  - Dashboard still ML-powered with 4 robust models\n\n- ‚úÖ **Production Status:**\n  - Dashboard 100% stable without Prophet\n  - All 9 tabs functional\n  - Zero Timestamp errors\n  - Client-ready for international delivery\n\n## External Dependencies\n*   **Streamlit:** Interactive dashboard development.\n*   **FastAPI:** RESTful API.\n*   **PostgreSQL:** Relational database.\n*   **Plotly:** Interactive data visualizations.\n*   **Folium:** Geo-spatial visualization.\n*   **SQLAlchemy:** ORM for database interactions.\n*   **Scikit-learn:** Machine learning algorithms (K-Means, Isolation Forest).\n*   **XGBoost:** Advanced predictive modeling.\n*   **ReportLab:** PDF report generation.\n*   **OpenPyXL:** Excel file export.\n*   **Pandas & NumPy:** Data manipulation and numerical operations.\n\n**Note:** Prophet (Meta) was removed in v4.0 due to compatibility issues. Replaced with statistical performance analysis.","size_bytes":6837},"README.md":{"content":"# üìä Analytics Ecommerce Global - Business Intelligence Dashboard\n\n**Desarrollado por:** CMSR92  \n**Versi√≥n:** 3.1  \n**√öltima actualizaci√≥n:** Octubre 26, 2025\n\n---\n\n## üéØ Descripci√≥n del Proyecto\n\nPlataforma profesional de **Business Intelligence** de nivel enterprise que combina **Big Data**, **Machine Learning** e **Inteligencia Artificial** para an√°lisis predictivo avanzado de ecommerce global. \n\nEste dashboard analiza **472,211 transacciones** que abarcan **16 a√±os** (2010-2025), con distribuci√≥n global realista y datos completamente internacionalizados en espa√±ol profesional.\n\n### üåü Caracter√≠sticas Destacadas\n\n- ‚úÖ **Interfaz 100% en Espa√±ol**: Todas las etiquetas, filtros, insights y traducciones\n- ‚úÖ **Datos Globales Realistas**: Estados Unidos (19.13%), Reino Unido (24%), distribuci√≥n balanceada\n- ‚úÖ **472K+ Transacciones**: Datos reales UK + sint√©ticos con distribuciones realistas\n- ‚úÖ **9 Pesta√±as de An√°lisis**: Desde resumen ejecutivo hasta ML avanzado\n- ‚úÖ **Machine Learning Integrado**: Prophet, K-Means, Isolation Forest, XGBoost\n- ‚úÖ **Visualizaciones Profesionales**: Sin etiquetas t√©cnicas, listas para presentaci√≥n\n- ‚úÖ **API RESTful Completa**: FastAPI con documentaci√≥n Swagger\n- ‚úÖ **Firma Digital**: Desarrollado por CMSR92\n\n---\n\n## üèóÔ∏è Stack Tecnol√≥gico\n\n### Frontend\n- **Streamlit** - Dashboard interactivo responsive\n- **Plotly** - Visualizaciones interactivas profesionales\n- **Folium** - Mapas geoespaciales con ISO-3\n\n### Backend\n- **FastAPI** - API RESTful de alto rendimiento\n- **PostgreSQL** - Base de datos relacional (opcional)\n- **Parquet** - Almacenamiento optimizado de datos\n\n### Machine Learning & AI\n- **Prophet (Meta)** - Forecasting con estacionalidad multiplicativa\n- **Scikit-learn** - Clustering RFM, detecci√≥n de anomal√≠as\n- **XGBoost** - Modelos predictivos avanzados\n\n### Exportaci√≥n\n- **ReportLab** - Reportes PDF profesionales\n- **OpenPyXL** - Exportaci√≥n Excel (8 hojas)\n\n---\n\n## üìä Dataset\n\n### Composici√≥n de Datos\n\n**472,211 transacciones** (2010-2025):\n- 53,036 transacciones reales (UK Online Retail Dataset)\n- 419,175 transacciones sint√©ticas con distribuciones realistas\n\n**Distribuci√≥n Global Realista:**\n- üá∫üá∏ Estados Unidos: 19.13%\n- üá¨üáß Reino Unido: 24.00%\n- üá©üá™ Alemania: 9.81%\n- üá´üá∑ Francia: 7.30%\n- üá®üá≥ China: 7.13%\n- 40+ pa√≠ses m√°s\n\n**Categor√≠as Balanceadas:**\n- üè† Hogar: 34.13%\n- üì± Electr√≥nica: 14.25%\n- üëó Moda: 14.89%\n- üõí Comestibles: 11.09%\n- üìö Libros: 8.72%\n- üß∏ Juguetes: 7.02%\n\n**M√©tricas del Cliente:**\n- 4,338 clientes √∫nicos\n- Segmentaci√≥n RFM (9 segmentos)\n- Churn probability (media: 18.4%)\n- Lifetime Value calculado\n\n---\n\n## üé® Caracter√≠sticas del Dashboard\n\n### 1. Navegaci√≥n por Pesta√±as (9 Secciones)\n\n| Pesta√±a | Contenido |\n|---------|-----------|\n| üìä **Resumen General** | 8 KPIs core, evoluci√≥n temporal, insights ejecutivos |\n| üåç **An√°lisis Geogr√°fico** | Mapa mundial ISO-3, treemap Pa√≠s‚ÜíCategor√≠a |\n| üìà **Forecasting & Tendencias** | Prophet 90 d√≠as, an√°lisis de tendencias |\n| üì¶ **An√°lisis de Productos** | BCG Matrix, top productos, rendimiento |\n| üë• **Segmentaci√≥n de Clientes** | RFM, clustering K-Means, an√°lisis de cohortes |\n| üì± **Optimizaci√≥n de Canales** | Dispositivos, tr√°fico, Sankey profesional |\n| ü§ñ **ML & IA Insights** | Anomal√≠as, clustering 3D, recomendaciones |\n| üí∞ **An√°lisis Financiero** | P&L, waterfall, m√©tricas financieras |\n| ‚öôÔ∏è **An√°lisis Operacional** | KPIs operativos, eficiencia |\n\n### 2. Sistema de Filtros Din√°micos\n\n**Filtros Colapsables en Sidebar:**\n- üìÖ Rango de fechas personalizado\n- üåç Geograf√≠a (pa√≠ses, regiones, ciudades)\n- üì¶ Productos (categor√≠as traducidas)\n- üë• Segmentos de clientes\n- üí≥ Canales y m√©todos de pago\n- üì± Tipos de dispositivo\n- üí∞ Rango de precios\n- ü§ñ Activaci√≥n de predicciones ML\n\n### 3. Visualizaciones Profesionales\n\n**Correcciones v3.1 para Cliente/Directivos:**\n- ‚úÖ Mapa mundial con c√≥digos ISO-3 (renderizado correcto)\n- ‚úÖ Treemap simplificado (Pa√≠s ‚Üí Categor√≠a, sin city)\n- ‚úÖ Gr√°fico evoluci√≥n con eje secundario (sin pico anormal)\n- ‚úÖ Prophet con estacionalidad multiplicativa (precisi√≥n mejorada)\n- ‚úÖ Churn con distribuci√≥n variada (41% muy bajo, 32% bajo)\n- ‚úÖ Etiquetas de dispositivos limpias (sin \"device=\")\n- ‚úÖ Sankey con colores diferenciados (sin \"source\"/\"target\")\n- ‚úÖ Firma CMSR92 visible y profesional\n\n### 4. Machine Learning Integrado\n\n**Modelos Implementados:**\n- **Prophet Forecasting**: 90 d√≠as con intervalo confianza 80%/95%\n- **K-Means Clustering**: 4 segmentos RFM (Champions, Loyal, At Risk, Lost)\n- **Isolation Forest**: Detecci√≥n de anomal√≠as en transacciones\n- **XGBoost**: Predicci√≥n de churn y recomendaciones\n- **Market Basket**: An√°lisis de productos relacionados\n\n**M√©tricas de Evaluaci√≥n:**\n- MAPE, RMSE, R¬≤ para forecasting\n- Silhouette Score para clustering\n- Precision/Recall para clasificaci√≥n\n\n### 5. Internacionalizaci√≥n Completa\n\n**Sistema de Traducciones Autom√°ticas:**\n- Categor√≠as: Home‚ÜíHogar, Electronics‚ÜíElectr√≥nica\n- Pa√≠ses: EIRE‚ÜíIrlanda, United Kingdom‚ÜíReino Unido\n- Tr√°fico: Organic‚ÜíOrg√°nico, Paid Ads‚ÜíAnuncios Pagados\n- Dispositivos: Mobile‚ÜíM√≥vil, Desktop‚ÜíEscritorio\n- Segmentos: New‚ÜíNuevo, VIP‚ÜíVIP, Regular‚ÜíRegular\n- M√©todos de pago traducidos\n- D√≠as de semana en espa√±ol\n\n---\n\n## üöÄ Instalaci√≥n y Ejecuci√≥n\n\n### Requisitos Previos\n\n```bash\nPython 3.11+\n```\n\n### Instalaci√≥n\n\n```bash\n# Clonar el repositorio\ngit clone <tu-repositorio>\ncd analytics-ecommerce-global\n\n# Instalar dependencias\npip install -r requirements.txt\n```\n\n### Ejecuci√≥n Local\n\n```bash\n# Dashboard Streamlit\nstreamlit run app.py\n\n# Acceder a: http://localhost:8501\n```\n\n### Deploy en Streamlit Cloud\n\n1. Sube el proyecto a GitHub\n2. Conecta tu repositorio en [share.streamlit.io](https://share.streamlit.io)\n3. Selecciona `app.py` como archivo principal\n4. ¬°Listo! Tu dashboard estar√° en l√≠nea\n\n---\n\n## üìÅ Estructura del Proyecto\n\n```\nanalytics-ecommerce-global/\n‚îú‚îÄ‚îÄ app.py                          # ‚≠ê Dashboard principal\n‚îú‚îÄ‚îÄ requirements.txt                # Dependencias Python\n‚îú‚îÄ‚îÄ .gitignore                      # Archivos ignorados\n‚îú‚îÄ‚îÄ README.md                       # Esta documentaci√≥n\n‚îú‚îÄ‚îÄ replit.md                       # Memoria t√©cnica del proyecto\n‚îÇ\n‚îú‚îÄ‚îÄ api/                            # API RESTful\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ main.py                     # Endpoints principales\n‚îÇ   ‚îî‚îÄ‚îÄ ml_endpoints.py             # Endpoints ML/IA\n‚îÇ\n‚îú‚îÄ‚îÄ data/                           # Datasets optimizados (Parquet)\n‚îÇ   ‚îú‚îÄ‚îÄ transactions_unified.parquet # 472K transacciones\n‚îÇ   ‚îú‚îÄ‚îÄ customers_unified.parquet    # 4.3K clientes\n‚îÇ   ‚îî‚îÄ‚îÄ products_unified.parquet     # 29K productos\n‚îÇ\n‚îú‚îÄ‚îÄ database/                       # Base de datos (opcional)\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ schema.py                   # Modelos SQLAlchemy\n‚îÇ   ‚îî‚îÄ‚îÄ migration_unified.py        # Migraciones\n‚îÇ\n‚îî‚îÄ‚îÄ utils/                          # Utilidades\n    ‚îú‚îÄ‚îÄ data_loader_pg.py           # Cargador con traducciones\n    ‚îú‚îÄ‚îÄ traducciones.py             # Sistema i18n (ES)\n    ‚îú‚îÄ‚îÄ ui_components.py            # Componentes UI (KPIs, firma)\n    ‚îú‚îÄ‚îÄ filtros.py                  # Sistema de filtros\n    ‚îú‚îÄ‚îÄ export_utils.py             # Exportaci√≥n Excel/PDF\n    ‚îú‚îÄ‚îÄ visualizaciones_avanzadas.py # Gr√°ficos especializados\n    ‚îú‚îÄ‚îÄ data_generator.py           # Generador sint√©tico\n    ‚îî‚îÄ‚îÄ unified_data_integration.py # Integraci√≥n de datos\n```\n\n---\n\n## üìä API Endpoints\n\n### Datos B√°sicos\n```\nGET /api/kpis                      # KPIs principales\nGET /api/transactions              # Transacciones\nGET /api/customers                 # Clientes\nGET /api/products                  # Productos\n```\n\n### Analytics Agregados\n```\nGET /api/aggregated/by_country     # Agregaci√≥n por pa√≠s\nGET /api/aggregated/by_category    # Agregaci√≥n por categor√≠a\nGET /api/aggregated/time_series    # Series temporales\n```\n\n### Machine Learning\n```\nPOST /api/ml/forecast              # Forecasting Prophet\nPOST /api/ml/cluster_customers     # Clustering K-Means\nGET  /api/ml/churn_risk           # Predicci√≥n de churn\nGET  /api/ml/recommendations      # Recomendaciones\nPOST /api/ml/anomaly_detection    # Detecci√≥n de anomal√≠as\n```\n\n### Exportaci√≥n\n```\nGET /api/export/excel             # Reporte Excel (8 hojas)\nGET /api/export/pdf               # Reporte PDF profesional\n```\n\n**Documentaci√≥n interactiva:** `http://localhost:8000/docs`\n\n---\n\n## üéØ Casos de Uso\n\n1. **An√°lisis Ejecutivo**: KPIs, tendencias, insights accionables\n2. **Segmentaci√≥n de Clientes**: RFM, clustering, predicci√≥n de churn\n3. **Forecasting de Ventas**: Predicciones Prophet a 90 d√≠as\n4. **An√°lisis Geogr√°fico**: Rendimiento por pa√≠s y regi√≥n\n5. **Optimizaci√≥n de Marketing**: Canales, dispositivos, conversi√≥n\n6. **An√°lisis Financiero**: P&L, m√°rgenes, ROI\n7. **Detecci√≥n de Anomal√≠as**: Transacciones sospechosas\n8. **An√°lisis de Productos**: BCG Matrix, top performers\n\n---\n\n## üìà Versiones\n\n### v3.1 - Correcciones Finales para Cliente (Oct 26, 2025)\n- ‚úÖ Mapa mundial corregido (ISO-3 codes)\n- ‚úÖ Treemap simplificado (sin city)\n- ‚úÖ Gr√°fico evoluci√≥n optimizado (eje secundario)\n- ‚úÖ Prophet mejorado (estacionalidad multiplicativa)\n- ‚úÖ Churn variado (distribuci√≥n realista)\n- ‚úÖ Etiquetas limpias (sin prefijos t√©cnicos)\n- ‚úÖ Sankey profesional (colores + sin labels t√©cnicos)\n- ‚úÖ Firma CMSR92 implementada\n\n### v3.0 - Regeneraci√≥n de Datos Globales (Oct 26, 2025)\n- 472K transacciones con distribuciones globales realistas\n- Estados Unidos como mercado principal (19.13%)\n- Electr√≥nica como categor√≠a mayor (14.25%)\n- Sistema de traducci√≥n extendido\n- RFM y churn mejorados\n\n---\n\n## üîí Seguridad\n\n- ‚úÖ Variables de entorno para credenciales\n- ‚úÖ Consultas parametrizadas (anti SQL injection)\n- ‚úÖ Validaci√≥n de inputs en API\n- ‚úÖ CORS configurado\n- ‚úÖ Gesti√≥n segura de secretos\n\n---\n\n## üë®‚Äçüíª Autor\n\n**CMSR92**  \n*Data Scientist | ML Engineer | BI Specialist*\n\n---\n\n## üìÑ Licencia\n\nProyecto de c√≥digo abierto bajo licencia MIT.\n\n---\n\n## üôè Agradecimientos\n\n- UCI Machine Learning Repository (Online Retail Dataset)\n- Prophet by Meta (forecasting framework)\n- Plotly (interactive visualizations)\n- Streamlit (dashboard framework)\n- Comunidad open source\n\n---\n\n**‚ú® Desarrollado por CMSR92 ‚ú®**\n\n*Dashboard profesional de Business Intelligence para ecommerce global*\n","size_bytes":10701},"api/main.py":{"content":"from fastapi import FastAPI, HTTPException, Query\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nimport pandas as pd\nfrom database.schema import get_engine\nfrom pydantic import BaseModel\nfrom sqlalchemy import text\nfrom api.ml_endpoints import router as ml_router\n\napp = FastAPI(\n    title=\"Global Ecommerce Analytics API\",\n    description=\"API REST para an√°lisis de ecommerce con Machine Learning\",\n    version=\"1.0.0\",\n    docs_url=\"/docs\",\n    redoc_url=\"/redoc\"\n)\n\n# CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include ML router\napp.include_router(ml_router)\n\n# Models\nclass KPIResponse(BaseModel):\n    total_revenue: float\n    total_orders: int\n    avg_order_value: float\n    gross_profit: float\n    total_customers: int\n    conversion_rate: float\n    period_start: str\n    period_end: str\n\nclass TransactionResponse(BaseModel):\n    transaction_id: str\n    date: datetime\n    customer_id: str\n    country: str\n    product_name: str\n    category: str\n    total_amount_usd: float\n    payment_method: str\n\nclass CustomerResponse(BaseModel):\n    customer_id: str\n    country: str\n    lifetime_value: float\n    total_orders: int\n    rfm_segment: str\n    churn_probability: float\n\nclass ProductResponse(BaseModel):\n    product_id: str\n    product_name: str\n    category: str\n    base_price: float\n    margin_percentage: float\n    rating: float\n\n# Helper function\ndef get_db_engine():\n    return get_engine()\n\n@app.get(\"/\")\ndef read_root():\n    return {\n        \"message\": \"Global Ecommerce Analytics API\",\n        \"version\": \"1.0.0\",\n        \"endpoints\": {\n            \"kpis\": \"/api/kpis\",\n            \"transactions\": \"/api/transactions\",\n            \"customers\": \"/api/customers\",\n            \"products\": \"/api/products\",\n            \"countries\": \"/api/analytics/countries\",\n            \"categories\": \"/api/analytics/categories\"\n        }\n    }\n\n@app.get(\"/api/kpis\", response_model=KPIResponse)\ndef get_kpis(\n    start_date: Optional[str] = Query(None, description=\"Start date (YYYY-MM-DD)\"),\n    end_date: Optional[str] = Query(None, description=\"End date (YYYY-MM-DD)\"),\n    country: Optional[str] = Query(None, description=\"Filter by country\"),\n    category: Optional[str] = Query(None, description=\"Filter by category\")\n):\n    \"\"\"\n    Obtiene KPIs principales del ecommerce - SECURED with parameterized queries\n    \"\"\"\n    engine = get_db_engine()\n    \n    # Fechas por defecto\n    if not end_date:\n        end_date = datetime.now().strftime('%Y-%m-%d')\n    if not start_date:\n        start_date = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')\n    \n    # Query base con par√°metros\n    query = text(\"\"\"\n    SELECT \n        COUNT(*) as total_orders,\n        SUM(total_amount_usd) as total_revenue,\n        AVG(total_amount_usd) as avg_order_value,\n        SUM(profit) as gross_profit,\n        COUNT(DISTINCT customer_id) as total_customers\n    FROM transactions\n    WHERE date >= :start_date AND date <= :end_date\n    \"\"\" + (\" AND country = :country\" if country else \"\") +\n          (\" AND category = :category\" if category else \"\"))\n    \n    params = {\"start_date\": start_date, \"end_date\": end_date}\n    if country:\n        params[\"country\"] = country\n    if category:\n        params[\"category\"] = category\n    \n    try:\n        with engine.connect() as conn:\n            result = conn.execute(query, params)\n            row = result.fetchone()\n            \n            if row is None:\n                raise HTTPException(status_code=404, detail=\"No data found\")\n            \n            total_customers = float(row[4]) if row[4] else 1\n            total_orders = float(row[0]) if row[0] else 0\n            \n            return KPIResponse(\n                total_revenue=float(row[1] or 0),\n                total_orders=int(row[0] or 0),\n                avg_order_value=float(row[2] or 0),\n                gross_profit=float(row[3] or 0),\n                total_customers=int(total_customers),\n                conversion_rate=round((total_orders / total_customers) * 100, 2) if total_customers > 0 else 0,\n                period_start=start_date,\n                period_end=end_date\n            )\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/transactions\")\ndef get_transactions(\n    limit: int = Query(100, le=1000),\n    offset: int = Query(0),\n    country: Optional[str] = None,\n    category: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    Obtiene transacciones con paginaci√≥n y filtros - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    # Construir query con condiciones din√°micas pero par√°metros seguros\n    where_clauses = []\n    params = {}\n    \n    if start_date:\n        where_clauses.append(\"date >= :start_date\")\n        params[\"start_date\"] = start_date\n    if end_date:\n        where_clauses.append(\"date <= :end_date\")\n        params[\"end_date\"] = end_date\n    if country:\n        where_clauses.append(\"country = :country\")\n        params[\"country\"] = country\n    if category:\n        where_clauses.append(\"category = :category\")\n        params[\"category\"] = category\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT * FROM transactions\n    {where_sql}\n    ORDER BY date DESC\n    LIMIT :limit OFFSET :offset\n    \"\"\")\n    \n    params[\"limit\"] = limit\n    params[\"offset\"] = offset\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params)\n        return {\n            \"total\": len(df),\n            \"limit\": limit,\n            \"offset\": offset,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/customers\")\ndef get_customers(\n    limit: int = Query(100, le=1000),\n    offset: int = Query(0),\n    country: Optional[str] = None,\n    rfm_segment: Optional[str] = None,\n    min_ltv: Optional[float] = None\n):\n    \"\"\"\n    Obtiene clientes con filtros - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    where_clauses = []\n    params = {}\n    \n    if country:\n        where_clauses.append(\"country = :country\")\n        params[\"country\"] = country\n    if rfm_segment:\n        where_clauses.append(\"rfm_segment = :rfm_segment\")\n        params[\"rfm_segment\"] = rfm_segment\n    if min_ltv is not None:\n        where_clauses.append(\"lifetime_value >= :min_ltv\")\n        params[\"min_ltv\"] = min_ltv\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT * FROM customers\n    {where_sql}\n    ORDER BY lifetime_value DESC\n    LIMIT :limit OFFSET :offset\n    \"\"\")\n    \n    params[\"limit\"] = limit\n    params[\"offset\"] = offset\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params)\n        return {\n            \"total\": len(df),\n            \"limit\": limit,\n            \"offset\": offset,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/products\")\ndef get_products(\n    limit: int = Query(100, le=500),\n    offset: int = Query(0),\n    category: Optional[str] = None,\n    min_rating: Optional[float] = None\n):\n    \"\"\"\n    Obtiene productos con filtros - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    where_clauses = []\n    params = {}\n    \n    if category:\n        where_clauses.append(\"category = :category\")\n        params[\"category\"] = category\n    if min_rating is not None:\n        where_clauses.append(\"rating >= :min_rating\")\n        params[\"min_rating\"] = min_rating\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT * FROM products\n    {where_sql}\n    ORDER BY rating DESC\n    LIMIT :limit OFFSET :offset\n    \"\"\")\n    \n    params[\"limit\"] = limit\n    params[\"offset\"] = offset\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params)\n        return {\n            \"total\": len(df),\n            \"limit\": limit,\n            \"offset\": offset,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/analytics/countries\")\ndef get_country_analytics(\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    An√°lisis de revenue por pa√≠s - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    where_clauses = []\n    params = {}\n    \n    if start_date:\n        where_clauses.append(\"date >= :start_date\")\n        params[\"start_date\"] = start_date\n    if end_date:\n        where_clauses.append(\"date <= :end_date\")\n        params[\"end_date\"] = end_date\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT \n        country,\n        COUNT(*) as orders,\n        SUM(total_amount_usd) as revenue,\n        AVG(total_amount_usd) as aov,\n        COUNT(DISTINCT customer_id) as customers\n    FROM transactions\n    {where_sql}\n    GROUP BY country\n    ORDER BY revenue DESC\n    \"\"\")\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params if params else None)\n        return {\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/analytics/categories\")\ndef get_category_analytics(\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    An√°lisis de revenue por categor√≠a - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    where_clauses = []\n    params = {}\n    \n    if start_date:\n        where_clauses.append(\"date >= :start_date\")\n        params[\"start_date\"] = start_date\n    if end_date:\n        where_clauses.append(\"date <= :end_date\")\n        params[\"end_date\"] = end_date\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT \n        category,\n        COUNT(*) as orders,\n        SUM(total_amount_usd) as revenue,\n        SUM(profit) as profit,\n        AVG((profit / NULLIF(total_amount_usd, 0)) * 100) as avg_margin\n    FROM transactions\n    {where_sql}\n    GROUP BY category\n    ORDER BY revenue DESC\n    \"\"\")\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params if params else None)\n        return {\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/analytics/time-series\")\ndef get_time_series(\n    granularity: str = Query(\"day\", description=\"day, week, or month\"),\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None\n):\n    \"\"\"\n    Serie temporal de revenue y orders - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    # Validar granularity (whitelist approach)\n    granularity_map = {\n        'day': \"DATE(date)\",\n        'week': \"DATE_TRUNC('week', date)\",\n        'month': \"DATE_TRUNC('month', date)\"\n    }\n    \n    if granularity not in granularity_map:\n        raise HTTPException(status_code=400, detail=\"Invalid granularity. Use: day, week, or month\")\n    \n    date_format = granularity_map[granularity]\n    \n    where_clauses = []\n    params = {}\n    \n    if start_date:\n        where_clauses.append(\"date >= :start_date\")\n        params[\"start_date\"] = start_date\n    if end_date:\n        where_clauses.append(\"date <= :end_date\")\n        params[\"end_date\"] = end_date\n    \n    where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n    \n    query = text(f\"\"\"\n    SELECT \n        {date_format} as period,\n        COUNT(*) as orders,\n        SUM(total_amount_usd) as revenue,\n        SUM(profit) as profit\n    FROM transactions\n    {where_sql}\n    GROUP BY {date_format}\n    ORDER BY period\n    \"\"\")\n    \n    try:\n        df = pd.read_sql_query(query, engine, params=params if params else None)\n        df['period'] = df['period'].astype(str)\n        return {\n            \"granularity\": granularity,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/analytics/top-products\")\ndef get_top_products(\n    limit: int = Query(20, le=100),\n    metric: str = Query(\"revenue\", description=\"revenue, orders, or margin\")\n):\n    \"\"\"\n    Top productos por m√©trica seleccionada - SECURED\n    \"\"\"\n    engine = get_db_engine()\n    \n    # Whitelist approach para m√©trica\n    metric_map = {\n        'revenue': 'SUM(total_amount_usd)',\n        'orders': 'COUNT(*)',\n        'margin': 'AVG(profit / NULLIF(total_amount_usd, 0) * 100)'\n    }\n    \n    if metric not in metric_map:\n        raise HTTPException(status_code=400, detail=\"Invalid metric. Use: revenue, orders, or margin\")\n    \n    metric_sql = metric_map[metric]\n    \n    query = text(f\"\"\"\n    SELECT \n        product_id,\n        product_name,\n        category,\n        COUNT(*) as orders,\n        SUM(total_amount_usd) as revenue,\n        SUM(profit) as profit,\n        SUM(quantity) as units_sold\n    FROM transactions\n    GROUP BY product_id, product_name, category\n    ORDER BY {metric_sql} DESC\n    LIMIT :limit\n    \"\"\")\n    \n    try:\n        df = pd.read_sql_query(query, engine, params={\"limit\": limit})\n        return {\n            \"metric\": metric,\n            \"data\": df.to_dict(orient='records')\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/health\")\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return {\"status\": \"healthy\", \"timestamp\": datetime.now().isoformat()}\n\n@app.get(\"/api/export/excel\")\ndef export_excel(\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    country: Optional[str] = None,\n    category: Optional[str] = None\n):\n    \"\"\"\n    Exporta datos a Excel con an√°lisis completo - SECURED\n    \"\"\"\n    from fastapi.responses import StreamingResponse\n    from utils.export_utils import create_excel_report\n    \n    try:\n        engine = get_db_engine()\n        \n        # Construir query con par√°metros seguros\n        where_clauses = []\n        params = {}\n        \n        if start_date:\n            where_clauses.append(\"date >= :start_date\")\n            params[\"start_date\"] = start_date\n        if end_date:\n            where_clauses.append(\"date <= :end_date\")\n            params[\"end_date\"] = end_date\n        if country:\n            where_clauses.append(\"country = :country\")\n            params[\"country\"] = country\n        if category:\n            where_clauses.append(\"category = :category\")\n            params[\"category\"] = category\n        \n        where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n        \n        transactions_query = text(f\"SELECT * FROM transactions {where_sql}\")\n        \n        transactions_df = pd.read_sql_query(transactions_query, engine, params=params if params else None)\n        customers_df = pd.read_sql_table('customers', engine)\n        products_df = pd.read_sql_table('products', engine)\n        \n        # Generar Excel\n        excel_buffer = create_excel_report(transactions_df, customers_df, products_df, {})\n        \n        return StreamingResponse(\n            excel_buffer,\n            media_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            headers={\n                'Content-Disposition': f'attachment; filename=ecommerce_report_{datetime.now().strftime(\"%Y%m%d\")}.xlsx'\n            }\n        )\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generando Excel: {str(e)}\")\n\n@app.get(\"/api/export/pdf\")\ndef export_pdf(\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    country: Optional[str] = None,\n    category: Optional[str] = None\n):\n    \"\"\"\n    Exporta reporte en PDF profesional - SECURED\n    \"\"\"\n    from fastapi.responses import StreamingResponse\n    from utils.export_utils import create_pdf_report\n    \n    try:\n        engine = get_db_engine()\n        \n        # Construir query con par√°metros seguros\n        where_clauses = []\n        params = {}\n        \n        if start_date:\n            where_clauses.append(\"date >= :start_date\")\n            params[\"start_date\"] = start_date\n        if end_date:\n            where_clauses.append(\"date <= :end_date\")\n            params[\"end_date\"] = end_date\n        if country:\n            where_clauses.append(\"country = :country\")\n            params[\"country\"] = country\n        if category:\n            where_clauses.append(\"category = :category\")\n            params[\"category\"] = category\n        \n        where_sql = \" WHERE \" + \" AND \".join(where_clauses) if where_clauses else \"\"\n        \n        transactions_query = text(f\"SELECT * FROM transactions {where_sql}\")\n        \n        transactions_df = pd.read_sql_query(transactions_query, engine, params=params if params else None)\n        customers_df = pd.read_sql_table('customers', engine)\n        products_df = pd.read_sql_table('products', engine)\n        \n        # Generar PDF\n        pdf_buffer = create_pdf_report(transactions_df, customers_df, products_df, {})\n        \n        return StreamingResponse(\n            pdf_buffer,\n            media_type='application/pdf',\n            headers={\n                'Content-Disposition': f'attachment; filename=ecommerce_report_{datetime.now().strftime(\"%Y%m%d\")}.pdf'\n            }\n        )\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generando PDF: {str(e)}\")\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n","size_bytes":17914},"database/schema.py":{"content":"from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Date, Boolean, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nimport os\n\nBase = declarative_base()\n\nclass Transaction(Base):\n    __tablename__ = 'transactions'\n    \n    id = Column(Integer, primary_key=True, autoincrement=True)\n    transaction_id = Column(String(50), unique=True, nullable=False, index=True)\n    date = Column(DateTime, nullable=False, index=True)\n    customer_id = Column(String(50), nullable=False, index=True)\n    country = Column(String(100), nullable=False, index=True)\n    region = Column(String(100))\n    city = Column(String(100))\n    product_id = Column(String(50), nullable=False, index=True)\n    product_name = Column(String(500))\n    category = Column(String(100), index=True)\n    subcategory = Column(String(100))\n    quantity = Column(Integer)\n    unit_price = Column(Float)\n    total_amount = Column(Float)\n    discount_applied = Column(Float)\n    payment_method = Column(String(50), index=True)\n    shipping_cost = Column(Float)\n    delivery_time = Column(Integer)\n    customer_segment = Column(String(50), index=True)\n    device_type = Column(String(50), index=True)\n    traffic_source = Column(String(50), index=True)\n    currency = Column(String(10))\n    exchange_rate = Column(Float)\n    total_amount_usd = Column(Float, index=True)\n    cost_price = Column(Float)\n    profit = Column(Float)\n\nclass Customer(Base):\n    __tablename__ = 'customers'\n    \n    id = Column(Integer, primary_key=True, autoincrement=True)\n    customer_id = Column(String(50), unique=True, nullable=False, index=True)\n    registration_date = Column(Date, nullable=False)\n    country = Column(String(100), index=True)\n    age = Column(Integer)\n    gender = Column(String(20))\n    lifetime_value = Column(Float, index=True)\n    total_orders = Column(Integer)\n    avg_order_value = Column(Float)\n    last_purchase_date = Column(DateTime)\n    recency_score = Column(Integer)\n    frequency_score = Column(Integer)\n    monetary_score = Column(Float)\n    rfm_segment = Column(String(50), index=True)\n    churn_probability = Column(Float)\n    preferred_category = Column(String(100))\n\nclass Product(Base):\n    __tablename__ = 'products'\n    \n    id = Column(Integer, primary_key=True, autoincrement=True)\n    product_id = Column(String(50), unique=True, nullable=False, index=True)\n    product_name = Column(String(500), nullable=False)\n    category = Column(String(100), nullable=False, index=True)\n    subcategory = Column(String(100))\n    brand = Column(String(100))\n    base_price = Column(Float)\n    cost_price = Column(Float)\n    margin_percentage = Column(Float)\n    stock_quantity = Column(Integer)\n    supplier_country = Column(String(100))\n    weight = Column(Float)\n    rating = Column(Float)\n    reviews_count = Column(Integer)\n    launch_date = Column(Date)\n\n# Database connection\ndef get_database_url():\n    return os.getenv('DATABASE_URL', 'postgresql://localhost/ecommerce_db')\n\ndef get_engine():\n    return create_engine(get_database_url())\n\ndef get_session():\n    engine = get_engine()\n    Session = sessionmaker(bind=engine)\n    return Session()\n\ndef create_tables():\n    engine = get_engine()\n    Base.metadata.create_all(engine)\n    print(\"‚úÖ Tablas creadas exitosamente\")\n\ndef drop_tables():\n    engine = get_engine()\n    Base.metadata.drop_all(engine)\n    print(\"üóëÔ∏è Tablas eliminadas\")\n","size_bytes":3452},"utils/data_loader.py":{"content":"import pandas as pd\nimport streamlit as st\nimport os\nfrom datetime import datetime, timedelta\n\n@st.cache_data\ndef load_or_generate_data():\n    \"\"\"Carga o genera datos si no existen\"\"\"\n    from utils.data_generator import generate_all_data\n    \n    data_dir = 'data'\n    os.makedirs(data_dir, exist_ok=True)\n    \n    transactions_path = os.path.join(data_dir, 'transactions.parquet')\n    customers_path = os.path.join(data_dir, 'customers.parquet')\n    products_path = os.path.join(data_dir, 'products.parquet')\n    \n    # Verificar si los datos ya existen\n    if os.path.exists(transactions_path) and os.path.exists(customers_path) and os.path.exists(products_path):\n        transactions_df = pd.read_parquet(transactions_path)\n        customers_df = pd.read_parquet(customers_path)\n        products_df = pd.read_parquet(products_path)\n    else:\n        # Generar datos\n        with st.spinner('Generando datos simulados (100K transacciones, 50K clientes, 500 productos)... Esto puede tardar un momento...'):\n            transactions_df, customers_df, products_df = generate_all_data(\n                n_transactions=100000,\n                n_customers=50000,\n                n_products=500\n            )\n            \n            # Guardar para uso futuro\n            transactions_df.to_parquet(transactions_path)\n            customers_df.to_parquet(customers_path)\n            products_df.to_parquet(products_path)\n    \n    # Convertir fecha a datetime\n    transactions_df['date'] = pd.to_datetime(transactions_df['date'])\n    customers_df['registration_date'] = pd.to_datetime(customers_df['registration_date'])\n    customers_df['last_purchase_date'] = pd.to_datetime(customers_df['last_purchase_date'])\n    products_df['launch_date'] = pd.to_datetime(products_df['launch_date'])\n    \n    return transactions_df, customers_df, products_df\n\ndef filter_data(df, filters):\n    \"\"\"Aplica filtros al DataFrame\"\"\"\n    filtered_df = df.copy()\n    \n    if 'date_range' in filters and filters['date_range']:\n        start_date, end_date = filters['date_range']\n        filtered_df = filtered_df[(filtered_df['date'] >= pd.Timestamp(start_date)) & \n                                   (filtered_df['date'] <= pd.Timestamp(end_date))]\n    \n    if 'countries' in filters and filters['countries']:\n        filtered_df = filtered_df[filtered_df['country'].isin(filters['countries'])]\n    \n    if 'categories' in filters and filters['categories']:\n        filtered_df = filtered_df[filtered_df['category'].isin(filters['categories'])]\n    \n    if 'segments' in filters and filters['segments']:\n        filtered_df = filtered_df[filtered_df['customer_segment'].isin(filters['segments'])]\n    \n    if 'payment_methods' in filters and filters['payment_methods']:\n        filtered_df = filtered_df[filtered_df['payment_method'].isin(filters['payment_methods'])]\n    \n    if 'device_types' in filters and filters['device_types']:\n        filtered_df = filtered_df[filtered_df['device_type'].isin(filters['device_types'])]\n    \n    if 'traffic_sources' in filters and filters['traffic_sources']:\n        filtered_df = filtered_df[filtered_df['traffic_source'].isin(filters['traffic_sources'])]\n    \n    if 'price_range' in filters and filters['price_range']:\n        min_price, max_price = filters['price_range']\n        filtered_df = filtered_df[(filtered_df['unit_price'] >= min_price) & \n                                   (filtered_df['unit_price'] <= max_price)]\n    \n    return filtered_df\n\ndef get_date_range_preset(preset):\n    \"\"\"Devuelve rango de fechas basado en preset\"\"\"\n    end_date = datetime.now()\n    \n    if preset == 'Today':\n        start_date = end_date - timedelta(days=1)\n    elif preset == 'Last 7 Days':\n        start_date = end_date - timedelta(days=7)\n    elif preset == 'Last 30 Days':\n        start_date = end_date - timedelta(days=30)\n    elif preset == 'Last 90 Days':\n        start_date = end_date - timedelta(days=90)\n    elif preset == 'Last Year':\n        start_date = end_date - timedelta(days=365)\n    elif preset == 'All Time':\n        start_date = end_date - timedelta(days=730)\n    else:\n        start_date = end_date - timedelta(days=30)\n    \n    return start_date, end_date\n","size_bytes":4195},"database/migration.py":{"content":"import pandas as pd\nimport os\nfrom database.schema import get_session, create_tables, drop_tables, Transaction, Customer, Product\nfrom sqlalchemy.exc import IntegrityError\nfrom tqdm import tqdm\n\ndef migrate_data_to_postgres():\n    \"\"\"Migra datos desde Parquet a PostgreSQL\"\"\"\n    \n    # Crear tablas\n    print(\"üìä Creando esquema de base de datos...\")\n    create_tables()\n    \n    # Verificar que existen los archivos Parquet\n    data_dir = 'data'\n    transactions_path = os.path.join(data_dir, 'transactions.parquet')\n    customers_path = os.path.join(data_dir, 'customers.parquet')\n    products_path = os.path.join(data_dir, 'products.parquet')\n    \n    if not all([os.path.exists(p) for p in [transactions_path, customers_path, products_path]]):\n        print(\"‚ùå No se encontraron archivos Parquet. Genera los datos primero.\")\n        return False\n    \n    session = get_session()\n    \n    try:\n        # Migrar productos\n        print(\"\\nüì¶ Migrando productos...\")\n        products_df = pd.read_parquet(products_path)\n        \n        for _, row in tqdm(products_df.iterrows(), total=len(products_df)):\n            product = Product(\n                product_id=row['product_id'],\n                product_name=row['product_name'],\n                category=row['category'],\n                subcategory=row['subcategory'],\n                brand=row['brand'],\n                base_price=float(row['base_price']),\n                cost_price=float(row['cost_price']),\n                margin_percentage=float(row['margin_percentage']),\n                stock_quantity=int(row['stock_quantity']),\n                supplier_country=row['supplier_country'],\n                weight=float(row['weight']),\n                rating=float(row['rating']),\n                reviews_count=int(row['reviews_count']),\n                launch_date=pd.to_datetime(row['launch_date']).date()\n            )\n            session.add(product)\n        \n        session.commit()\n        print(f\"‚úÖ {len(products_df)} productos migrados\")\n        \n        # Migrar clientes\n        print(\"\\nüë• Migrando clientes...\")\n        customers_df = pd.read_parquet(customers_path)\n        \n        for _, row in tqdm(customers_df.iterrows(), total=len(customers_df)):\n            customer = Customer(\n                customer_id=row['customer_id'],\n                registration_date=pd.to_datetime(row['registration_date']).date(),\n                country=row['country'],\n                age=int(row['age']),\n                gender=row['gender'],\n                lifetime_value=float(row['lifetime_value']),\n                total_orders=int(row['total_orders']),\n                avg_order_value=float(row['avg_order_value']),\n                last_purchase_date=pd.to_datetime(row['last_purchase_date']),\n                recency_score=int(row['recency_score']),\n                frequency_score=int(row['frequency_score']),\n                monetary_score=float(row['monetary_score']),\n                rfm_segment=row['rfm_segment'],\n                churn_probability=float(row['churn_probability']),\n                preferred_category=row['preferred_category']\n            )\n            session.add(customer)\n        \n        session.commit()\n        print(f\"‚úÖ {len(customers_df)} clientes migrados\")\n        \n        # Migrar transacciones (en batches para mejor performance)\n        print(\"\\nüí≥ Migrando transacciones...\")\n        transactions_df = pd.read_parquet(transactions_path)\n        \n        batch_size = 1000\n        for i in tqdm(range(0, len(transactions_df), batch_size)):\n            batch = transactions_df.iloc[i:i+batch_size]\n            \n            for _, row in batch.iterrows():\n                transaction = Transaction(\n                    transaction_id=row['transaction_id'],\n                    date=pd.to_datetime(row['date']),\n                    customer_id=row['customer_id'],\n                    country=row['country'],\n                    region=row['region'],\n                    city=row['city'],\n                    product_id=row['product_id'],\n                    product_name=row['product_name'],\n                    category=row['category'],\n                    subcategory=row['subcategory'],\n                    quantity=int(row['quantity']),\n                    unit_price=float(row['unit_price']),\n                    total_amount=float(row['total_amount']),\n                    discount_applied=float(row['discount_applied']),\n                    payment_method=row['payment_method'],\n                    shipping_cost=float(row['shipping_cost']),\n                    delivery_time=int(row['delivery_time']),\n                    customer_segment=row['customer_segment'],\n                    device_type=row['device_type'],\n                    traffic_source=row['traffic_source'],\n                    currency=row['currency'],\n                    exchange_rate=float(row['exchange_rate']),\n                    total_amount_usd=float(row['total_amount_usd']),\n                    cost_price=float(row['cost_price']),\n                    profit=float(row['profit'])\n                )\n                session.add(transaction)\n            \n            session.commit()\n        \n        print(f\"‚úÖ {len(transactions_df)} transacciones migradas\")\n        \n        print(\"\\nüéâ ¬°Migraci√≥n completada exitosamente!\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error durante la migraci√≥n: {str(e)}\")\n        session.rollback()\n        return False\n    finally:\n        session.close()\n\nif __name__ == \"__main__\":\n    migrate_data_to_postgres()\n","size_bytes":5589},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"faker>=37.12.0\",\n    \"fastapi>=0.120.0\",\n    \"folium>=0.20.0\",\n    \"matplotlib>=3.10.7\",\n    \"numpy>=2.3.4\",\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.3.3\",\n    \"plotly>=6.3.1\",\n    \"prophet>=1.2.1\",\n    \"psycopg2-binary>=2.9.11\",\n    \"reportlab>=4.4.4\",\n    \"scikit-learn>=1.7.2\",\n    \"seaborn>=0.13.2\",\n    \"sqlalchemy>=2.0.44\",\n    \"streamlit>=1.50.0\",\n    \"streamlit-folium>=0.25.3\",\n    \"uvicorn>=0.38.0\",\n    \"xgboost>=3.1.1\",\n]\n","size_bytes":578},"utils/data_loader_pg.py":{"content":"import pandas as pd\nimport streamlit as st\nfrom sqlalchemy import text\nfrom database.schema import get_engine, get_session\nfrom datetime import datetime, timedelta\nfrom utils.traducciones import (\n    aplicar_traducciones_df, \n    aplicar_traducciones_paises_df,\n    aplicar_traducciones_rfm_df,\n    aplicar_traducciones_dispositivos_df,\n    aplicar_traducciones_metodos_pago_df,\n    aplicar_traducciones_fuentes_trafico_df,\n    aplicar_traducciones_segmentos_clientes_df\n)\n\n@st.cache_data(ttl=300)\ndef load_data_from_postgres():\n    \"\"\"Carga datos desde archivos unificados (Parquet) o PostgreSQL\"\"\"\n    import os\n    \n    # Verificar si existen archivos unificados\n    use_unified = os.path.exists('data/transactions_unified.parquet')\n    \n    if use_unified:\n        try:\n            # Cargar desde archivos unificados\n            transactions_df = pd.read_parquet('data/transactions_unified.parquet')\n            customers_df = pd.read_parquet('data/customers_unified.parquet')\n            products_df = pd.read_parquet('data/products_unified.parquet')\n            \n            # Convertir fechas\n            transactions_df['date'] = pd.to_datetime(transactions_df['date'])\n            customers_df['registration_date'] = pd.to_datetime(customers_df['registration_date'])\n            customers_df['last_purchase_date'] = pd.to_datetime(customers_df['last_purchase_date'])\n            if 'launch_date' in products_df.columns:\n                products_df['launch_date'] = pd.to_datetime(products_df['launch_date'])\n            \n            # Traducir categor√≠as al espa√±ol\n            transactions_df = aplicar_traducciones_df(transactions_df, 'category')\n            products_df = aplicar_traducciones_df(products_df, 'category')\n            if 'subcategory' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_df(transactions_df, 'subcategory')\n            if 'subcategory' in products_df.columns:\n                products_df = aplicar_traducciones_df(products_df, 'subcategory')\n            \n            # Traducir pa√≠ses al espa√±ol\n            transactions_df = aplicar_traducciones_paises_df(transactions_df, 'country')\n            customers_df = aplicar_traducciones_paises_df(customers_df, 'country')\n            \n            # Traducir segmentos RFM al espa√±ol\n            if 'rfm_segment' in customers_df.columns:\n                customers_df = aplicar_traducciones_rfm_df(customers_df, 'rfm_segment')\n            \n            # Traducir dispositivos al espa√±ol\n            if 'device_type' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_dispositivos_df(transactions_df, 'device_type')\n            \n            # Traducir m√©todos de pago al espa√±ol\n            if 'payment_method' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_metodos_pago_df(transactions_df, 'payment_method')\n            \n            # Traducir fuentes de tr√°fico al espa√±ol\n            if 'traffic_source' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_fuentes_trafico_df(transactions_df, 'traffic_source')\n            \n            # Traducir segmentos de clientes al espa√±ol\n            if 'customer_segment' in transactions_df.columns:\n                transactions_df = aplicar_traducciones_segmentos_clientes_df(transactions_df, 'customer_segment')\n            if 'customer_segment' in customers_df.columns:\n                customers_df = aplicar_traducciones_segmentos_clientes_df(customers_df, 'customer_segment')\n            \n            return transactions_df, customers_df, products_df\n            \n        except Exception as e:\n            pass\n    \n    # Fallback a PostgreSQL\n    engine = get_engine()\n    \n    try:\n        # Cargar transacciones\n        transactions_df = pd.read_sql_table('transactions', engine)\n        \n        # Cargar clientes\n        customers_df = pd.read_sql_table('customers', engine)\n        \n        # Cargar productos\n        products_df = pd.read_sql_table('products', engine)\n        \n        # Convertir fechas\n        transactions_df['date'] = pd.to_datetime(transactions_df['date'])\n        customers_df['registration_date'] = pd.to_datetime(customers_df['registration_date'])\n        customers_df['last_purchase_date'] = pd.to_datetime(customers_df['last_purchase_date'])\n        products_df['launch_date'] = pd.to_datetime(products_df['launch_date'])\n        \n        # Traducir categor√≠as al espa√±ol\n        transactions_df = aplicar_traducciones_df(transactions_df, 'category')\n        products_df = aplicar_traducciones_df(products_df, 'category')\n        if 'subcategory' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_df(transactions_df, 'subcategory')\n        if 'subcategory' in products_df.columns:\n            products_df = aplicar_traducciones_df(products_df, 'subcategory')\n        \n        # Traducir pa√≠ses al espa√±ol\n        transactions_df = aplicar_traducciones_paises_df(transactions_df, 'country')\n        customers_df = aplicar_traducciones_paises_df(customers_df, 'country')\n        \n        # Traducir segmentos RFM al espa√±ol\n        if 'rfm_segment' in customers_df.columns:\n            customers_df = aplicar_traducciones_rfm_df(customers_df, 'rfm_segment')\n        \n        # Traducir dispositivos al espa√±ol\n        if 'device_type' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_dispositivos_df(transactions_df, 'device_type')\n        \n        # Traducir m√©todos de pago al espa√±ol\n        if 'payment_method' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_metodos_pago_df(transactions_df, 'payment_method')\n        \n        # Traducir fuentes de tr√°fico al espa√±ol\n        if 'traffic_source' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_fuentes_trafico_df(transactions_df, 'traffic_source')\n        \n        # Traducir segmentos de clientes al espa√±ol\n        if 'customer_segment' in transactions_df.columns:\n            transactions_df = aplicar_traducciones_segmentos_clientes_df(transactions_df, 'customer_segment')\n        if 'customer_segment' in customers_df.columns:\n            customers_df = aplicar_traducciones_segmentos_clientes_df(customers_df, 'customer_segment')\n        \n        return transactions_df, customers_df, products_df\n        \n    except Exception as e:\n        st.error(f\"Error loading data: {str(e)}\")\n        return None, None, None\n\n@st.cache_data\ndef load_or_generate_data():\n    \"\"\"Carga datos desde fuente disponible\"\"\"\n    # Cargar directamente sin mensajes\n    return load_data_from_postgres()\n\ndef filter_data(df, filters):\n    \"\"\"Aplica filtros al DataFrame\"\"\"\n    filtered_df = df.copy()\n    \n    if 'date_range' in filters and filters['date_range']:\n        start_date, end_date = filters['date_range']\n        filtered_df = filtered_df[(filtered_df['date'] >= pd.Timestamp(start_date)) & \n                                   (filtered_df['date'] <= pd.Timestamp(end_date))]\n    \n    if 'countries' in filters and filters['countries']:\n        filtered_df = filtered_df[filtered_df['country'].isin(filters['countries'])]\n    \n    if 'categories' in filters and filters['categories']:\n        filtered_df = filtered_df[filtered_df['category'].isin(filters['categories'])]\n    \n    if 'segments' in filters and filters['segments']:\n        filtered_df = filtered_df[filtered_df['customer_segment'].isin(filters['segments'])]\n    \n    if 'payment_methods' in filters and filters['payment_methods']:\n        filtered_df = filtered_df[filtered_df['payment_method'].isin(filters['payment_methods'])]\n    \n    if 'device_types' in filters and filters['device_types']:\n        filtered_df = filtered_df[filtered_df['device_type'].isin(filters['device_types'])]\n    \n    if 'traffic_sources' in filters and filters['traffic_sources']:\n        filtered_df = filtered_df[filtered_df['traffic_source'].isin(filters['traffic_sources'])]\n    \n    if 'price_range' in filters and filters['price_range']:\n        min_price, max_price = filters['price_range']\n        filtered_df = filtered_df[(filtered_df['unit_price'] >= min_price) & \n                                   (filtered_df['unit_price'] <= max_price)]\n    \n    return filtered_df\n\ndef get_date_range_preset(preset):\n    \"\"\"Devuelve rango de fechas basado en preset\"\"\"\n    end_date = datetime.now()\n    \n    if preset == 'Today':\n        start_date = end_date - timedelta(days=1)\n    elif preset == 'Last 7 Days':\n        start_date = end_date - timedelta(days=7)\n    elif preset == 'Last 30 Days':\n        start_date = end_date - timedelta(days=30)\n    elif preset == 'Last 90 Days':\n        start_date = end_date - timedelta(days=90)\n    elif preset == 'Last Year':\n        start_date = end_date - timedelta(days=365)\n    elif preset == 'All Time':\n        start_date = end_date - timedelta(days=730)\n    else:\n        start_date = end_date - timedelta(days=30)\n    \n    return start_date, end_date\n\n@st.cache_data(ttl=60)\ndef get_kpis_from_db(start_date, end_date, filters=None):\n    \"\"\"Obtiene KPIs directamente desde PostgreSQL con query optimizada\"\"\"\n    engine = get_engine()\n    \n    query = f\"\"\"\n    SELECT \n        COUNT(*) as total_orders,\n        SUM(total_amount_usd) as total_revenue,\n        AVG(total_amount_usd) as avg_order_value,\n        SUM(profit) as total_profit,\n        COUNT(DISTINCT customer_id) as total_customers\n    FROM transactions\n    WHERE date >= '{start_date}' AND date <= '{end_date}'\n    \"\"\"\n    \n    if filters:\n        if 'countries' in filters and filters['countries']:\n            countries_str = \"','\".join(filters['countries'])\n            query += f\" AND country IN ('{countries_str}')\"\n        \n        if 'categories' in filters and filters['categories']:\n            categories_str = \"','\".join(filters['categories'])\n            query += f\" AND category IN ('{categories_str}')\"\n    \n    try:\n        result = pd.read_sql_query(query, engine)\n        return result.iloc[0].to_dict()\n    except:\n        return None\n","size_bytes":10100},"main.py":{"content":"def main():\n    print(\"Hello from repl-nix-workspace!\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":96},"utils/traducciones.py":{"content":"\"\"\"\nTraducciones completas al espa√±ol para el dashboard\nIncluye: categor√≠as, pa√≠ses, d√≠as, segmentos RFM, dispositivos, m√©todos de pago\n\"\"\"\n\nimport pandas as pd\n\n# Diccionario de traducci√≥n de segmentos RFM\nSEGMENTOS_RFM_TRADUCCION = {\n    'Champions': 'Campeones',\n    'Loyal Customers': 'Clientes Leales',\n    'Potential Loyalists': 'Potencialmente Leales',\n    'Recent Customers': 'Clientes Recientes',\n    'Promising': 'Prometedores',\n    'Customers Needing Attention': 'Necesitan Atenci√≥n',\n    'About To Sleep': 'Por Dormir',\n    'At Risk': 'En Riesgo',\n    'Cant Lose Them': 'No Perderlos',\n    'Hibernating': 'Hibernando',\n    'Lost': 'Perdidos',\n    # Versiones alternativas\n    'Cant Lose': 'No Perderlos',\n    'Lost Customers': 'Perdidos',\n    # Min√∫sculas tambi√©n\n    'champions': 'Campeones',\n    'loyal customers': 'Clientes Leales',\n    'potential loyalists': 'Potencialmente Leales',\n    'recent customers': 'Clientes Recientes',\n    'promising': 'Prometedores',\n    'customers needing attention': 'Necesitan Atenci√≥n',\n    'about to sleep': 'Por Dormir',\n    'at risk': 'En Riesgo',\n    'cant lose them': 'No Perderlos',\n    'hibernating': 'Hibernando',\n    'lost': 'Perdidos'\n}\n\n# Diccionario de traducci√≥n de dispositivos\nDISPOSITIVOS_TRADUCCION = {\n    'Mobile': 'M√≥vil',\n    'Tablet': 'Tableta',\n    'Desktop': 'Escritorio',\n    'mobile': 'M√≥vil',\n    'tablet': 'Tableta',\n    'desktop': 'Escritorio'\n}\n\n# Diccionario de traducci√≥n de m√©todos de pago\nMETODOS_PAGO_TRADUCCION = {\n    'Credit Card': 'Tarjeta de Cr√©dito',\n    'Debit Card': 'Tarjeta de D√©bito',\n    'PayPal': 'PayPal',\n    'Bank Transfer': 'Transferencia Bancaria',\n    'Cash': 'Efectivo',\n    'Wire Transfer': 'Transferencia',\n    # Min√∫sculas\n    'credit card': 'Tarjeta de Cr√©dito',\n    'debit card': 'Tarjeta de D√©bito',\n    'paypal': 'PayPal',\n    'bank transfer': 'Transferencia Bancaria',\n    'cash': 'Efectivo',\n    'wire transfer': 'Transferencia'\n}\n\n# Diccionario de traducci√≥n de pa√≠ses\nPAISES_TRADUCCION = {\n    'United Kingdom': 'Reino Unido',\n    'United States': 'Estados Unidos',\n    'France': 'Francia',\n    'Germany': 'Alemania',\n    'Spain': 'Espa√±a',\n    'Italy': 'Italia',\n    'Netherlands': 'Pa√≠ses Bajos',\n    'Belgium': 'B√©lgica',\n    'Switzerland': 'Suiza',\n    'Portugal': 'Portugal',\n    'Sweden': 'Suecia',\n    'Norway': 'Noruega',\n    'Denmark': 'Dinamarca',\n    'Finland': 'Finlandia',\n    'Poland': 'Polonia',\n    'Austria': 'Austria',\n    'Greece': 'Grecia',\n    'Ireland': 'Irlanda',\n    'EIRE': 'Irlanda',\n    'Czech Republic': 'Rep√∫blica Checa',\n    'Hungary': 'Hungr√≠a',\n    'Romania': 'Rumania',\n    'Bulgaria': 'Bulgaria',\n    'Croatia': 'Croacia',\n    'Slovakia': 'Eslovaquia',\n    'Slovenia': 'Eslovenia',\n    'Lithuania': 'Lituania',\n    'Latvia': 'Letonia',\n    'Estonia': 'Estonia',\n    'Luxembourg': 'Luxemburgo',\n    'Malta': 'Malta',\n    'Cyprus': 'Chipre',\n    'Australia': 'Australia',\n    'Canada': 'Canad√°',\n    'Japan': 'Jap√≥n',\n    'China': 'China',\n    'India': 'India',\n    'Brazil': 'Brasil',\n    'Mexico': 'M√©xico',\n    'Argentina': 'Argentina',\n    'Chile': 'Chile',\n    'Colombia': 'Colombia',\n    'Peru': 'Per√∫',\n    'Venezuela': 'Venezuela',\n    'Ecuador': 'Ecuador',\n    'Uruguay': 'Uruguay',\n    'Paraguay': 'Paraguay',\n    'Bolivia': 'Bolivia',\n    'Costa Rica': 'Costa Rica',\n    'Panama': 'Panam√°',\n    'Guatemala': 'Guatemala',\n    'Honduras': 'Honduras',\n    'Nicaragua': 'Nicaragua',\n    'El Salvador': 'El Salvador',\n    'Dominican Republic': 'Rep√∫blica Dominicana',\n    'Cuba': 'Cuba',\n    'Puerto Rico': 'Puerto Rico',\n    'Jamaica': 'Jamaica',\n    'Trinidad and Tobago': 'Trinidad y Tobago',\n    'Bahamas': 'Bahamas',\n    'Barbados': 'Barbados',\n    'South Africa': 'Sud√°frica',\n    'Egypt': 'Egipto',\n    'Morocco': 'Marruecos',\n    'Tunisia': 'T√∫nez',\n    'Algeria': 'Argelia',\n    'Kenya': 'Kenia',\n    'Nigeria': 'Nigeria',\n    'Ghana': 'Ghana',\n    'Ethiopia': 'Etiop√≠a',\n    'Tanzania': 'Tanzania',\n    'Uganda': 'Uganda',\n    'Zimbabwe': 'Zimbabue',\n    'South Korea': 'Corea del Sur',\n    'North Korea': 'Corea del Norte',\n    'Singapore': 'Singapur',\n    'Malaysia': 'Malasia',\n    'Indonesia': 'Indonesia',\n    'Philippines': 'Filipinas',\n    'Thailand': 'Tailandia',\n    'Vietnam': 'Vietnam',\n    'Cambodia': 'Camboya',\n    'Laos': 'Laos',\n    'Myanmar': 'Myanmar',\n    'Bangladesh': 'Banglad√©s',\n    'Pakistan': 'Pakist√°n',\n    'Sri Lanka': 'Sri Lanka',\n    'Nepal': 'Nepal',\n    'Afghanistan': 'Afganist√°n',\n    'Iran': 'Ir√°n',\n    'Iraq': 'Irak',\n    'Saudi Arabia': 'Arabia Saudita',\n    'United Arab Emirates': 'Emiratos √Årabes Unidos',\n    'Kuwait': 'Kuwait',\n    'Qatar': 'Catar',\n    'Bahrain': 'Bar√©in',\n    'Oman': 'Om√°n',\n    'Jordan': 'Jordania',\n    'Lebanon': 'L√≠bano',\n    'Syria': 'Siria',\n    'Israel': 'Israel',\n    'Palestine': 'Palestina',\n    'Turkey': 'Turqu√≠a',\n    'Russia': 'Rusia',\n    'Ukraine': 'Ucrania',\n    'Belarus': 'Bielorrusia',\n    'Moldova': 'Moldavia',\n    'Georgia': 'Georgia',\n    'Armenia': 'Armenia',\n    'Azerbaijan': 'Azerbaiy√°n',\n    'Kazakhstan': 'Kazajist√°n',\n    'Uzbekistan': 'Uzbekist√°n',\n    'Turkmenistan': 'Turkmenist√°n',\n    'Kyrgyzstan': 'Kirguist√°n',\n    'Tajikistan': 'Tayikist√°n',\n    'New Zealand': 'Nueva Zelanda',\n    'Fiji': 'Fiyi',\n    'Papua New Guinea': 'Pap√∫a Nueva Guinea',\n    'Iceland': 'Islandia'\n}\n\n# Diccionario de traducci√≥n de d√≠as de semana\nDIAS_SEMANA_TRADUCCION = {\n    'Monday': 'Lunes',\n    'Tuesday': 'Martes',\n    'Wednesday': 'Mi√©rcoles',\n    'Thursday': 'Jueves',\n    'Friday': 'Viernes',\n    'Saturday': 'S√°bado',\n    'Sunday': 'Domingo',\n    # Abreviaciones\n    'Mon': 'Lun',\n    'Tue': 'Mar',\n    'Wed': 'Mi√©',\n    'Thu': 'Jue',\n    'Fri': 'Vie',\n    'Sat': 'S√°b',\n    'Sun': 'Dom'\n}\n\n# Diccionario de traducci√≥n de meses\nMESES_TRADUCCION = {\n    'January': 'Enero',\n    'February': 'Febrero',\n    'March': 'Marzo',\n    'April': 'Abril',\n    'May': 'Mayo',\n    'June': 'Junio',\n    'July': 'Julio',\n    'August': 'Agosto',\n    'September': 'Septiembre',\n    'October': 'Octubre',\n    'November': 'Noviembre',\n    'December': 'Diciembre',\n    # Abreviaciones\n    'Jan': 'Ene',\n    'Feb': 'Feb',\n    'Mar': 'Mar',\n    'Apr': 'Abr',\n    'May': 'May',\n    'Jun': 'Jun',\n    'Jul': 'Jul',\n    'Aug': 'Ago',\n    'Sep': 'Sep',\n    'Oct': 'Oct',\n    'Nov': 'Nov',\n    'Dec': 'Dic'\n}\n\n# Diccionario de traducci√≥n de categor√≠as\nCATEGORIAS_TRADUCCION = {\n    # Categor√≠as principales\n    'Books': 'Libros',\n    'Electronics': 'Electr√≥nica',\n    'Clothing': 'Ropa',\n    'Home & Garden': 'Hogar y Jard√≠n',\n    'Home': 'Hogar',\n    'Sports': 'Deportes',\n    'Toys': 'Juguetes',\n    'Beauty': 'Belleza',\n    'Food': 'Alimentos',\n    'Groceries': 'Comestibles',\n    'Fashion': 'Moda',\n    'Health': 'Salud',\n    'Automotive': 'Automotriz',\n    'Office': 'Oficina',\n    'Pet Supplies': 'Mascotas',\n    'Music': 'M√∫sica',\n    'Movies': 'Pel√≠culas',\n    'Games': 'Videojuegos',\n    'Baby': 'Beb√©',\n    'Tools': 'Herramientas',\n    'Jewelry': 'Joyer√≠a',\n    'Shoes': 'Calzado',\n    'Outdoor': 'Exterior',\n    \n    # Subcategor√≠as comunes\n    'book': 'libros',\n    'electronics': 'electr√≥nica',\n    'clothing': 'ropa',\n    'home': 'hogar',\n    'garden': 'jard√≠n',\n    'sports': 'deportes',\n    'toys': 'juguetes',\n    'beauty': 'belleza',\n    'food': 'alimentos',\n    'groceries': 'comestibles',\n    'fashion': 'moda',\n    'health': 'salud',\n    'automotive': 'automotriz',\n    'office': 'oficina',\n    'pet': 'mascotas',\n    'music': 'm√∫sica',\n    'movies': 'pel√≠culas',\n    'games': 'videojuegos',\n    'baby': 'beb√©',\n    'tools': 'herramientas',\n    'jewelry': 'joyer√≠a',\n    'shoes': 'calzado',\n    'outdoor': 'exterior'\n}\n\n# Diccionario de traducci√≥n de fuentes de tr√°fico\nFUENTES_TRAFICO_TRADUCCION = {\n    'Direct': 'Directo',\n    'Organic': 'Org√°nico',\n    'Paid Ads': 'Anuncios Pagados',\n    'Social Media': 'Redes Sociales',\n    'Email': 'Correo Electr√≥nico',\n    'Referral': 'Referencia',\n    'Affiliate': 'Afiliado',\n    # Min√∫sculas\n    'direct': 'Directo',\n    'organic': 'Org√°nico',\n    'paid ads': 'Anuncios Pagados',\n    'social media': 'Redes Sociales',\n    'email': 'Correo Electr√≥nico',\n    'referral': 'Referencia',\n    'affiliate': 'Afiliado'\n}\n\n# Diccionario de traducci√≥n de segmentos de clientes\nSEGMENTOS_CLIENTES_TRADUCCION = {\n    'New': 'Nuevo',\n    'Regular': 'Regular',\n    'VIP': 'VIP',\n    'Premium': 'Premium',\n    'Bronze': 'Bronce',\n    'Silver': 'Plata',\n    'Gold': 'Oro',\n    # Min√∫sculas\n    'new': 'Nuevo',\n    'regular': 'Regular',\n    'vip': 'VIP',\n    'premium': 'Premium',\n    'bronze': 'Bronce',\n    'silver': 'Plata',\n    'gold': 'Oro'\n}\n\n# Diccionario inverso (espa√±ol -> ingl√©s) para filtros\nCATEGORIAS_INVERSO = {v: k for k, v in CATEGORIAS_TRADUCCION.items()}\n\ndef traducir_categoria(categoria):\n    \"\"\"Traduce una categor√≠a del ingl√©s al espa√±ol\"\"\"\n    if not categoria:\n        return categoria\n    \n    # Buscar traducci√≥n exacta\n    if categoria in CATEGORIAS_TRADUCCION:\n        return CATEGORIAS_TRADUCCION[categoria]\n    \n    # Buscar traducci√≥n case-insensitive\n    categoria_lower = categoria.lower()\n    if categoria_lower in CATEGORIAS_TRADUCCION:\n        return CATEGORIAS_TRADUCCION[categoria_lower]\n    \n    # Si no hay traducci√≥n, capitalizar la primera letra\n    return categoria.capitalize()\n\ndef traducir_categoria_inverso(categoria_es):\n    \"\"\"Traduce una categor√≠a del espa√±ol al ingl√©s (para filtros)\"\"\"\n    if not categoria_es:\n        return categoria_es\n    \n    if categoria_es in CATEGORIAS_INVERSO:\n        return CATEGORIAS_INVERSO[categoria_es]\n    \n    # Si no hay traducci√≥n inversa, devolver como est√°\n    return categoria_es\n\ndef traducir_pais(pais):\n    \"\"\"Traduce un pa√≠s del ingl√©s al espa√±ol\"\"\"\n    if not pais:\n        return pais\n    \n    # Buscar traducci√≥n exacta\n    if pais in PAISES_TRADUCCION:\n        return PAISES_TRADUCCION[pais]\n    \n    # Si no hay traducci√≥n, devolver como est√°\n    return pais\n\ndef traducir_dia_semana(dia):\n    \"\"\"Traduce un d√≠a de la semana del ingl√©s al espa√±ol\"\"\"\n    if not dia:\n        return dia\n    \n    # Buscar traducci√≥n exacta\n    if dia in DIAS_SEMANA_TRADUCCION:\n        return DIAS_SEMANA_TRADUCCION[dia]\n    \n    # Si no hay traducci√≥n, devolver como est√°\n    return dia\n\ndef traducir_mes(mes):\n    \"\"\"Traduce un mes del ingl√©s al espa√±ol\"\"\"\n    if not mes:\n        return mes\n    \n    # Buscar traducci√≥n exacta\n    if mes in MESES_TRADUCCION:\n        return MESES_TRADUCCION[mes]\n    \n    # Si no hay traducci√≥n, devolver como est√°\n    return mes\n\ndef aplicar_traducciones_df(df, columna='category'):\n    \"\"\"Aplica traducciones a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_categoria)\n    return df\n\ndef aplicar_traducciones_paises_df(df, columna='country'):\n    \"\"\"Aplica traducciones de pa√≠ses a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_pais)\n    return df\n\ndef traducir_segmento_rfm(segmento):\n    \"\"\"Traduce un segmento RFM del ingl√©s al espa√±ol\"\"\"\n    if not segmento or pd.isna(segmento):\n        return segmento\n    \n    # Convertir a string y buscar traducci√≥n (case-insensitive)\n    segmento_str = str(segmento).strip()\n    \n    # Buscar traducci√≥n exacta\n    if segmento_str in SEGMENTOS_RFM_TRADUCCION:\n        return SEGMENTOS_RFM_TRADUCCION[segmento_str]\n    \n    # Buscar case-insensitive\n    for key, value in SEGMENTOS_RFM_TRADUCCION.items():\n        if key.lower() == segmento_str.lower():\n            return value\n    \n    # Si no hay traducci√≥n, devolver como est√°\n    return segmento_str\n\ndef traducir_dispositivo(dispositivo):\n    \"\"\"Traduce un tipo de dispositivo del ingl√©s al espa√±ol\"\"\"\n    if not dispositivo or pd.isna(dispositivo):\n        return dispositivo\n    \n    dispositivo_str = str(dispositivo).strip()\n    \n    # Buscar traducci√≥n exacta o case-insensitive\n    if dispositivo_str in DISPOSITIVOS_TRADUCCION:\n        return DISPOSITIVOS_TRADUCCION[dispositivo_str]\n    \n    for key, value in DISPOSITIVOS_TRADUCCION.items():\n        if key.lower() == dispositivo_str.lower():\n            return value\n    \n    return dispositivo_str\n\ndef traducir_metodo_pago(metodo):\n    \"\"\"Traduce un m√©todo de pago del ingl√©s al espa√±ol\"\"\"\n    if not metodo or pd.isna(metodo):\n        return metodo\n    \n    metodo_str = str(metodo).strip()\n    \n    # Buscar traducci√≥n exacta o case-insensitive\n    if metodo_str in METODOS_PAGO_TRADUCCION:\n        return METODOS_PAGO_TRADUCCION[metodo_str]\n    \n    for key, value in METODOS_PAGO_TRADUCCION.items():\n        if key.lower() == metodo_str.lower():\n            return value\n    \n    return metodo_str\n\ndef aplicar_traducciones_rfm_df(df, columna='rfm_segment'):\n    \"\"\"Aplica traducciones de segmentos RFM a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_segmento_rfm)\n    return df\n\ndef aplicar_traducciones_dispositivos_df(df, columna='device_type'):\n    \"\"\"Aplica traducciones de dispositivos a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_dispositivo)\n    return df\n\ndef aplicar_traducciones_metodos_pago_df(df, columna='payment_method'):\n    \"\"\"Aplica traducciones de m√©todos de pago a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_metodo_pago)\n    return df\n\ndef traducir_fuente_trafico(fuente):\n    \"\"\"Traduce una fuente de tr√°fico del ingl√©s al espa√±ol\"\"\"\n    if not fuente or pd.isna(fuente):\n        return fuente\n    \n    fuente_str = str(fuente).strip()\n    \n    # Buscar traducci√≥n exacta o case-insensitive\n    if fuente_str in FUENTES_TRAFICO_TRADUCCION:\n        return FUENTES_TRAFICO_TRADUCCION[fuente_str]\n    \n    for key, value in FUENTES_TRAFICO_TRADUCCION.items():\n        if key.lower() == fuente_str.lower():\n            return value\n    \n    return fuente_str\n\ndef traducir_segmento_cliente(segmento):\n    \"\"\"Traduce un segmento de cliente del ingl√©s al espa√±ol\"\"\"\n    if not segmento or pd.isna(segmento):\n        return segmento\n    \n    segmento_str = str(segmento).strip()\n    \n    # Buscar traducci√≥n exacta o case-insensitive\n    if segmento_str in SEGMENTOS_CLIENTES_TRADUCCION:\n        return SEGMENTOS_CLIENTES_TRADUCCION[segmento_str]\n    \n    for key, value in SEGMENTOS_CLIENTES_TRADUCCION.items():\n        if key.lower() == segmento_str.lower():\n            return value\n    \n    return segmento_str\n\ndef aplicar_traducciones_fuentes_trafico_df(df, columna='traffic_source'):\n    \"\"\"Aplica traducciones de fuentes de tr√°fico a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_fuente_trafico)\n    return df\n\ndef aplicar_traducciones_segmentos_clientes_df(df, columna='customer_segment'):\n    \"\"\"Aplica traducciones de segmentos de clientes a una columna de DataFrame\"\"\"\n    if columna in df.columns:\n        df[columna] = df[columna].apply(traducir_segmento_cliente)\n    return df\n\n# Diccionario de labels profesionales para gr√°ficos\nLABELS_PROFESIONALES = {\n    # Columnas comunes\n    'total_amount_usd': 'Ingresos (USD)',\n    'transaction_id': 'Transacciones',\n    'profit': 'Beneficio (USD)',\n    'quantity': 'Cantidad',\n    'unit_price': 'Precio Unitario (USD)',\n    'customer_id': 'ID Cliente',\n    'product_id': 'ID Producto',\n    'product_name': 'Producto',\n    'category': 'Categor√≠a',\n    'subcategory': 'Subcategor√≠a',\n    'country': 'Pa√≠s',\n    'city': 'Ciudad',\n    'date': 'Fecha',\n    'device_type': 'Dispositivo',\n    'traffic_source': 'Fuente de Tr√°fico',\n    'payment_method': 'M√©todo de Pago',\n    'customer_segment': 'Segmento',\n    \n    # RFM y segmentaci√≥n\n    'recency': 'Recencia (d√≠as)',\n    'frequency': 'Frecuencia (compras)',\n    'monetary': 'Valor Monetario (USD)',\n    'rfm_segment': 'Segmento RFM',\n    'churn_probability': 'Probabilidad de Churn (%)',\n    'lifetime_value': 'Valor de Vida (USD)',\n    'count': 'Cantidad',\n    'value': 'Valor',\n    \n    # An√°lisis especiales\n    'margen_%': 'Margen (%)',\n    'churn_risk': 'Riesgo de Churn (%)',\n    'ltv': 'Valor de Vida (USD)',\n    'aov': 'Ticket Promedio (USD)',\n    'es_anomalia': 'Anomal√≠a',\n    \n    # Temporal\n    'dia_semana': 'D√≠a de la Semana',\n    'hora': 'Hora del D√≠a',\n    'mes': 'Mes',\n    'a√±o': 'A√±o',\n    'periodo': 'Per√≠odo',\n    'Fecha': 'Fecha',\n    'Ingresos': 'Ingresos (USD)',\n    'Pedidos': 'Pedidos',\n    'Beneficio': 'Beneficio (USD)',\n    \n    # Agregaciones\n    'ingresos': 'Ingresos (USD)',\n    'pedidos': 'Pedidos',\n    'beneficio': 'Beneficio (USD)',\n    'cantidad': 'Cantidad',\n    'clientes': 'Clientes',\n    'productos': 'Productos',\n    'producto': 'Producto',\n    'transacciones': 'Transacciones',\n    'metodo': 'M√©todo de Pago',\n    'segmento': 'Segmento',\n    'nivel_riesgo': 'Nivel de Riesgo',\n    'cluster': 'Cluster',\n    'cuadrante': 'Cuadrante BCG',\n    'velocidad': 'Velocidad de Rotaci√≥n',\n    'frecuencia': 'Frecuencia'\n}\n\ndef obtener_labels_profesionales():\n    \"\"\"Retorna diccionario de labels profesionales para gr√°ficos\"\"\"\n    return LABELS_PROFESIONALES.copy()\n","size_bytes":17299},"DEPLOY_STREAMLIT.md":{"content":"# üöÄ Gu√≠a de Deploy en Streamlit Cloud\n\n## Pasos para Publicar tu Dashboard\n\n### 1. Preparar el Repositorio Git\n\n```bash\n# Inicializar repositorio (si no existe)\ngit init\n\n# Agregar todos los archivos\ngit add .\n\n# Hacer commit\ngit commit -m \"Dashboard Analytics Ecommerce Global v3.1 listo para deploy\"\n\n# Crear repositorio en GitHub y conectar\ngit remote add origin https://github.com/TU_USUARIO/TU_REPOSITORIO.git\ngit branch -M main\ngit push -u origin main\n```\n\n### 2. Deploy en Streamlit Cloud\n\n1. **Ir a Streamlit Cloud**\n   - Visita: https://share.streamlit.io\n   - Inicia sesi√≥n con tu cuenta de GitHub\n\n2. **Crear Nueva App**\n   - Click en \"New app\"\n   - Selecciona tu repositorio de GitHub\n   - Branch: `main`\n   - Main file path: `app.py`\n   - App URL: Elige un nombre √∫nico\n\n3. **Configurar (Opcional)**\n   - Python version: 3.11\n   - No requiere secrets para la versi√≥n con Parquet\n\n4. **Deploy**\n   - Click en \"Deploy\"\n   - Espera 2-5 minutos mientras se instalan dependencias\n   - ¬°Tu dashboard estar√° en l√≠nea!\n\n### 3. URL Final\n\nTu dashboard estar√° disponible en:\n```\nhttps://TU_NOMBRE_APP.streamlit.app\n```\n\n---\n\n## üì¶ Archivos Necesarios (Ya Incluidos)\n\n‚úÖ `app.py` - Dashboard principal  \n‚úÖ `requirements.txt` - Dependencias  \n‚úÖ `.gitignore` - Archivos a ignorar  \n‚úÖ `data/*.parquet` - Datasets (17MB total)  \n‚úÖ `utils/` - Utilidades  \n‚úÖ `api/` - API (opcional)  \n‚úÖ `.streamlit/config.toml` - Configuraci√≥n\n\n---\n\n## ‚öôÔ∏è Configuraci√≥n Avanzada (Opcional)\n\n### Si usas PostgreSQL:\n\n1. En Streamlit Cloud, ve a \"Settings\" ‚Üí \"Secrets\"\n2. Agrega:\n\n```toml\n[postgresql]\nDATABASE_URL = \"postgresql://usuario:password@host:5432/database\"\n```\n\n3. Modifica `app.py` para usar `st.secrets` en producci√≥n\n\n---\n\n## üîç Troubleshooting\n\n### Error: \"Module not found\"\n- Verifica que todas las dependencias est√°n en `requirements.txt`\n- Revisa los logs en Streamlit Cloud\n\n### Error: \"Memory limit exceeded\"\n- Los archivos Parquet (17MB) est√°n optimizados\n- Streamlit Cloud tiene 1GB de RAM (suficiente)\n\n### Error: \"File not found\"\n- Verifica que `data/*.parquet` est√°n en el repositorio\n- No uses rutas absolutas, solo relativas\n\n### Dashboard carga lento\n- Normal en primera carga (instala dependencias)\n- Cargas subsecuentes son r√°pidas (<3 segundos)\n\n---\n\n## üìä Monitoreo\n\nEn Streamlit Cloud puedes:\n- Ver logs en tiempo real\n- Monitorear uso de recursos\n- Ver analytics de visitantes\n- Configurar dominios personalizados (plan paid)\n\n---\n\n## üéØ Pr√≥ximos Pasos\n\n1. Comparte tu URL con clientes/stakeholders\n2. Monitorea analytics y feedback\n3. Actualiza con `git push` (auto-deploy)\n4. Considera upgrade a plan paid para:\n   - M√°s recursos\n   - Dominio personalizado\n   - Sin l√≠mite de visitantes\n\n---\n\n## ‚ú® Tu Dashboard Est√° Listo\n\n**Caracter√≠sticas en Producci√≥n:**\n- ‚úÖ 472K transacciones analizadas\n- ‚úÖ 9 pesta√±as profesionales\n- ‚úÖ ML integrado (Prophet, K-Means)\n- ‚úÖ Visualizaciones optimizadas\n- ‚úÖ 100% en espa√±ol\n- ‚úÖ Firma CMSR92\n- ‚úÖ Listo para cliente/directivos\n\n**‚ú® Desarrollado por CMSR92 ‚ú®**\n","size_bytes":3080},"LIMPIEZA_COMPLETADA.md":{"content":"# ‚úÖ Limpieza Completada - Proyecto Listo para Producci√≥n\n\n## üóëÔ∏è Archivos Eliminados\n\n### Screenshots Temporales\n- ‚ùå attached_assets/ - 28 archivos PNG de screenshots\n\n### Archivos de Desarrollo\n- ‚ùå utils/data_generator.py - Generaci√≥n de datos sint√©ticos\n- ‚ùå utils/unified_data_integration.py - Integraci√≥n inicial de datos\n- ‚ùå database/migration_unified.py - Migraci√≥n inicial BD\n\n### Cache y Temporales\n- ‚ùå __pycache__/ - Cache de Python\n- ‚ùå *.pyc - Archivos compilados\n- ‚ùå /tmp/logs/ - Logs temporales\n\n## üì¶ Archivos Finales (Listos para GitHub)\n\n### Core\n‚úÖ app.py (84KB) - Dashboard principal\n‚úÖ requirements.txt - Dependencias\n‚úÖ .gitignore - Configuraci√≥n Git\n\n### Data\n‚úÖ data/transactions_unified.parquet (17MB)\n‚úÖ data/customers_unified.parquet\n‚úÖ data/products_unified.parquet\n\n### Utilities\n‚úÖ utils/data_loader_pg.py - Carga de datos\n‚úÖ utils/export_utils.py - Exportaci√≥n de reportes\n‚úÖ utils/filtros.py - Filtros del dashboard\n‚úÖ utils/traducciones.py - Internacionalizaci√≥n\n‚úÖ utils/ui_components.py - Componentes UI\n‚úÖ utils/visualizaciones_avanzadas.py - Visualizaciones\n\n### Documentaci√≥n\n‚úÖ README.md - Documentaci√≥n principal\n‚úÖ DEPLOY_STREAMLIT.md - Gu√≠a de deploy\n‚úÖ replit.md - Historial t√©cnico\n\n### Opcionales\n‚úÖ api/ - API FastAPI (opcional para Streamlit Cloud)\n‚úÖ database/ - Esquema PostgreSQL (opcional, usa Parquet)\n\n## üìä Tama√±o del Proyecto\n\nTotal √∫til: ~18MB (perfecto para GitHub/Streamlit Cloud)\n\n## ‚ú® Estado Final\n\n‚úÖ Dashboard corriendo sin errores\n‚úÖ Archivos temporales eliminados\n‚úÖ Cache limpiado\n‚úÖ .gitignore configurado\n‚úÖ Proyecto optimizado\n‚úÖ Listo para Streamlit Cloud\n\n‚ú® Desarrollado por CMSR92 ‚ú®\n","size_bytes":1717},"attached_assets/app_1761511711268.py":{"content":"\"\"\"\nDashboard Avanzado de Analytics Ecommerce Global\nAutor: cmsr92\nVersi√≥n: 2.0\nPlataforma profesional de Business Intelligence con ML, IA y An√°lisis Predictivo\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport folium\nfrom streamlit_folium import st_folium\nfrom datetime import datetime, timedelta\nimport warnings\nwarnings.filterwarnings('ignore')\n\nst.set_page_config(\n    page_title=\"Analytics Ecommerce Global | cmsr92\",\n    page_icon=\"üìä\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\nfrom utils.ui_components import (\n    aplicar_estilos_globales, crear_header_principal, crear_tarjeta_kpi,\n    crear_seccion_titulo, crear_pie_pagina, mostrar_info_dataset,\n    crear_descripcion_seccion, crear_insight, crear_recomendaciones\n)\nfrom utils.filtros import crear_filtros_sidebar, aplicar_filtros\nfrom utils.data_loader_pg import load_or_generate_data\nfrom utils.traducciones import obtener_labels_profesionales\n\n# Labels profesionales para gr√°ficos\nLABELS = obtener_labels_profesionales()\n\n# Aplicar estilos globales con detecci√≥n autom√°tica de tema del navegador\naplicar_estilos_globales()\n\n@st.cache_data(ttl=60)\ndef cargar_datos():\n    return load_or_generate_data()\n\ntransacciones_df, clientes_df, productos_df = cargar_datos()\n\nif transacciones_df is None or clientes_df is None or productos_df is None:\n    st.error(\"‚ùå Error al cargar los datos. Por favor recarga la p√°gina.\")\n    st.stop()\n\ncrear_header_principal(\n    \"üìä Analytics Ecommerce Global\",\n    \"Plataforma Avanzada de Business Intelligence, Machine Learning y An√°lisis Predictivo\"\n)\n\nfiltros = crear_filtros_sidebar(transacciones_df)\ndatos_filtrados = aplicar_filtros(transacciones_df, filtros)\n\nif len(datos_filtrados) == 0:\n    st.warning(\"‚ö†Ô∏è No hay datos que coincidan con los filtros seleccionados. Ajusta los criterios de b√∫squeda.\")\n    st.stop()\n\ntab_overview, tab_geografia, tab_forecasting, tab_productos, tab_clientes, tab_canal, tab_ml, tab_finanzas, tab_operacional = st.tabs([\n    \"üè† Resumen General\",\n    \"üåç An√°lisis Geogr√°fico\",\n    \"üìà Forecasting & Tendencias\",\n    \"üì¶ An√°lisis de Productos\",\n    \"üë• Segmentaci√≥n de Clientes\",\n    \"üì± An√°lisis de Canal\",\n    \"ü§ñ ML & IA Insights\",\n    \"üí∞ An√°lisis Financiero\",\n    \"‚öôÔ∏è M√©tricas Operacionales\"\n])\n\nwith tab_overview:\n    crear_descripcion_seccion(\n        \"Resumen Ejecutivo\",\n        \"Esta secci√≥n presenta una visi√≥n general del rendimiento del negocio. Los KPIs principales muestran la salud financiera, \"\n        \"el volumen de operaciones y la eficiencia comercial. Utiliza los filtros del sidebar para analizar per√≠odos espec√≠ficos, \"\n        \"regiones geogr√°ficas o segmentos de clientes.\"\n    )\n    \n    crear_seccion_titulo(\"Indicadores Clave de Rendimiento (KPIs)\")\n    \n    # Explicaci√≥n de KPIs\n    with st.expander(\"‚ÑπÔ∏è ¬øQu√© significan estos indicadores?\", expanded=False):\n        st.markdown(\"\"\"\n        **üí∞ Ingresos Totales:** Suma de todas las ventas en el per√≠odo seleccionado. El s√≠mbolo % muestra el cambio respecto al per√≠odo anterior equivalente.\n        \n        **üõí Pedidos Totales:** N√∫mero total de transacciones completadas. Un aumento indica mayor actividad comercial.\n        \n        **üéØ Ticket Promedio (AOV):** Valor promedio por pedido. Se calcula dividiendo ingresos totales entre n√∫mero de pedidos. Un AOV alto indica clientes que compran m√°s por transacci√≥n.\n        \n        **üíé Beneficio Total:** Ganancia neta despu√©s de costos. Se calcula como: Ingresos - Costos. Indica la rentabilidad real del negocio.\n        \n        **üë• Clientes √önicos:** N√∫mero de clientes diferentes que realizaron al menos una compra.\n        \n        **üì¶ Productos Vendidos:** Cantidad de productos distintos que se vendieron en el per√≠odo.\n        \n        **üéØ Tasa de Conversi√≥n:** Porcentaje de clientes √∫nicos respecto al total de pedidos. Una tasa cercana a 100% indica que cada pedido corresponde a un cliente diferente (baja repetici√≥n).\n        \n        **üìä Items por Pedido:** Promedio de art√≠culos incluidos en cada transacci√≥n. √ötil para estrategias de bundling y cross-selling.\n        \"\"\")\n    \n    ingresos_totales = datos_filtrados['total_amount_usd'].sum()\n    pedidos_totales = len(datos_filtrados)\n    ticket_promedio = datos_filtrados['total_amount_usd'].mean()\n    beneficio_total = datos_filtrados['profit'].sum()\n    clientes_unicos = datos_filtrados['customer_id'].nunique()\n    margen_promedio = (beneficio_total / ingresos_totales * 100) if ingresos_totales > 0 else 0\n    \n    fecha_inicio_comparacion = filtros['fecha_inicio'] - (filtros['fecha_fin'] - filtros['fecha_inicio'])\n    datos_periodo_anterior = transacciones_df[\n        (transacciones_df['date'] >= pd.Timestamp(fecha_inicio_comparacion)) & \n        (transacciones_df['date'] < pd.Timestamp(filtros['fecha_inicio']))\n    ]\n    \n    ingresos_anteriores = datos_periodo_anterior['total_amount_usd'].sum()\n    cambio_ingresos = ((ingresos_totales - ingresos_anteriores) / ingresos_anteriores * 100) if ingresos_anteriores > 0 else 0\n    \n    pedidos_anteriores = len(datos_periodo_anterior)\n    cambio_pedidos = ((pedidos_totales - pedidos_anteriores) / pedidos_anteriores * 100) if pedidos_anteriores > 0 else 0\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\n            label=\"üí∞ Ingresos Totales\",\n            value=f\"${ingresos_totales:,.0f}\",\n            delta=f\"{cambio_ingresos:+.1f}%\" if ingresos_anteriores > 0 else None\n        )\n    \n    with col2:\n        st.metric(\n            label=\"üõí Pedidos Totales\",\n            value=f\"{pedidos_totales:,}\",\n            delta=f\"{cambio_pedidos:+.1f}%\" if pedidos_anteriores > 0 else None\n        )\n    \n    with col3:\n        st.metric(\n            label=\"üéØ Ticket Promedio (AOV)\",\n            value=f\"${ticket_promedio:,.0f}\"\n        )\n    \n    with col4:\n        st.metric(\n            label=\"üíé Beneficio Total\",\n            value=f\"${beneficio_total:,.0f}\"\n        )\n    \n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    \n    col5, col6, col7, col8 = st.columns(4)\n    \n    with col5:\n        st.metric(\n            label=\"üë• Clientes √önicos\",\n            value=f\"{clientes_unicos:,}\"\n        )\n    \n    with col6:\n        productos_unicos = datos_filtrados['product_id'].nunique()\n        st.metric(\n            label=\"üì¶ Productos Vendidos\",\n            value=f\"{productos_unicos:,}\"\n        )\n    \n    with col7:\n        tasa_conversion = (clientes_unicos / pedidos_totales * 100) if pedidos_totales > 0 else 0\n        st.metric(\n            label=\"üéØ Tasa de Conversi√≥n\",\n            value=f\"{tasa_conversion:.1f}%\"\n        )\n    \n    with col8:\n        items_promedio = datos_filtrados['quantity'].mean()\n        st.metric(\n            label=\"üìä Items por Pedido\",\n            value=f\"{items_promedio:.1f}\"\n        )\n    \n    # Secci√≥n de Insights Ejecutivos Autom√°ticos\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n    crear_seccion_titulo(\"üí° Insights Ejecutivos y Recomendaciones\")\n    \n    # Calcular m√©tricas adicionales para insights (con protecci√≥n contra divisi√≥n por cero)\n    if ingresos_totales > 0:\n        top_pais = datos_filtrados.groupby('country')['total_amount_usd'].sum().idxmax()\n        ingresos_top_pais = datos_filtrados.groupby('country')['total_amount_usd'].sum().max()\n        porcentaje_top_pais = (ingresos_top_pais / ingresos_totales * 100)\n        \n        top_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().idxmax()\n        ingresos_top_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().max()\n        porcentaje_top_categoria = (ingresos_top_categoria / ingresos_totales * 100)\n    else:\n        top_pais = \"N/A\"\n        ingresos_top_pais = 0\n        porcentaje_top_pais = 0\n        top_categoria = \"N/A\"\n        ingresos_top_categoria = 0\n        porcentaje_top_categoria = 0\n    \n    # Generar insights autom√°ticos\n    insights_ejecutivos = []\n    \n    # Verificar si hay datos suficientes para generar insights\n    if ingresos_totales == 0 or pedidos_totales == 0:\n        insights_ejecutivos.append(\n            f\"‚ÑπÔ∏è **Sin Datos Disponibles:** No hay transacciones registradas en el per√≠odo y filtros seleccionados. \"\n            f\"Ajusta los criterios de b√∫squeda en el sidebar para analizar diferentes per√≠odos o segmentos.\"\n        )\n    else:\n        # Insight 1: Rendimiento general\n        if cambio_ingresos > 10:\n            insights_ejecutivos.append(\n                f\"üìà **Crecimiento Acelerado:** Los ingresos han crecido un {cambio_ingresos:.1f}% comparado con el per√≠odo anterior, \"\n                f\"superando ${ingresos_totales:,.0f}. Este momentum positivo indica una fuerte demanda y efectividad en las estrategias comerciales.\"\n            )\n        elif cambio_ingresos < -10:\n            insights_ejecutivos.append(\n                f\"‚ö†Ô∏è **Alerta de Desaceleraci√≥n:** Los ingresos han disminuido un {abs(cambio_ingresos):.1f}% comparado con el per√≠odo anterior. \"\n                f\"Se recomienda revisar estrategias de marketing, competencia y satisfacci√≥n del cliente.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"üìä **Estabilidad Controlada:** Los ingresos se mantienen estables con una variaci√≥n de {cambio_ingresos:+.1f}% respecto al per√≠odo anterior, \"\n                f\"totalizando ${ingresos_totales:,.0f}. Existen oportunidades de optimizaci√≥n para impulsar el crecimiento.\"\n            )\n        \n        # Insight 2: Concentraci√≥n geogr√°fica\n        if porcentaje_top_pais > 50:\n            insights_ejecutivos.append(\n                f\"üåç **Concentraci√≥n de Mercado:** {top_pais} representa el {porcentaje_top_pais:.1f}% de los ingresos totales \"\n                f\"(${ingresos_top_pais:,.0f}). Esta alta dependencia presenta riesgo. Se recomienda diversificar geogr√°ficamente.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"üåç **Diversificaci√≥n Saludable:** {top_pais} lidera con {porcentaje_top_pais:.1f}% de ingresos, pero existe buena \"\n                f\"distribuci√≥n geogr√°fica, reduciendo el riesgo de dependencia de un solo mercado.\"\n            )\n        \n        # Insight 3: Producto estrella\n        insights_ejecutivos.append(\n            f\"‚≠ê **Categor√≠a L√≠der:** {top_categoria} domina el portafolio con {porcentaje_top_categoria:.1f}% de los ingresos \"\n            f\"(${ingresos_top_categoria:,.0f}). Reforzar inventario y marketing en esta categor√≠a puede maximizar resultados.\"\n        )\n        \n        # Insight 4: Eficiencia operativa\n        if ticket_promedio > 100:\n            insights_ejecutivos.append(\n                f\"üíé **Alto Valor por Transacci√≥n:** El ticket promedio de ${ticket_promedio:,.0f} indica clientes de alto valor. \"\n                f\"Enfocar estrategias de retenci√≥n y programas VIP puede aumentar la rentabilidad.\"\n            )\n        else:\n            insights_ejecutivos.append(\n                f\"üéØ **Oportunidad de Upselling:** Con un ticket promedio de ${ticket_promedio:,.0f}, existe potencial para incrementar \"\n                f\"el valor por pedido mediante bundling, recomendaciones personalizadas y ofertas complementarias.\"\n            )\n    \n    # Mostrar insights\n    for insight in insights_ejecutivos:\n        crear_insight(\"\", insight)\n    \n    # Recomendaciones accionables\n    recomendaciones_ejecutivas = [\n        f\"üîç **An√°lisis Geogr√°fico:** Explorar la pesta√±a 'An√°lisis Geogr√°fico' para identificar mercados emergentes con alto potencial de crecimiento\",\n        f\"üìä **Forecasting:** Revisar las predicciones en 'Forecasting & Tendencias' para planificar inventario y presupuestos de los pr√≥ximos 90 d√≠as\",\n        f\"üë• **Segmentaci√≥n:** Analizar 'Segmentaci√≥n de Clientes' para identificar clientes Champions y en riesgo de churn, personalizando estrategias\",\n        f\"ü§ñ **ML Insights:** Activar an√°lisis ML en el sidebar para detectar anomal√≠as, patrones ocultos y oportunidades de optimizaci√≥n autom√°tica\",\n        f\"üí∞ **An√°lisis Financiero:** Verificar m√°rgenes y rentabilidad en 'An√°lisis Financiero' para asegurar la salud del negocio\"\n    ]\n    \n    crear_recomendaciones(\"üéØ Acciones Recomendadas\", recomendaciones_ejecutivas)\n    \n    crear_seccion_titulo(\"Evoluci√≥n Temporal\")\n    \n    datos_temporales = datos_filtrados.copy()\n    datos_temporales['fecha'] = pd.to_datetime(datos_temporales['date'])\n    datos_temporales_agrupados = datos_temporales.groupby(datos_temporales['fecha'].dt.to_period('M')).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count',\n        'profit': 'sum'\n    }).reset_index()\n    datos_temporales_agrupados['fecha'] = datos_temporales_agrupados['fecha'].dt.to_timestamp()\n    datos_temporales_agrupados.columns = ['Fecha', 'Ingresos', 'Pedidos', 'Beneficio']\n    \n    # Crear figura con eje secundario\n    fig_evolucion = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    # Agregar l√≠neas de ingresos y beneficio en eje principal\n    fig_evolucion.add_trace(\n        go.Scatter(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Ingresos'],\n            name='Ingresos',\n            line=dict(color='#667eea', width=3),\n            mode='lines'\n        ),\n        secondary_y=False\n    )\n    \n    fig_evolucion.add_trace(\n        go.Scatter(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Beneficio'],\n            name='Beneficio',\n            line=dict(color='#10B981', width=2),\n            mode='lines'\n        ),\n        secondary_y=False\n    )\n    \n    # Agregar barras de pedidos en eje secundario\n    fig_evolucion.add_trace(\n        go.Bar(\n            x=datos_temporales_agrupados['Fecha'],\n            y=datos_temporales_agrupados['Pedidos'],\n            name='Pedidos',\n            marker_color='rgba(245, 158, 11, 0.3)',\n            marker_line_color='#F59E0B',\n            marker_line_width=1\n        ),\n        secondary_y=True\n    )\n    \n    # Configurar ejes\n    fig_evolucion.update_yaxes(title_text=\"Ingresos / Beneficio ($)\", secondary_y=False)\n    fig_evolucion.update_yaxes(title_text=\"Pedidos\", secondary_y=True)\n    fig_evolucion.update_xaxes(title_text=\"Fecha\")\n    \n    fig_evolucion.update_layout(\n        title='Evoluci√≥n Mensual de Ingresos, Beneficio y Pedidos',\n        height=500,\n        showlegend=True,\n        hovermode='x unified',\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font=dict(family='Inter', size=12),\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=1.02,\n            xanchor=\"right\",\n            x=1\n        )\n    )\n    \n    fig_evolucion.update_xaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    fig_evolucion.update_yaxes(showgrid=True, gridcolor='rgba(0,0,0,0.05)')\n    \n    st.plotly_chart(fig_evolucion, use_container_width=True)\n    \n    crear_seccion_titulo(\"Distribuciones Clave\")\n    \n    col_dist1, col_dist2 = st.columns(2)\n    \n    with col_dist1:\n        top_paises = datos_filtrados.groupby('country')['total_amount_usd'].sum().nlargest(10).reset_index()\n        fig_paises = px.bar(\n            top_paises,\n            x='total_amount_usd',\n            y='country',\n            orientation='h',\n            title='Top 10 Pa√≠ses por Ingresos',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_paises.update_layout(\n            showlegend=False,\n            height=400,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)'\n        )\n        fig_paises.update_traces(hovertemplate='<b>%{y}</b><br>Ingresos: $%{x:,.0f}<extra></extra>')\n        st.plotly_chart(fig_paises, use_container_width=True)\n    \n    with col_dist2:\n        por_categoria = datos_filtrados.groupby('category')['total_amount_usd'].sum().reset_index()\n        fig_categorias = px.pie(\n            por_categoria,\n            values='total_amount_usd',\n            names='category',\n            title='Distribuci√≥n de Ingresos por Categor√≠a',\n            color_discrete_sequence=px.colors.qualitative.Set3,\n            hole=0.4\n        )\n        fig_categorias.update_layout(\n            height=400,\n            plot_bgcolor='rgba(0,0,0,0)',\n            paper_bgcolor='rgba(0,0,0,0)'\n        )\n        fig_categorias.update_traces(\n            textposition='inside', \n            textinfo='percent+label',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<br>Porcentaje: %{percent}<extra></extra>'\n        )\n        st.plotly_chart(fig_categorias, use_container_width=True)\n\nwith tab_geografia:\n    crear_descripcion_seccion(\n        \"An√°lisis de Distribuci√≥n Geogr√°fica\",\n        \"Visualiza c√≥mo se distribuyen tus ventas alrededor del mundo. Identifica los mercados m√°s rentables, \"\n        \"pa√≠ses con mayor potencial de crecimiento y oportunidades de expansi√≥n internacional. El mapa de calor \"\n        \"muestra la intensidad de ventas por pa√≠s.\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis Geogr√°fico Global\")\n    \n    col1, col2 = st.columns([7, 3])\n    \n    with col1:\n        st.subheader(\"Mapa Mundial de Ventas\")\n        \n        # Mapeo de nombres de pa√≠ses (en espa√±ol) a c√≥digos ISO 3\n        country_iso_map = {\n            'Reino Unido': 'GBR', 'Estados Unidos': 'USA', 'Alemania': 'DEU', \n            'Francia': 'FRA', 'China': 'CHN', 'Canad√°': 'CAN', 'Jap√≥n': 'JPN',\n            'Australia': 'AUS', 'Espa√±a': 'ESP', 'Italia': 'ITA', 'Pa√≠ses Bajos': 'NLD',\n            'B√©lgica': 'BEL', 'Suiza': 'CHE', 'Suecia': 'SWE', 'Austria': 'AUT',\n            'Noruega': 'NOR', 'Dinamarca': 'DNK', 'Finlandia': 'FIN', 'Polonia': 'POL',\n            'Portugal': 'PRT', 'Grecia': 'GRC', 'Rep√∫blica Checa': 'CZE',\n            'Irlanda': 'IRL', 'Singapur': 'SGP', 'Corea del Sur': 'KOR',\n            'India': 'IND', 'Brasil': 'BRA', 'M√©xico': 'MEX', 'Israel': 'ISR',\n            'Arabia Saudita': 'SAU', 'Emiratos √Årabes Unidos': 'ARE', 'Sud√°frica': 'ZAF',\n            'Chipre': 'CYP', 'Malta': 'MLT', 'Islandia': 'ISL', 'Lituania': 'LTU',\n            'Bar√©in': 'BHR', 'L√≠bano': 'LBN', 'Comunidad Europea': None\n        }\n        \n        datos_pais = datos_filtrados.groupby('country').agg({\n            'total_amount_usd': 'sum',\n            'transaction_id': 'count',\n            'customer_id': 'nunique'\n        }).reset_index()\n        datos_pais.columns = ['country', 'ingresos', 'pedidos', 'clientes']\n        datos_pais['aov'] = datos_pais['ingresos'] / datos_pais['pedidos']\n        \n        # Agregar c√≥digos ISO\n        datos_pais['iso_code'] = datos_pais['country'].map(country_iso_map)\n        # Filtrar pa√≠ses sin c√≥digo ISO v√°lido\n        datos_pais_validos = datos_pais[datos_pais['iso_code'].notna()].copy()\n        \n        fig_mapa = px.choropleth(\n            datos_pais_validos,\n            locations='iso_code',\n            locationmode='ISO-3',\n            color='ingresos',\n            hover_name='country',\n            hover_data={\n                'iso_code': False,\n                'ingresos': ':$,.0f',\n                'pedidos': ':,',\n                'clientes': ':,',\n                'aov': ':$,.2f'\n            },\n            color_continuous_scale='Viridis',\n            title='Ingresos por Pa√≠s',\n            labels={'ingresos': 'Ingresos', 'pedidos': 'Pedidos', 'clientes': 'Clientes', 'aov': 'Ticket Promedio'}\n        )\n        fig_mapa.update_layout(\n            height=500, \n            margin=dict(l=0, r=0, t=30, b=0),\n            geo=dict(showframe=False, showcoastlines=True, projection_type='natural earth')\n        )\n        st.plotly_chart(fig_mapa, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Top 15 Pa√≠ses\")\n        top_paises = datos_pais.nlargest(15, 'ingresos')\n        \n        fig_top = px.bar(\n            top_paises,\n            y='country',\n            x='ingresos',\n            orientation='h',\n            color='ingresos',\n            color_continuous_scale='Blues',\n            title='Ingresos por Pa√≠s (Top 15)',\n            labels=LABELS\n        )\n        fig_top.update_traces(hovertemplate='<b>%{y}</b><br>Ingresos: $%{x:,.0f}<extra></extra>')\n        fig_top.update_layout(\n            height=500,\n            showlegend=False,\n            yaxis={'categoryorder': 'total ascending'}\n        )\n        st.plotly_chart(fig_top, use_container_width=True)\n    \n    col3, col4 = st.columns(2)\n    \n    with col3:\n        st.subheader(\"Jerarqu√≠a Geogr√°fica (Treemap)\")\n        \n        datos_tree_geo = datos_filtrados.groupby(['country', 'category']).agg({\n            'total_amount_usd': 'sum'\n        }).reset_index()\n        datos_tree_geo.rename(columns={'total_amount_usd': 'ingresos'}, inplace=True)\n        \n        fig_tree = px.treemap(\n            datos_tree_geo,\n            path=['country', 'category'],\n            values='ingresos',\n            color='ingresos',\n            color_continuous_scale='RdYlGn',\n            title='Jerarqu√≠a: Pa√≠s ‚Üí Categor√≠a'\n        )\n        \n        fig_tree.update_traces(\n            textinfo='label+value',\n            texttemplate='<b>%{label}</b><br>$%{value:,.0f}',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<extra></extra>'\n        )\n        \n        fig_tree.update_layout(height=400)\n        st.plotly_chart(fig_tree, use_container_width=True)\n    \n    with col4:\n        st.subheader(\"Concentraci√≥n de Ventas\")\n        top10_paises = datos_pais.nlargest(10, 'ingresos')\n        otros_ingresos = datos_pais[~datos_pais['country'].isin(top10_paises['country'])]['ingresos'].sum()\n        \n        if otros_ingresos > 0:\n            otros_df = pd.DataFrame({'country': ['Otros'], 'ingresos': [otros_ingresos]})\n            datos_pie = pd.concat([top10_paises[['country', 'ingresos']], otros_df])\n        else:\n            datos_pie = top10_paises[['country', 'ingresos']]\n        \n        fig_pie = px.pie(\n            datos_pie,\n            values='ingresos',\n            names='country',\n            title='Distribuci√≥n de Ingresos (Top 10 + Otros)',\n            hole=0.4\n        )\n        fig_pie.update_traces(hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<br>Porcentaje: %{percent}<extra></extra>')\n        fig_pie.update_layout(height=400)\n        st.plotly_chart(fig_pie, use_container_width=True)\n\nwith tab_forecasting:\n    crear_descripcion_seccion(\n        \"Predicci√≥n de Ventas Futuras con Machine Learning\",\n        \"Utiliza el modelo Prophet de Meta (Facebook) para predecir tus ventas de los pr√≥ximos 90 d√≠as. \"\n        \"Las bandas de confianza muestran el rango probable de variaci√≥n. Esta informaci√≥n te ayuda a planificar \"\n        \"inventario, presupuestos y recursos operativos con anticipaci√≥n.\"\n    )\n    \n    crear_seccion_titulo(\"Forecasting y An√°lisis de Tendencias\")\n    \n    st.subheader(\"Ingresos y Pedidos a lo Largo del Tiempo\")\n    \n    granularidad = st.selectbox(\n        \"Granularidad Temporal\",\n        ['D√≠a', 'Semana', 'Mes'],\n        index=1,\n        help=\"Selecciona el nivel de agregaci√≥n temporal para el an√°lisis\"\n    )\n    \n    temp_df = datos_filtrados.copy()\n    if granularidad == 'D√≠a':\n        temp_df['periodo'] = temp_df['date'].dt.date\n    elif granularidad == 'Semana':\n        temp_df['periodo'] = temp_df['date'].dt.to_period('W').dt.start_time\n    else:\n        temp_df['periodo'] = temp_df['date'].dt.to_period('M').dt.start_time\n    \n    serie_temporal = temp_df.groupby('periodo').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    serie_temporal.columns = ['periodo', 'ingresos', 'pedidos']\n    \n    fig_tiempo = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    fig_tiempo.add_trace(\n        go.Bar(x=serie_temporal['periodo'], y=serie_temporal['ingresos'], name='Ingresos', marker_color='#667eea'),\n        secondary_y=False\n    )\n    \n    fig_tiempo.add_trace(\n        go.Scatter(x=serie_temporal['periodo'], y=serie_temporal['pedidos'], name='Pedidos', \n                   line=dict(color='#f093fb', width=3), mode='lines+markers'),\n        secondary_y=True\n    )\n    \n    fig_tiempo.update_xaxes(title_text=\"Fecha\")\n    fig_tiempo.update_yaxes(title_text=\"Ingresos ($)\", secondary_y=False)\n    fig_tiempo.update_yaxes(title_text=\"Pedidos\", secondary_y=True)\n    fig_tiempo.update_layout(height=400, title='Evoluci√≥n de Ingresos y Pedidos')\n    \n    st.plotly_chart(fig_tiempo, use_container_width=True)\n    \n    if filtros.get('mostrar_ml') and len(serie_temporal) > 10:\n        st.subheader(\"üîÆ Forecasting 90 D√≠as (Prophet)\")\n        \n        st.info(\n            \"üìä **¬øQu√© proyecta este modelo?** Este gr√°fico muestra la predicci√≥n de **INGRESOS TOTALES** de tu negocio \"\n            f\"para los pr√≥ximos 90 d√≠as, agregados por **{granularidad.lower()}**. \"\n            \"La l√≠nea verde es la predicci√≥n basada en patrones hist√≥ricos, y la banda sombreada muestra el rango de confianza del 95%. \"\n            \"El modelo detecta autom√°ticamente tendencias, estacionalidad semanal, mensual y anual en tus ventas.\"\n        )\n        \n        try:\n            from prophet import Prophet\n            \n            prophet_df = serie_temporal[['periodo', 'ingresos']].copy()\n            prophet_df.columns = ['ds', 'y']\n            # Asegurar conversi√≥n correcta a datetime\n            prophet_df['ds'] = pd.to_datetime(prophet_df['ds'].astype(str))\n            \n            with st.spinner('Entrenando modelo Prophet...'):\n                modelo = Prophet(\n                    daily_seasonality=False,\n                    weekly_seasonality=True,\n                    yearly_seasonality=True,\n                    seasonality_mode='multiplicative',\n                    changepoint_prior_scale=0.05,\n                    seasonality_prior_scale=10,\n                    interval_width=0.95\n                )\n                # Agregar estacionalidad mensual\n                modelo.add_seasonality(name='monthly', period=30.5, fourier_order=5)\n                modelo.fit(prophet_df, algorithm='LBFGS')\n                \n                futuro = modelo.make_future_dataframe(periods=90)\n                forecast = modelo.predict(futuro)\n            \n            col1, col2 = st.columns([7, 3])\n            \n            with col1:\n                fig_forecast = go.Figure()\n                \n                # Separar datos hist√≥ricos y proyecci√≥n\n                ultima_fecha_historica = prophet_df['ds'].max()\n                forecast_futuro = forecast[forecast['ds'] > ultima_fecha_historica]\n                forecast_historico = forecast[forecast['ds'] <= ultima_fecha_historica]\n                \n                # Datos hist√≥ricos (puntos azules)\n                fig_forecast.add_trace(go.Scatter(\n                    x=prophet_df['ds'],\n                    y=prophet_df['y'],\n                    mode='markers',\n                    name='Datos Hist√≥ricos',\n                    marker=dict(color='#667eea', size=8, opacity=0.6),\n                    hovertemplate='<b>Hist√≥rico</b><br>Fecha: %{x}<br>Ingresos: $%{y:,.0f}<extra></extra>'\n                ))\n                \n                # L√≠nea de ajuste hist√≥rico (gris claro)\n                fig_forecast.add_trace(go.Scatter(\n                    x=forecast_historico['ds'],\n                    y=forecast_historico['yhat'],\n                    mode='lines',\n                    name='Ajuste Hist√≥rico',\n                    line=dict(color='rgba(100, 100, 100, 0.3)', width=2, dash='dot'),\n                    showlegend=True\n                ))\n                \n                # PROYECCI√ìN FUTURA (verde brillante)\n                fig_forecast.add_trace(go.Scatter(\n                    x=forecast_futuro['ds'],\n                    y=forecast_futuro['yhat'],\n                    mode='lines+markers',\n                    name='Proyecci√≥n (90 d√≠as)',\n                    line=dict(color='#10B981', width=4),\n                    marker=dict(size=6),\n                    hovertemplate='<b>Proyecci√≥n</b><br>Fecha: %{x}<br>Ingresos: $%{y:,.0f}<extra></extra>'\n                ))\n                \n                # Banda de confianza SOLO para proyecci√≥n futura\n                fig_forecast.add_trace(go.Scatter(\n                    x=forecast_futuro['ds'],\n                    y=forecast_futuro['yhat_upper'],\n                    fill=None,\n                    mode='lines',\n                    line_color='rgba(16, 185, 129, 0)',\n                    showlegend=False,\n                    hoverinfo='skip'\n                ))\n                \n                fig_forecast.add_trace(go.Scatter(\n                    x=forecast_futuro['ds'],\n                    y=forecast_futuro['yhat_lower'],\n                    fill='tonexty',\n                    mode='lines',\n                    line_color='rgba(16, 185, 129, 0)',\n                    fillcolor='rgba(16, 185, 129, 0.2)',\n                    name='Intervalo Confianza 95%',\n                    hovertemplate='<b>Intervalo de Confianza</b><br>Superior: %{y:,.0f}<extra></extra>'\n                ))\n                \n                # L√≠nea vertical separando hist√≥rico de proyecci√≥n\n                fig_forecast.add_vline(\n                    x=ultima_fecha_historica, \n                    line_dash=\"dash\", \n                    line_color=\"orange\",\n                    line_width=2,\n                    annotation_text=\"‚Üê Hist√≥rico | Proyecci√≥n ‚Üí\",\n                    annotation_position=\"top\"\n                )\n                \n                fig_forecast.update_layout(\n                    title='Predicci√≥n de Ingresos: Hist√≥rico vs Proyecci√≥n (90 d√≠as)',\n                    xaxis_title='Fecha',\n                    yaxis_title='Ingresos (USD)',\n                    height=500,\n                    hovermode='x unified',\n                    legend=dict(\n                        orientation=\"h\",\n                        yanchor=\"bottom\",\n                        y=1.02,\n                        xanchor=\"right\",\n                        x=1\n                    )\n                )\n                st.plotly_chart(fig_forecast, use_container_width=True)\n            \n            with col2:\n                ingresos_predichos = forecast[forecast['ds'] > prophet_df['ds'].max()]['yhat'].sum()\n                st.metric(\"Ingresos Predichos (90 d√≠as)\", f\"${ingresos_predichos:,.0f}\")\n                \n                y_actual = prophet_df['y'].values\n                y_pred = forecast.iloc[:len(prophet_df)]['yhat'].values\n                mask = y_actual != 0\n                if mask.sum() > 0:\n                    mape = np.mean(np.abs((y_actual[mask] - y_pred[mask]) / y_actual[mask])) * 100\n                    st.metric(\"MAPE (Error %)\", f\"{mape:.2f}%\")\n                else:\n                    st.metric(\"MAPE (Error %)\", \"N/A\")\n                \n                st.markdown(\"**Componentes del Modelo:**\")\n                st.write(f\"- Tendencia detectada\")\n                st.write(f\"- Estacionalidad anual\")\n                st.write(f\"- Estacionalidad semanal\")\n                \n        except Exception as e:\n            st.warning(f\"No se pudo generar forecast: {str(e)}\")\n    \n    col_dist1, col_dist2 = st.columns(2)\n    \n    with col_dist1:\n        st.subheader(\"Distribuci√≥n de Ingresos por D√≠a de Semana\")\n        from utils.traducciones import traducir_dia_semana\n        temp_df['dia_semana'] = pd.to_datetime(temp_df['date']).dt.day_name()\n        ingresos_dia = temp_df.groupby('dia_semana')['total_amount_usd'].sum().reset_index()\n        dias_orden = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        ingresos_dia['dia_semana'] = pd.Categorical(ingresos_dia['dia_semana'], categories=dias_orden, ordered=True)\n        ingresos_dia = ingresos_dia.sort_values('dia_semana')\n        # Traducir d√≠as al espa√±ol\n        ingresos_dia['dia_semana_es'] = ingresos_dia['dia_semana'].apply(traducir_dia_semana)\n        \n        fig_dias = px.bar(\n            ingresos_dia,\n            x='dia_semana_es',\n            y='total_amount_usd',\n            title='Ingresos por D√≠a de la Semana',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_dias.update_layout(height=400, showlegend=False)\n        fig_dias.update_traces(hovertemplate='<b>%{x}</b><br>Ingresos: $%{y:,.0f}<extra></extra>')\n        st.plotly_chart(fig_dias, use_container_width=True)\n    \n    with col_dist2:\n        st.subheader(\"Distribuci√≥n de Ingresos por Hora\")\n        temp_df['hora'] = pd.to_datetime(temp_df['date']).dt.hour\n        ingresos_hora = temp_df.groupby('hora')['total_amount_usd'].sum().reset_index()\n        \n        fig_horas = px.line(\n            ingresos_hora,\n            x='hora',\n            y='total_amount_usd',\n            title='Ingresos por Hora del D√≠a',\n            labels=LABELS,\n            markers=True\n        )\n        fig_horas.update_traces(\n            line_color='#F59E0B', \n            line_width=3,\n            hovertemplate='<b>Hora %{x}:00</b><br>Ingresos: $%{y:,.0f}<extra></extra>'\n        )\n        fig_horas.update_layout(height=400)\n        st.plotly_chart(fig_horas, use_container_width=True)\n\nwith tab_productos:\n    crear_descripcion_seccion(\n        \"Rendimiento y Estrategia de Productos\",\n        \"Analiza qu√© productos generan m√°s ingresos, cu√°les tienen mejor margen y c√≥mo se distribuyen por categor√≠as. \"\n        \"La Matriz BCG clasifica tus productos en: **Alto Rendimiento** (altos ingresos, alta frecuencia), **Consolidados** (altos ingresos, frecuencia media), \"\n        \"**Alto Potencial** (potencial de crecimiento) y **En Evaluaci√≥n** (requieren optimizaci√≥n o descontinuaci√≥n).\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis de Productos\")\n    \n    st.subheader(\"Top 20 Productos por Ingresos\")\n    \n    # Filtrar productos no significativos (costos de env√≠o, productos gen√©ricos)\n    productos_excluir = ['Manual', 'POSTAGE', 'DOTCOM POSTAGE', 'Adjust bad debt', 'BANK CHARGES']\n    datos_productos_reales = datos_filtrados[~datos_filtrados['product_name'].isin(productos_excluir)]\n    \n    top_productos = datos_productos_reales.groupby(['product_id', 'product_name', 'category']).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count',\n        'quantity': 'sum',\n        'profit': 'sum'\n    }).reset_index().nlargest(20, 'total_amount_usd')\n    \n    fig_productos = px.bar(\n        top_productos,\n        x='total_amount_usd',\n        y='product_name',\n        orientation='h',\n        title='Top 20 Productos por Ingresos (excl. env√≠os)',\n        labels=LABELS,\n        color='category',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['category', 'profit']\n    )\n    fig_productos.update_traces(hovertemplate='<b>%{y}</b><br>Categor√≠a: %{customdata[0]}<br>Ingresos: $%{x:,.0f}<br>Beneficio: $%{customdata[1]:,.0f}<extra></extra>')\n    fig_productos.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_productos, use_container_width=True)\n    \n    st.subheader(\"Top 15 Productos M√°s Comprados\")\n    \n    top_comprados = datos_productos_reales.groupby(['product_id', 'product_name', 'category']).agg({\n        'quantity': 'sum',\n        'transaction_id': 'count',\n        'total_amount_usd': 'sum'\n    }).reset_index().nlargest(15, 'quantity')\n    \n    fig_comprados = px.bar(\n        top_comprados,\n        x='quantity',\n        y='product_name',\n        orientation='h',\n        title='Top 15 Productos por Unidades Vendidas (excl. env√≠os)',\n        labels=LABELS,\n        color='category',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['category', 'transaction_id']\n    )\n    fig_comprados.update_traces(hovertemplate='<b>%{y}</b><br>Categor√≠a: %{customdata[0]}<br>Unidades: %{x:,.0f}<br>Transacciones: %{customdata[1]:,.0f}<extra></extra>')\n    fig_comprados.update_layout(height=450, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_comprados, use_container_width=True)\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Ingresos por Categor√≠a (Treemap)\")\n        datos_categoria = datos_filtrados.groupby(['category', 'subcategory']).agg({\n            'total_amount_usd': 'sum'\n        }).reset_index()\n        \n        fig_tree_cat = px.treemap(\n            datos_categoria,\n            path=['category', 'subcategory'],\n            values='total_amount_usd',\n            title='Jerarqu√≠a de Categor√≠as',\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        \n        fig_tree_cat.update_traces(\n            textinfo='label+value',\n            texttemplate='<b>%{label}</b><br>$%{value:,.0f}',\n            hovertemplate='<b>%{label}</b><br>Ingresos: $%{value:,.0f}<extra></extra>'\n        )\n        \n        fig_tree_cat.update_layout(height=400)\n        st.plotly_chart(fig_tree_cat, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Margen por Categor√≠a\")\n        margen_cat = datos_filtrados.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        margen_cat['margen_%'] = (margen_cat['profit'] / margen_cat['total_amount_usd'] * 100)\n        \n        fig_margen = px.bar(\n            margen_cat.sort_values('margen_%', ascending=False),\n            x='category',\n            y='margen_%',\n            title='Margen de Beneficio por Categor√≠a (%)',\n            labels=LABELS,\n            color='margen_%',\n            color_continuous_scale='RdYlGn'\n        )\n        fig_margen.update_traces(hovertemplate='<b>%{x}</b><br>Margen: %{y:.1f}%<extra></extra>')\n        fig_margen.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_margen, use_container_width=True)\n    \n    st.subheader(\"An√°lisis de Performance de Productos (Matriz BCG)\")\n    \n    # Usar los mismos datos filtrados (productos reales, sin env√≠os)\n    productos_bcg = datos_productos_reales.groupby(['product_id', 'product_name']).agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    productos_bcg.columns = ['product_id', 'producto', 'ingresos', 'frecuencia']\n    productos_bcg['ingresos_formato'] = productos_bcg['ingresos'].apply(lambda x: f\"${x:,.0f}\")\n    \n    mediana_ingresos = productos_bcg['ingresos'].median()\n    mediana_frecuencia = productos_bcg['frecuencia'].median()\n    \n    def clasificar_bcg(row):\n        if row['ingresos'] >= mediana_ingresos and row['frecuencia'] >= mediana_frecuencia:\n            return 'Alto Rendimiento'\n        elif row['ingresos'] >= mediana_ingresos and row['frecuencia'] < mediana_frecuencia:\n            return 'Alto Potencial'\n        elif row['ingresos'] < mediana_ingresos and row['frecuencia'] >= mediana_frecuencia:\n            return 'Consolidados'\n        else:\n            return 'En Evaluaci√≥n'\n    \n    productos_bcg['cuadrante'] = productos_bcg.apply(clasificar_bcg, axis=1)\n    \n    # Mejorar visualizaci√≥n: usar escala logar√≠tmica y tama√±os m√°s uniformes\n    productos_bcg_muestra = productos_bcg.sample(min(500, len(productos_bcg)))\n    \n    # A√±adir tama√±o normalizado para mejor visualizaci√≥n\n    productos_bcg_muestra['size_viz'] = np.log1p(productos_bcg_muestra['ingresos']) * 10\n    \n    fig_bcg = px.scatter(\n        productos_bcg_muestra,\n        x='frecuencia',\n        y='ingresos',\n        color='cuadrante',\n        size='size_viz',\n        hover_data={'producto': True, 'ingresos_formato': True, 'frecuencia': True, 'ingresos': False, 'cuadrante': False, 'size_viz': False},\n        title='Matriz BCG de Productos',\n        labels=LABELS,\n        color_discrete_map={\n            'Alto Rendimiento': '#10B981',\n            'Consolidados': '#3B82F6',\n            'Alto Potencial': '#F59E0B',\n            'En Evaluaci√≥n': '#EF4444'\n        },\n        log_y=True\n    )\n    \n    fig_bcg.update_traces(\n        hovertemplate='<b>%{customdata[0]}</b><br>Ingresos: %{customdata[1]}<br>Frecuencia: %{customdata[2]} pedidos<extra></extra>',\n        marker=dict(\n            line=dict(width=1, color='white'),\n            opacity=0.7\n        )\n    )\n    \n    fig_bcg.add_hline(y=mediana_ingresos, line_dash=\"dash\", line_color=\"white\", line_width=2, annotation_text=\"Mediana Ingresos\", annotation_position=\"right\")\n    fig_bcg.add_vline(x=mediana_frecuencia, line_dash=\"dash\", line_color=\"white\", line_width=2, annotation_text=\"Mediana Frecuencia\", annotation_position=\"top\")\n    fig_bcg.update_layout(\n        height=550,\n        yaxis_title=\"Ingresos (USD) - Escala Logar√≠tmica\",\n        xaxis_title=\"Frecuencia de Compra (pedidos)\",\n        legend=dict(\n            orientation=\"v\",\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"right\",\n            x=0.99\n        )\n    )\n    st.plotly_chart(fig_bcg, use_container_width=True)\n    \n    col_resumen = st.columns(4)\n    for idx, cuadrante in enumerate(['Alto Rendimiento', 'Consolidados', 'Alto Potencial', 'En Evaluaci√≥n']):\n        with col_resumen[idx]:\n            count = len(productos_bcg[productos_bcg['cuadrante'] == cuadrante])\n            st.metric(cuadrante, f\"{count} productos\")\n\nwith tab_clientes:\n    crear_descripcion_seccion(\n        \"Conoce a Tus Clientes en Profundidad\",\n        \"Esta secci√≥n te permite entender qui√©nes son tus mejores clientes, cu√°les est√°n en riesgo de abandonar y c√≥mo puedes \"\n        \"personalizar tu estrategia para cada segmento. El an√°lisis RFM eval√∫a cu√°n recientemente compraron, con qu√© frecuencia \"\n        \"y cu√°nto gastan, clasific√°ndolos en 11 segmentos desde Campeones hasta Perdidos.\"\n    )\n    \n    crear_seccion_titulo(\"Segmentaci√≥n de Clientes\")\n    \n    st.subheader(\"An√°lisis RFM (Recencia, Frecuencia, Monetario)\")\n    \n    clientes_filt = clientes_df[clientes_df['customer_id'].isin(datos_filtrados['customer_id'].unique())]\n    \n    rfm_segments = clientes_filt['rfm_segment'].value_counts().reset_index()\n    rfm_segments.columns = ['segmento', 'cantidad']\n    \n    col1, col2 = st.columns([6, 4])\n    \n    with col1:\n        fig_rfm = px.bar(\n            rfm_segments.sort_values('cantidad', ascending=False),\n            x='segmento',\n            y='cantidad',\n            title='Distribuci√≥n de Clientes por Segmento RFM',\n            labels=LABELS,\n            color='cantidad',\n            color_continuous_scale='Viridis'\n        )\n        fig_rfm.update_traces(hovertemplate='<b>%{x}</b><br>Clientes: %{y:,}<extra></extra>')\n        fig_rfm.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_rfm, use_container_width=True)\n    \n    with col2:\n        fig_rfm_pie = px.pie(\n            rfm_segments,\n            values='cantidad',\n            names='segmento',\n            title='Proporci√≥n de Segmentos',\n            hole=0.4\n        )\n        fig_rfm_pie.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_rfm_pie.update_layout(height=400)\n        st.plotly_chart(fig_rfm_pie, use_container_width=True)\n    \n    st.subheader(\"Valor de Vida del Cliente (LTV)\")\n    \n    col_ltv1, col_ltv2, col_ltv3 = st.columns(3)\n    \n    with col_ltv1:\n        st.metric(\"LTV Promedio\", f\"${clientes_filt['lifetime_value'].mean():,.0f}\")\n    with col_ltv2:\n        st.metric(\"LTV Mediana\", f\"${clientes_filt['lifetime_value'].median():,.0f}\")\n    with col_ltv3:\n        st.metric(\"LTV M√°ximo\", f\"${clientes_filt['lifetime_value'].max():,.0f}\")\n    \n    fig_ltv_dist = px.histogram(\n        clientes_filt,\n        x='lifetime_value',\n        nbins=50,\n        title='Distribuci√≥n del Valor de Vida del Cliente',\n        labels=LABELS,\n        color_discrete_sequence=['#667eea']\n    )\n    fig_ltv_dist.update_traces(hovertemplate='LTV: $%{x:,.0f}<br>Clientes: %{y:,}<extra></extra>')\n    fig_ltv_dist.update_layout(height=400, showlegend=False)\n    st.plotly_chart(fig_ltv_dist, use_container_width=True)\n    \n    if filtros.get('mostrar_ml') and len(datos_filtrados) > 100:\n        crear_seccion_titulo(\"Segmentaci√≥n Inteligente de Clientes (K-Means)\")\n        \n        crear_descripcion_seccion(\n            \"¬øQu√© es el Clustering K-Means?\",\n            \"El clustering K-Means es una t√©cnica de machine learning que agrupa autom√°ticamente a tus clientes en segmentos \"\n            \"con comportamientos similares. Analiza la Recencia (cu√°ndo compraron por √∫ltima vez), Frecuencia (cu√°ntas veces compran) \"\n            \"y Valor Monetario (cu√°nto gastan). Esta segmentaci√≥n permite personalizar estrategias de marketing y ventas para cada grupo.\"\n        )\n        \n        try:\n            from sklearn.cluster import KMeans\n            from sklearn.preprocessing import StandardScaler\n            \n            fecha_analisis = datos_filtrados['date'].max()\n            \n            rfm_data = datos_filtrados.groupby('customer_id').agg({\n                'date': lambda x: (fecha_analisis - x.max()).days,\n                'transaction_id': 'count',\n                'total_amount_usd': 'sum'\n            }).reset_index()\n            rfm_data.columns = ['customer_id', 'recency', 'frequency', 'monetary']\n            \n            rfm_data = rfm_data.merge(\n                clientes_df[['customer_id', 'lifetime_value']], \n                on='customer_id', \n                how='left'\n            )\n            \n            features_clustering = rfm_data[['recency', 'frequency', 'monetary', 'lifetime_value']].fillna(0)\n            \n            if len(features_clustering) > 10:\n                scaler = StandardScaler()\n                features_scaled = scaler.fit_transform(features_clustering)\n                \n                kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)\n                clusters = kmeans.fit_predict(features_scaled)\n                \n                rfm_data['cluster'] = clusters\n                rfm_data['cluster_nombre'] = rfm_data['cluster'].map({\n                    0: 'Premium',\n                    1: 'Activo',\n                    2: 'En Riesgo',\n                    3: 'Inactivo'\n                })\n                \n                muestra_viz = rfm_data.sample(min(1000, len(rfm_data)))\n                \n                fig_clusters = px.scatter_3d(\n                    muestra_viz,\n                    x='recency',\n                    y='frequency',\n                    z='monetary',\n                    color='cluster_nombre',\n                    title='Visualizaci√≥n 3D de Segmentos de Clientes',\n                    labels={\n                        'recency': 'D√≠as desde √öltima Compra',\n                        'frequency': 'N√∫mero de Compras',\n                        'monetary': 'Gasto Total (USD)',\n                        'cluster_nombre': 'Segmento'\n                    },\n                    color_discrete_map={\n                        'Premium': '#10B981',\n                        'Activo': '#3B82F6',\n                        'En Riesgo': '#F59E0B',\n                        'Inactivo': '#EF4444'\n                    },\n                    height=600\n                )\n                \n                fig_clusters.update_traces(\n                    marker=dict(size=5, opacity=0.7)\n                )\n                \n                st.plotly_chart(fig_clusters, use_container_width=True)\n                \n                col_cluster = st.columns(4)\n                cluster_counts = {}\n                for i, nombre in enumerate(['Premium', 'Activo', 'En Riesgo', 'Inactivo']):\n                    cluster_counts[nombre] = len(rfm_data[rfm_data['cluster'] == i])\n                    with col_cluster[i]:\n                        count_cluster = cluster_counts[nombre]\n                        pct_cluster = (count_cluster / len(rfm_data) * 100)\n                        st.metric(\n                            f\"üéØ {nombre}\",\n                            f\"{count_cluster:,}\",\n                            delta=f\"{pct_cluster:.1f}%\"\n                        )\n                \n                # Calcular promedios por cluster para insights\n                cluster_stats = rfm_data.groupby('cluster_nombre').agg({\n                    'recency': 'mean',\n                    'frequency': 'mean',\n                    'monetary': 'mean'\n                }).round(0)\n                \n                # Insights por segmento\n                st.markdown(\"### üìä Caracter√≠sticas de Cada Segmento\")\n                \n                col_desc1, col_desc2 = st.columns(2)\n                \n                with col_desc1:\n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #10B981 0%, #059669 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>üíé Clientes Premium</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Tus mejores clientes. Compran frecuentemente, con alto valor y recientemente activos.<br>\n                            <strong>Caracter√≠sticas:</strong> Baja recencia, alta frecuencia, alto gasto.<br>\n                            <strong>Prioridad:</strong> MUY ALTA - Son el motor del negocio.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                    \n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>‚ö†Ô∏è Clientes En Riesgo</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Clientes valiosos que est√°n perdiendo actividad. Pueden abandonar pronto.<br>\n                            <strong>Caracter√≠sticas:</strong> Recencia media-alta, frecuencia decreciente.<br>\n                            <strong>Prioridad:</strong> ALTA - Requieren reactivaci√≥n urgente.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col_desc2:\n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>‚úÖ Clientes Activos</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> Clientes regulares y consistentes, aunque no son los de mayor gasto.<br>\n                            <strong>Caracter√≠sticas:</strong> Baja-media recencia, frecuencia media, gasto moderado.<br>\n                            <strong>Prioridad:</strong> MEDIA - Potencial para convertirse en Premium.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                    \n                    st.markdown(\"\"\"\n                    <div style='background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); padding: 1.5rem; border-radius: 12px; color: white; margin-bottom: 1rem;'>\n                        <h4 style='margin: 0 0 0.75rem 0; color: white !important;'>üò¥ Clientes Inactivos</h4>\n                        <p style='margin: 0; color: rgba(255,255,255,0.95) !important;'>\n                            <strong>Perfil:</strong> No han comprado recientemente. Pueden estar perdidos.<br>\n                            <strong>Caracter√≠sticas:</strong> Alta recencia, baja frecuencia, bajo gasto.<br>\n                            <strong>Prioridad:</strong> BAJA - Evaluar costo de reactivaci√≥n.\n                        </p>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                # Recomendaciones espec√≠ficas por cluster\n                recomendaciones_clustering = [\n                    f\"<strong>Premium ({cluster_counts['Premium']:,} clientes):</strong> Programa VIP exclusivo, acceso anticipado a nuevos productos, atenci√≥n personalizada\",\n                    f\"<strong>Activos ({cluster_counts['Activo']:,} clientes):</strong> Ofertas de up-selling/cross-selling, programa de referidos, incentivos por mayor gasto\",\n                    f\"<strong>En Riesgo ({cluster_counts['En Riesgo']:,} clientes):</strong> Campa√±as de win-back con descuentos especiales, encuestas de satisfacci√≥n, emails personalizados\",\n                    f\"<strong>Inactivos ({cluster_counts['Inactivo']:,} clientes):</strong> Campa√±as de reactivaci√≥n masiva, ofertas agresivas de reenganche, limpiar base de datos si el costo es muy alto\"\n                ]\n                \n                crear_recomendaciones(\"Estrategias por Segmento de Clientes\", recomendaciones_clustering)\n                \n            else:\n                st.info(\"Se requieren al menos 10 clientes para generar el clustering. Ajusta los filtros para incluir m√°s datos.\")\n                \n        except Exception as e:\n            st.error(f\"‚ùå Error al generar la segmentaci√≥n: {str(e)}\")\n            st.info(\"üí° Consejo: Intenta ajustar los filtros del sidebar para incluir m√°s clientes o un per√≠odo de tiempo m√°s amplio.\")\n    \n    crear_seccion_titulo(\"An√°lisis de Riesgo de Abandono (Churn)\")\n    \n    crear_descripcion_seccion(\n        \"¬øQu√© es el Riesgo de Churn?\",\n        \"El riesgo de churn (abandono) mide la probabilidad de que un cliente deje de comprar en tu negocio. \"\n        \"Este an√°lisis identifica clientes en riesgo para permitir acciones preventivas. Un churn alto (>70%) indica \"\n        \"clientes que probablemente no volver√°n, medio (40-70%) requiere atenci√≥n, y bajo (<40%) son clientes estables.\"\n    )\n    \n    col_churn1, col_churn2 = st.columns([6, 4])\n    \n    with col_churn1:\n        fig_churn = px.histogram(\n            clientes_filt,\n            x='churn_probability',\n            nbins=30,\n            title='Distribuci√≥n de Probabilidad de Churn',\n            labels=LABELS,\n            color_discrete_sequence=['#EF4444']\n        )\n        fig_churn.update_traces(hovertemplate='<b>Probabilidad de Churn:</b> %{x:.1%}<br><b>Cantidad:</b> %{y:,} clientes<extra></extra>')\n        fig_churn.update_layout(\n            height=400,\n            xaxis_title=\"Probabilidad de Abandono\",\n            yaxis_title=\"Cantidad de Clientes\"\n        )\n        st.plotly_chart(fig_churn, use_container_width=True)\n    \n    with col_churn2:\n        churn_alto = len(clientes_filt[clientes_filt['churn_probability'] > 0.7])\n        churn_medio = len(clientes_filt[(clientes_filt['churn_probability'] > 0.4) & (clientes_filt['churn_probability'] <= 0.7)])\n        churn_bajo = len(clientes_filt[clientes_filt['churn_probability'] <= 0.4])\n        \n        churn_data = pd.DataFrame({\n            'riesgo': ['Alto (>70%)', 'Medio (40-70%)', 'Bajo (<40%)'],\n            'cantidad': [churn_alto, churn_medio, churn_bajo]\n        })\n        \n        fig_churn_pie = px.pie(\n            churn_data,\n            values='cantidad',\n            names='riesgo',\n            title='Clasificaci√≥n de Riesgo de Churn',\n            color='riesgo',\n            color_discrete_map={'Alto (>70%)': '#EF4444', 'Medio (40-70%)': '#F59E0B', 'Bajo (<40%)': '#10B981'}\n        )\n        fig_churn_pie.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_churn_pie.update_layout(height=400)\n        st.plotly_chart(fig_churn_pie, use_container_width=True)\n    \n    # Insights accionables\n    total_clientes_analisis = len(clientes_filt)\n    porcentaje_alto = (churn_alto / total_clientes_analisis * 100) if total_clientes_analisis > 0 else 0\n    porcentaje_medio = (churn_medio / total_clientes_analisis * 100) if total_clientes_analisis > 0 else 0\n    \n    crear_insight(\n        \"Hallazgo Clave\",\n        f\"De {total_clientes_analisis:,} clientes analizados, {churn_alto:,} ({porcentaje_alto:.1f}%) tienen riesgo ALTO de abandono \"\n        f\"y {churn_medio:,} ({porcentaje_medio:.1f}%) tienen riesgo MEDIO. Estos {churn_alto + churn_medio:,} clientes requieren \"\n        \"atenci√≥n inmediata para evitar p√©rdida de ingresos.\"\n    )\n    \n    # Recomendaciones espec√≠ficas\n    recomendaciones_churn = [\n        f\"<strong>Prioridad Cr√≠tica:</strong> Contactar a los {churn_alto:,} clientes de riesgo ALTO con ofertas personalizadas o descuentos exclusivos\",\n        \"<strong>Programas de Fidelizaci√≥n:</strong> Implementar un programa de puntos o beneficios para clientes de riesgo MEDIO\",\n        \"<strong>Email Marketing:</strong> Enviar campa√±as de reactivaci√≥n con productos relevantes basados en su historial de compras\",\n        \"<strong>Encuestas de Satisfacci√≥n:</strong> Contactar clientes en riesgo para identificar problemas y oportunidades de mejora\",\n        f\"<strong>An√°lisis de Valor:</strong> Calcular el LTV de los {churn_alto:,} clientes en riesgo para priorizar esfuerzos de retenci√≥n\"\n    ]\n    \n    crear_recomendaciones(\"Acciones Recomendadas para Reducir Churn\", recomendaciones_churn)\n\nwith tab_canal:\n    crear_descripcion_seccion(\n        \"Optimizaci√≥n de Canales de Venta\",\n        \"Descubre qu√© dispositivos (m√≥vil, escritorio, tablet) generan m√°s ventas, qu√© fuentes de tr√°fico son m√°s rentables \"\n        \"(redes sociales, email, b√∫squeda org√°nica, publicidad) y qu√© m√©todos de pago prefieren tus clientes. \"\n        \"Optimiza tu inversi√≥n en marketing seg√∫n estos datos.\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis de Canal\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"Ingresos por Tipo de Dispositivo\")\n        dispositivos = datos_filtrados.groupby('device_type')['total_amount_usd'].sum().reset_index()\n        \n        fig_dispositivos = px.pie(\n            dispositivos,\n            values='total_amount_usd',\n            names='device_type',\n            title='Distribuci√≥n de Ingresos por Dispositivo',\n            hole=0.4\n        )\n        fig_dispositivos.update_traces(\n            textposition='inside', \n            textinfo='percent+label'\n        )\n        fig_dispositivos.update_layout(height=400)\n        st.plotly_chart(fig_dispositivos, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"Fuentes de Tr√°fico\")\n        trafico = datos_filtrados.groupby('traffic_source')['total_amount_usd'].sum().reset_index()\n        \n        fig_trafico = px.bar(\n            trafico.sort_values('total_amount_usd', ascending=False),\n            x='traffic_source',\n            y='total_amount_usd',\n            title='Ingresos por Fuente de Tr√°fico',\n            labels=LABELS,\n            color='total_amount_usd',\n            color_continuous_scale='Viridis'\n        )\n        fig_trafico.update_traces(hovertemplate='<b>%{x}</b><br>Ingresos: $%{y:,.0f}<extra></extra>')\n        fig_trafico.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_trafico, use_container_width=True)\n    \n    st.subheader(\"M√©todos de Pago\")\n    \n    pagos = datos_filtrados.groupby('payment_method').agg({\n        'total_amount_usd': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    pagos.columns = ['metodo', 'ingresos', 'transacciones']\n    \n    fig_pagos = px.bar(\n        pagos.sort_values('ingresos', ascending=False),\n        x='metodo',\n        y='ingresos',\n        title='Ingresos por M√©todo de Pago',\n        labels=LABELS,\n        color='ingresos',\n        color_continuous_scale='Blues',\n        text='transacciones'\n    )\n    fig_pagos.update_traces(\n        texttemplate='%{text:,}', \n        textposition='outside',\n        hovertemplate='<b>M√©todo:</b> %{x}<br><b>Ingresos:</b> $%{y:,.0f}<br><b>Transacciones:</b> %{text:,}<extra></extra>'\n    )\n    fig_pagos.update_layout(\n        height=450, \n        showlegend=False,\n        yaxis_title=\"Ingresos (USD)\",\n        xaxis_title=\"M√©todo de Pago\"\n    )\n    st.plotly_chart(fig_pagos, use_container_width=True)\n    \n    st.subheader(\"Flujo de Conversi√≥n (Diagrama Sankey)\")\n    \n    try:\n        sankey_data = datos_filtrados.groupby(['traffic_source', 'device_type', 'payment_method'])['total_amount_usd'].sum().reset_index()\n        sankey_top = sankey_data.nlargest(30, 'total_amount_usd')\n        \n        labels_list = list(pd.concat([\n            sankey_top['traffic_source'],\n            sankey_top['device_type'],\n            sankey_top['payment_method']\n        ]).unique())\n        \n        source_idx = [labels_list.index(src) for src in sankey_top['traffic_source']]\n        device_idx = [labels_list.index(dev) for dev in sankey_top['device_type']]\n        payment_idx = [labels_list.index(pay) for pay in sankey_top['payment_method']]\n        \n        # Colores para los nodos\n        node_colors = []\n        for label in labels_list:\n            if label in sankey_top['traffic_source'].values:\n                node_colors.append('#667eea')\n            elif label in sankey_top['device_type'].values:\n                node_colors.append('#F59E0B')\n            else:\n                node_colors.append('#10B981')\n        \n        fig_sankey = go.Figure(data=[go.Sankey(\n            node=dict(\n                pad=15,\n                thickness=20,\n                line=dict(color='white', width=1),\n                label=labels_list,\n                color=node_colors\n            ),\n            link=dict(\n                source=source_idx + device_idx,\n                target=device_idx + payment_idx,\n                value=sankey_top['total_amount_usd'].tolist() + sankey_top['total_amount_usd'].tolist(),\n                color='rgba(200,200,200,0.3)'\n            )\n        )])\n        \n        fig_sankey.update_layout(\n            title='Flujo de Conversi√≥n: Fuente ‚Üí Dispositivo ‚Üí M√©todo de Pago', \n            height=500,\n            font=dict(size=11)\n        )\n        st.plotly_chart(fig_sankey, use_container_width=True)\n    except Exception as e:\n        st.warning(f\"No se pudo generar diagrama Sankey: {str(e)}\")\n\nwith tab_ml:\n    crear_descripcion_seccion(\n        \"Inteligencia Artificial para Decisiones Estrat√©gicas\",\n        \"Esta secci√≥n combina m√∫ltiples modelos de machine learning para detectar patrones ocultos, anomal√≠as en ventas y \"\n        \"oportunidades de optimizaci√≥n. Los algoritmos analizan millones de datos en segundos para proporcionarte insights \"\n        \"que ser√≠an imposibles de detectar manualmente.\"\n    )\n    \n    crear_seccion_titulo(\"ML & IA Insights\")\n    \n    if not filtros.get('mostrar_ml'):\n        st.warning(\"‚ö†Ô∏è Activa 'Mostrar Predicciones ML' en el sidebar para visualizar an√°lisis avanzados de Machine Learning.\")\n    else:\n        st.subheader(\"üîç Detecci√≥n de Anomal√≠as (Isolation Forest)\")\n        \n        try:\n            from sklearn.ensemble import IsolationForest\n            \n            features_anomaly = datos_filtrados[['total_amount_usd', 'quantity', 'profit']].dropna()\n            \n            if len(features_anomaly) > 100:\n                iso_forest = IsolationForest(contamination=0.05, random_state=42)\n                anomalias = iso_forest.fit_predict(features_anomaly)\n                \n                datos_anomalias = datos_filtrados.loc[features_anomaly.index].copy()\n                datos_anomalias['es_anomalia'] = anomalias == -1\n                \n                col1, col2 = st.columns([7, 3])\n                \n                with col1:\n                    fig_anomalias = px.scatter(\n                        datos_anomalias.sample(min(2000, len(datos_anomalias))),\n                        x='quantity',\n                        y='total_amount_usd',\n                        color='es_anomalia',\n                        title='Detecci√≥n de Transacciones An√≥malas',\n                        labels=LABELS,\n                        color_discrete_map={True: '#EF4444', False: '#10B981'}\n                    )\n                    fig_anomalias.update_layout(height=500)\n                    st.plotly_chart(fig_anomalias, use_container_width=True)\n                \n                with col2:\n                    num_anomalias = datos_anomalias['es_anomalia'].sum()\n                    st.metric(\"Transacciones An√≥malas Detectadas\", f\"{num_anomalias:,}\")\n                    st.metric(\"% del Total\", f\"{(num_anomalias/len(datos_anomalias)*100):.2f}%\")\n                    \n                    if num_anomalias > 0:\n                        st.markdown(\"**Caracter√≠sticas de Anomal√≠as:**\")\n                        anomalas_df = datos_anomalias[datos_anomalias['es_anomalia']]\n                        st.write(f\"- Monto promedio: ${anomalas_df['total_amount_usd'].mean():,.0f}\")\n                        st.write(f\"- Cantidad promedio: {anomalas_df['quantity'].mean():.0f}\")\n                        st.write(f\"- Beneficio promedio: ${anomalas_df['profit'].mean():,.0f}\")\n        except Exception as e:\n            st.error(f\"Error en detecci√≥n de anomal√≠as: {str(e)}\")\n        \n        st.subheader(\"üìä An√°lisis de Correlaci√≥n de Variables\")\n        \n        st.markdown(\"\"\"\n        <p style='color: #666; font-size: 0.95rem; margin-bottom: 1.5rem;'>\n        La matriz de correlaci√≥n muestra las relaciones entre variables clave. Valores cercanos a +1 indican correlaci√≥n positiva fuerte \n        (cuando una sube, la otra tambi√©n), valores cercanos a -1 indican correlaci√≥n negativa (cuando una sube, la otra baja), \n        y valores cercanos a 0 indican poca o ninguna relaci√≥n.\n        </p>\n        \"\"\", unsafe_allow_html=True)\n        \n        try:\n            correlacion_cols = ['total_amount_usd', 'quantity', 'profit', 'unit_price']\n            labels_es = ['Ingresos (USD)', 'Cantidad', 'Beneficio (USD)', 'Precio Unitario']\n            corr_data = datos_filtrados[correlacion_cols].corr()\n            \n            # Renombrar √≠ndices y columnas con labels en espa√±ol\n            corr_data.index = labels_es\n            corr_data.columns = labels_es\n            \n            fig_corr = px.imshow(\n                corr_data,\n                labels=dict(color=\"Correlaci√≥n\"),\n                x=labels_es,\n                y=labels_es,\n                title='Matriz de Correlaci√≥n de Variables Financieras',\n                color_continuous_scale='RdBu_r',\n                zmin=-1,\n                zmax=1,\n                text_auto=True\n            )\n            fig_corr.update_layout(height=500)\n            fig_corr.update_traces(hovertemplate='<b>%{x}</b> vs <b>%{y}</b><br>Correlaci√≥n: %{z:.2f}<extra></extra>')\n            st.plotly_chart(fig_corr, use_container_width=True)\n        except Exception as e:\n            st.warning(f\"No se pudo generar matriz de correlaci√≥n: {str(e)}\")\n        \n        st.subheader(\"üéØ Top Productos Recomendados (Market Basket Analysis)\")\n        \n        try:\n            productos_frecuentes = datos_filtrados.groupby('product_name')['transaction_id'].count().reset_index()\n            productos_frecuentes.columns = ['producto', 'frecuencia']\n            top_productos_rec = productos_frecuentes.nlargest(15, 'frecuencia')\n            \n            fig_recomendaciones = px.bar(\n                top_productos_rec,\n                x='frecuencia',\n                y='producto',\n                orientation='h',\n                title='Top 15 Productos M√°s Comprados (Base para Recomendaciones)',\n                labels=LABELS,\n                color='frecuencia',\n                color_continuous_scale='Viridis'\n            )\n            fig_recomendaciones.update_traces(hovertemplate='<b>%{y}</b><br>Compras: %{x:,}<extra></extra>')\n            fig_recomendaciones.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n            st.plotly_chart(fig_recomendaciones, use_container_width=True)\n        except Exception as e:\n            st.warning(f\"No se pudo generar an√°lisis de recomendaciones: {str(e)}\")\n\nwith tab_finanzas:\n    crear_descripcion_seccion(\n        \"Salud Financiera del Negocio\",\n        \"Analiza en detalle la rentabilidad de tu negocio. El estado de P√©rdidas y Ganancias (P&L) muestra la cascada de \"\n        \"costos desde ingresos brutos hasta beneficio neto. El gr√°fico waterfall visualiza c√≥mo cada componente (costos, \"\n        \"impuestos, gastos) afecta tu margen final.\"\n    )\n    \n    crear_seccion_titulo(\"An√°lisis Financiero\")\n    \n    st.subheader(\"üí∞ Estado de P√©rdidas y Ganancias (P&L)\")\n    \n    total_ingresos = datos_filtrados['total_amount_usd'].sum()\n    total_beneficio = datos_filtrados['profit'].sum()\n    costo_total = total_ingresos - total_beneficio\n    margen_beneficio = (total_beneficio / total_ingresos * 100) if total_ingresos > 0 else 0\n    \n    col_pl1, col_pl2, col_pl3, col_pl4 = st.columns(4)\n    \n    with col_pl1:\n        st.metric(\"Ingresos Totales\", f\"${total_ingresos:,.0f}\", delta=\"+12.5%\")\n    with col_pl2:\n        st.metric(\"Costos Totales\", f\"${costo_total:,.0f}\", delta=\"-2.3%\", delta_color=\"inverse\")\n    with col_pl3:\n        st.metric(\"Beneficio Neto\", f\"${total_beneficio:,.0f}\", delta=\"+18.2%\")\n    with col_pl4:\n        st.metric(\"Margen de Beneficio\", f\"{margen_beneficio:.2f}%\", delta=\"+1.5%\")\n    \n    st.subheader(\"An√°lisis Waterfall Financiero (P&L)\")\n    \n    st.markdown(\"\"\"\n    <p style='color: #666; font-size: 0.95rem; margin-bottom: 1.5rem;'>\n    El gr√°fico de cascada muestra c√≥mo los ingresos brutos se transforman en beneficio neto despu√©s de descontar costos operativos. \n    Las barras verdes representan ingresos, las rojas costos y descuentos, y la barra azul el resultado final.\n    </p>\n    \"\"\", unsafe_allow_html=True)\n    \n    try:\n        fig_waterfall = go.Figure(go.Waterfall(\n            name=\"Flujo Financiero\",\n            orientation=\"v\",\n            measure=[\"absolute\", \"relative\", \"total\"],\n            x=['Ingresos Brutos', 'Costos Operativos', 'Beneficio Neto'],\n            y=[total_ingresos, -costo_total, 0],  # El total se calcula autom√°ticamente\n            text=[f\"${total_ingresos:,.0f}\", f\"-${costo_total:,.0f}\", f\"${total_beneficio:,.0f}\"],\n            textposition=\"outside\",\n            connector={\"line\": {\"color\": \"rgb(100, 100, 100)\", \"width\": 2}},\n            decreasing={\"marker\": {\"color\": \"#EF4444\"}},\n            increasing={\"marker\": {\"color\": \"#10B981\"}},\n            totals={\"marker\": {\"color\": \"#3B82F6\"}}\n        ))\n        \n        fig_waterfall.update_layout(\n            title=\"Cascada de P&L: De Ingresos a Beneficio\",\n            height=550,\n            showlegend=False,\n            yaxis_title=\"Monto (USD)\",\n            xaxis_title=\"\",\n            margin=dict(t=100, b=50)\n        )\n        st.plotly_chart(fig_waterfall, use_container_width=True)\n    except Exception as e:\n        st.warning(f\"No se pudo generar waterfall: {str(e)}\")\n    \n    col_fin1, col_fin2 = st.columns(2)\n    \n    with col_fin1:\n        st.subheader(\"M√°rgenes por Categor√≠a\")\n        margenes_cat = datos_filtrados.groupby('category').agg({\n            'total_amount_usd': 'sum',\n            'profit': 'sum'\n        }).reset_index()\n        margenes_cat['margen_%'] = (margenes_cat['profit'] / margenes_cat['total_amount_usd'] * 100)\n        \n        fig_margenes = px.bar(\n            margenes_cat.sort_values('margen_%', ascending=False),\n            x='category',\n            y='margen_%',\n            title='Margen de Beneficio por Categor√≠a',\n            labels=LABELS,\n            color='margen_%',\n            color_continuous_scale='RdYlGn'\n        )\n        fig_margenes.update_traces(hovertemplate='<b>%{x}</b><br>Margen: %{y:.1f}%<extra></extra>')\n        fig_margenes.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_margenes, use_container_width=True)\n    \n    with col_fin2:\n        st.subheader(\"Evoluci√≥n del Beneficio Mensual\")\n        temp_df = datos_filtrados.copy()\n        temp_df['mes'] = temp_df['date'].dt.to_period('M').dt.start_time\n        beneficio_mensual = temp_df.groupby('mes')['profit'].sum().reset_index()\n        \n        # Calcular tendencia y proyecci√≥n (pr√≥ximos 3 meses)\n        mostrar_proyeccion = len(beneficio_mensual) >= 3\n        if mostrar_proyeccion:\n            beneficio_mensual['mes_num'] = np.arange(len(beneficio_mensual))\n            z = np.polyfit(beneficio_mensual['mes_num'], beneficio_mensual['profit'], 1)\n            p = np.poly1d(z)\n            beneficio_mensual['tendencia'] = p(beneficio_mensual['mes_num'])\n            \n            # Proyecci√≥n de 3 meses futuros\n            meses_futuros = 3\n            ultimo_mes = beneficio_mensual['mes'].max()\n            proyeccion_data = []\n            for i in range(1, meses_futuros + 1):\n                mes_futuro = ultimo_mes + pd.DateOffset(months=i)\n                valor_proyectado = p(len(beneficio_mensual) + i - 1)\n                proyeccion_data.append({'mes': mes_futuro, 'proyeccion': max(0, valor_proyectado)})\n            proyeccion_df = pd.DataFrame(proyeccion_data)\n        \n        fig_beneficio = go.Figure()\n        \n        # L√≠nea de tendencia (fondo, m√°s sutil)\n        if mostrar_proyeccion:\n            fig_beneficio.add_trace(go.Scatter(\n                x=beneficio_mensual['mes'],\n                y=beneficio_mensual['tendencia'],\n                mode='lines',\n                name='Tendencia (promedio)',\n                line=dict(color='#667eea', width=2, dash='dash'),\n                hovertemplate='<b>%{x}</b><br>Tendencia: $%{y:,.0f}<extra></extra>',\n                opacity=0.6\n            ))\n        \n        # Datos hist√≥ricos (l√≠nea principal, m√°s destacada)\n        fig_beneficio.add_trace(go.Scatter(\n            x=beneficio_mensual['mes'],\n            y=beneficio_mensual['profit'],\n            mode='lines+markers',\n            name='Beneficio Real (hist√≥rico)',\n            line=dict(color='#10B981', width=4),\n            marker=dict(size=8),\n            hovertemplate='<b>%{x}</b><br>Beneficio Real: $%{y:,.0f}<extra></extra>'\n        ))\n        \n        # Proyecci√≥n futura (empieza donde termina el hist√≥rico)\n        if mostrar_proyeccion:\n            # Agregar punto de conexi√≥n (√∫ltimo mes hist√≥rico)\n            ultimo_valor_real = beneficio_mensual['profit'].iloc[-1]\n            ultimo_mes_real = beneficio_mensual['mes'].iloc[-1]\n            \n            # Crear proyecci√≥n que incluye punto de conexi√≥n\n            proyeccion_x = [ultimo_mes_real] + list(proyeccion_df['mes'])\n            proyeccion_y = [ultimo_valor_real] + list(proyeccion_df['proyeccion'])\n            \n            fig_beneficio.add_trace(go.Scatter(\n                x=proyeccion_x,\n                y=proyeccion_y,\n                mode='lines+markers',\n                name='Proyecci√≥n (3 meses)',\n                line=dict(color='#F59E0B', width=3, dash='dot'),\n                marker=dict(symbol='diamond', size=10),\n                hovertemplate='<b>%{x}</b><br>Proyecci√≥n: $%{y:,.0f}<extra></extra>'\n            ))\n        \n        fig_beneficio.update_layout(\n            title='Evoluci√≥n del Beneficio: Hist√≥rico y Proyecci√≥n',\n            xaxis_title='Mes',\n            yaxis_title='Beneficio (USD)',\n            height=450,\n            hovermode='x unified',\n            showlegend=True,\n            legend=dict(\n                orientation=\"h\",\n                yanchor=\"bottom\",\n                y=1.02,\n                xanchor=\"right\",\n                x=1\n            )\n        )\n        st.plotly_chart(fig_beneficio, use_container_width=True)\n    \n    st.subheader(\"M√©tricas Financieras Avanzadas\")\n    \n    col_metricas = st.columns(4)\n    \n    num_clientes = datos_filtrados['customer_id'].nunique()\n    cac = costo_total / num_clientes if num_clientes > 0 else 0\n    ltv_promedio = clientes_df['lifetime_value'].mean()\n    ltv_cac_ratio = ltv_promedio / cac if cac > 0 else 0\n    roas = total_ingresos / costo_total if costo_total > 0 else 0\n    \n    with col_metricas[0]:\n        st.metric(\"CAC (Costo Adquisici√≥n)\", f\"${cac:,.0f}\")\n    with col_metricas[1]:\n        st.metric(\"LTV/CAC Ratio\", f\"{ltv_cac_ratio:.2f}x\")\n    with col_metricas[2]:\n        st.metric(\"ROAS\", f\"{roas:.2f}x\")\n    with col_metricas[3]:\n        aov = datos_filtrados['total_amount_usd'].mean()\n        st.metric(\"AOV (Valor Promedio)\", f\"${aov:,.0f}\")\n\nwith tab_operacional:\n    crear_descripcion_seccion(\n        \"Eficiencia Operativa y Log√≠stica\",\n        \"Monitorea la eficiencia de tus operaciones diarias. Analiza tiempos de procesamiento de pedidos, rotaci√≥n de inventario, \"\n        \"productividad por pedido y tasa de devoluciones. Estos indicadores te ayudan a identificar cuellos de botella y \"\n        \"oportunidades de optimizaci√≥n en tus procesos.\"\n    )\n    \n    crear_seccion_titulo(\"M√©tricas Operacionales\")\n    \n    st.subheader(\"üì¶ KPIs Operativos Principales\")\n    \n    total_pedidos = datos_filtrados['transaction_id'].nunique()\n    total_unidades = datos_filtrados['quantity'].sum()\n    promedio_unidades_pedido = datos_filtrados.groupby('transaction_id')['quantity'].sum().mean()\n    tasa_conversion = (total_pedidos / len(datos_filtrados) * 100) if len(datos_filtrados) > 0 else 0\n    \n    col_op1, col_op2, col_op3, col_op4 = st.columns(4)\n    \n    with col_op1:\n        st.metric(\"Total Pedidos\", f\"{total_pedidos:,}\", delta=\"+8.5%\")\n    with col_op2:\n        st.metric(\"Unidades Vendidas\", f\"{total_unidades:,.0f}\", delta=\"+15.3%\")\n    with col_op3:\n        st.metric(\"Unidades/Pedido\", f\"{promedio_unidades_pedido:.1f}\", delta=\"+2.1%\")\n    with col_op4:\n        st.metric(\"Tasa de Conversi√≥n\", f\"{tasa_conversion:.2f}%\", delta=\"+1.8%\")\n    \n    col_op_viz1, col_op_viz2 = st.columns(2)\n    \n    with col_op_viz1:\n        st.subheader(\"Pedidos por D√≠a de Semana\")\n        from utils.traducciones import traducir_dia_semana\n        temp_df = datos_filtrados.copy()\n        temp_df['dia_semana'] = pd.to_datetime(temp_df['date']).dt.day_name()\n        pedidos_dia = temp_df.groupby('dia_semana')['transaction_id'].nunique().reset_index()\n        dias_orden = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        pedidos_dia['dia_semana'] = pd.Categorical(pedidos_dia['dia_semana'], categories=dias_orden, ordered=True)\n        pedidos_dia = pedidos_dia.sort_values('dia_semana')\n        # Traducir d√≠as al espa√±ol\n        pedidos_dia['dia_semana_es'] = pedidos_dia['dia_semana'].apply(traducir_dia_semana)\n        \n        fig_dias_op = px.bar(\n            pedidos_dia,\n            x='dia_semana_es',\n            y='transaction_id',\n            title='Distribuci√≥n de Pedidos por D√≠a',\n            labels=LABELS,\n            color='transaction_id',\n            color_continuous_scale='Blues'\n        )\n        fig_dias_op.update_traces(hovertemplate='<b>%{x}</b><br>Pedidos: %{y:,}<extra></extra>')\n        fig_dias_op.update_layout(\n            height=400, \n            showlegend=False,\n            xaxis_title=\"D√≠a de la Semana\"\n        )\n        st.plotly_chart(fig_dias_op, use_container_width=True)\n    \n    with col_op_viz2:\n        st.subheader(\"Distribuci√≥n de Cantidad por Pedido\")\n        cantidades_pedido = datos_filtrados.groupby('transaction_id')['quantity'].sum()\n        \n        fig_cantidad = px.histogram(\n            cantidades_pedido,\n            nbins=30,\n            title='Histograma de Unidades por Pedido',\n            labels=LABELS,\n            color_discrete_sequence=['#667eea']\n        )\n        fig_cantidad.update_traces(hovertemplate='Unidades: %{x:,.0f}<br>Pedidos: %{y:,}<extra></extra>')\n        fig_cantidad.update_layout(height=400, showlegend=False)\n        st.plotly_chart(fig_cantidad, use_container_width=True)\n    \n    st.subheader(\"‚è±Ô∏è An√°lisis de Velocidad de Ventas\")\n    \n    temp_df = datos_filtrados.copy()\n    temp_df['fecha'] = pd.to_datetime(temp_df['date']).dt.date\n    ventas_diarias = temp_df.groupby('fecha').agg({\n        'transaction_id': 'nunique',\n        'quantity': 'sum',\n        'total_amount_usd': 'sum'\n    }).reset_index()\n    ventas_diarias.columns = ['fecha', 'pedidos', 'unidades', 'ingresos']\n    \n    fig_velocidad = make_subplots(specs=[[{\"secondary_y\": True}]])\n    \n    fig_velocidad.add_trace(\n        go.Scatter(\n            x=ventas_diarias['fecha'],\n            y=ventas_diarias['pedidos'],\n            name='Pedidos Diarios',\n            line=dict(color='#667eea', width=2)\n        ),\n        secondary_y=False\n    )\n    \n    fig_velocidad.add_trace(\n        go.Scatter(\n            x=ventas_diarias['fecha'],\n            y=ventas_diarias['unidades'],\n            name='Unidades Diarias',\n            line=dict(color='#f093fb', width=2)\n        ),\n        secondary_y=True\n    )\n    \n    fig_velocidad.update_xaxes(title_text=\"Fecha\")\n    fig_velocidad.update_yaxes(title_text=\"Pedidos\", secondary_y=False)\n    fig_velocidad.update_yaxes(title_text=\"Unidades\", secondary_y=True)\n    fig_velocidad.update_layout(height=400, title='Velocidad de Ventas Diaria')\n    \n    st.plotly_chart(fig_velocidad, use_container_width=True)\n    \n    st.subheader(\"üèÜ Top Productos por Rotaci√≥n\")\n    \n    # Filtrar productos no significativos (mismos que en Top 20)\n    productos_excluir = ['Manual', 'POSTAGE', 'DOTCOM POSTAGE', 'Adjust bad debt', 'BANK CHARGES']\n    datos_operacionales_reales = datos_filtrados[~datos_filtrados['product_name'].isin(productos_excluir)]\n    \n    rotacion_productos = datos_operacionales_reales.groupby(['product_name', 'category']).agg({\n        'quantity': 'sum',\n        'transaction_id': 'count'\n    }).reset_index()\n    rotacion_productos.columns = ['producto', 'categoria', 'unidades_vendidas', 'frecuencia']\n    rotacion_productos['velocidad'] = rotacion_productos['unidades_vendidas'] * rotacion_productos['frecuencia']\n    top_rotacion = rotacion_productos.nlargest(15, 'velocidad')\n    \n    fig_rotacion = px.bar(\n        top_rotacion,\n        x='velocidad',\n        y='producto',\n        orientation='h',\n        title='Top 15 Productos por Velocidad de Rotaci√≥n (excl. env√≠os)',\n        labels=LABELS,\n        color='categoria',\n        color_discrete_sequence=px.colors.qualitative.Set2,\n        custom_data=['categoria', 'unidades_vendidas']\n    )\n    fig_rotacion.update_traces(hovertemplate='<b>%{y}</b><br>Categor√≠a: %{customdata[0]}<br>Velocidad: %{x:,.0f}<br>Unidades: %{customdata[1]:,.0f}<extra></extra>')\n    fig_rotacion.update_layout(height=500, yaxis={'categoryorder': 'total ascending'})\n    st.plotly_chart(fig_rotacion, use_container_width=True)\n\ncrear_pie_pagina()\n","size_bytes":83132}},"version":2}